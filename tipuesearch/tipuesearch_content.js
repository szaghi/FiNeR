var tipuesearch = {"pages":[{"text":"FiNeR FiNeR FiNeR, Fortran INI ParseR and generator for FoRtraners FiNeR is a pure Fortran (KISS) library for IO of INI (config) files for modern (2003+) Fortran projects; FiNeR is Fortran 2003+ standard compliant; FiNeR is OOP designed; FiNeR is TDD designed; FiNeR is a Free, Open Source Project. Issues Compiler Support What is FiNeR? | Main features | Copyrights | Documentation | A Taste of FiNeR What is FiNeR? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, FiNeR provides an easy to use module library for input (parsing) and output (generating) INI (config) files. Go to Top Main features User-friendly methods for IO INI files: parsing files: automatic parsing of all sections (whose number is auto-detected); automatic parsing of all options of each section (whose number is auto-detected); unlimited polymorphic option-values extraction; generating files: user-friendly add/remove sections/options; unlimited polymorphic option-values setting; introspection: self-consistency checks; pretty-printings; loop over options; inquiring the presence of sections/options by name; errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights FiNeR is an open source project, it is distributed under a dual licensing system: the GPL v3 and the MIT licenses. Anyone is interest to use, to develop or to contribute to FiNeR is welcome: you are free to select the GPL license for FOSS projects or the MIT one for commercial softwares. Go to Top Documentation Besides this README file the FiNeR documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FiNeR Let us assume our goal is to parse a config file. It is as simple as USE Lib_INI_IO ... type ( Type_File_INI ) :: fini ! INI File. character ( len = :), allocatable :: source ! Testing string. real ( R4P ), allocatable :: array (:) ! Array option. integer ( I4P ) :: error ! Error code. ... source = '[section-1]' // new_line ( 'A' ) // & 'option-1 = one' // new_line ( 'A' ) // & 'option-2 = 2.' // new_line ( 'A' ) // & '           3.' // new_line ( 'A' ) // & 'option-3 = bar' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 = foo' call fini % load ( source = source ) allocate ( array ( 1 : fini % count_values ( section = 'section-1' , option = 'option-2' ))) call fini % get ( section = 'section-1' , option = 'option-2' , val = array , error = error ) if ( error == 0 ) then print * , array else ! errors occur... endif And what about the generation of an INI file? It is simple as parsing an old one: USE Lib_INI_IO ... type ( Type_File_INI ) :: fini ! INI File. ... call fini % add ( section = 'sec-foo' ) call fini % add ( section = 'sec-foo' , option = 'bar' , val =- 3 2.1_R8P ) call fini % add ( section = 'sec-foo' , option = 'baz' , val = ' hello FiNeR! ' ) call fini % add ( section = 'sec-foo' , option = 'array' , val = [ 1 , 2 , 3 , 4 ]) call fini % add ( section = 'sec-bar' ) call fini % add ( section = 'sec-bar' , option = 'bools' , val = [. true .,. false .,. false .]) call fini % save ( filename = 'foo.ini' ) A file named foo.ini is created. It contains something like: [sec-foo] bar = -0.321000000000000E+002 baz = hello FiNeR! array = +1 +2 +3 +4 [sec-bar] bools = T F F Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" FiNeR "},{"text":"Testing program for FiNeR, File INI Parser library for FoRtran poor men Source Code !< Testing program for FiNeR, File INI Parser library for FoRtran poor men program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for FiNeR, File INI Parser library for FoRtran poor men !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- use finer , only : file_ini_autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Testing FiNeR' call file_ini_autotest stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"sourcefile/test_driver.f90.html","title":"Test_Driver.f90 â€“ FiNeR"},{"text":"INI file class definition. Source Code !< INI file class definition. module finer_file_ini_t !----------------------------------------------------------------------------------------------------------------------------------- !< INI file class definition. !----------------------------------------------------------------------------------------------------------------------------------- use finer_backend use finer_option_t , only : option use finer_section_t , only : section use penf use stringifor use , intrinsic :: iso_fortran_env , only : stdout => output_unit !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: file_ini public :: file_ini_autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: file_ini !< INI file class. private character ( len = :), allocatable :: filename !< File name integer ( I4P ) :: Ns = 0 !< Number of sections. character ( 1 ) :: opt_sep = def_opt_sep !< Separator character of option name/value. type ( section ), allocatable :: sections (:) !< Sections. contains ! public methods generic :: add => add_section , & !< Add a section. add_option , & !< Add an option to a section (scalar). add_a_option !< Add an option to a section (array). procedure , pass ( self ) :: count_values !< Count option value(s). generic :: del => free_option_of_section , & !< Remove (freeing) an option of a section. free_section !< Remove (freeing) a section. procedure , pass ( self ) :: free !< Free dynamic memory destroyng file data. generic :: free_options => free_options_all , & !< Free all options. free_options_of_section , & !< Free all options of a section. free_option_of_section !< Free an option of a section. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_items !< Get list of couples option name/value. procedure , pass ( self ) :: has_option !< Inquire the presence of an option. procedure , pass ( self ) :: has_section !< Inquire the presence of a section. generic :: index => index_section , & !< Return the index of a section. index_option !< Return the index of an option. procedure , pass ( self ) :: load !< Load file data. generic :: loop => loop_options_section , & !< Loop over options of a section. loop_options !< Loop over all options. procedure , pass ( self ) :: print => print_file_ini !< Pretty printing data. procedure , pass ( self ) :: save => save_file_ini !< Save data. procedure , pass ( self ) :: section => section_file_ini !< Get section name once provided an index. ! operators overloading generic :: assignment ( = ) => assign_file_ini !< Procedure for section assignment overloading. ! private methods procedure , private , pass ( self ) :: add_a_option !< Add an option to a section (array). procedure , private , pass ( self ) :: add_option !< Add an option to a section (scalar). procedure , private , pass ( self ) :: add_section !< Add a section. procedure , private , pass ( self ) :: free_options_all !< Free all options of all sections. procedure , private , pass ( self ) :: free_options_of_section !< Free all options of a section. procedure , private , pass ( self ) :: free_option_of_section !< Free an option of a section. procedure , private , pass ( self ) :: free_section !< Free a section. procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: index_option !< Return the index of an option. procedure , private , pass ( self ) :: index_section !< Return the index of a section. procedure , private , pass ( self ) :: loop_options !< Loop over all options. procedure , private , pass ( self ) :: loop_options_section !< Loop over options of a section. procedure , private , pass ( self ) :: parse !< Parse file data. ! assignments procedure , private , pass ( lhs ) :: assign_file_ini !< Assignment overloading. endtype file_ini !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental function count_values ( self , delimiter , section_name , option_name ) result ( Nv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the number of values of option into section data. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then Nv = self % sections ( s )% count_values ( delimiter = dlm , option_name = option_name ) exit endif enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_values elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % filename )) deallocate ( self % filename ) if ( allocated ( self % sections )) then call self % sections % free deallocate ( self % sections ) endif self % Ns = 0 self % opt_sep = def_opt_sep return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free pure subroutine get_items ( self , items ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get list of couples option name/value. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( len = :), allocatable , intent ( out ) :: items (:,:) !< Items, list of couples option name/value for all options [1:No,1:2]. character ( len = :), allocatable :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: mx_chars !< Maximum number of chars into name/value within all options. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: No !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mx_chars = MinI4P if ( allocated ( self % sections )) then No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then mx_chars = max ( mx_chars , self % sections ( s )% max_chars_len ()) No = No + self % sections ( s )% options_number () endif enddo if (( mx_chars > 0 ). and .( No > 0 )) then allocate ( character ( mx_chars ) :: items ( 1 : No , 1 : 2 )) No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then do o = 1 , self % sections ( s )% options_number () No = No + 1 call self % sections ( s )% option_pairs ( option_index = o , pairs = pairs ) items ( No , 1 ) = pairs ( 1 ) items ( No , 2 ) = pairs ( 2 ) enddo endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_items function has_option ( self , option_name , section_name ) result ( pres ) !--------------------------------------------------------------------------------------------------------------------------------- !< Inquire the presence of (at least one) option with the name passed. !< !< Optionall, the first matching section name is returned. !< !< @note All sections are searched and the first occurence is returned. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), optional , intent ( inout ) :: section_name !< Section name. logical :: pres !< Inquiring flag. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pres = . false . if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) pres = ( self % sections ( s )% index ( option_name = option_name ) > 0 ) if ( pres ) then if ( present ( section_name )) section_name = self % sections ( s )% name () exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction has_option elemental function has_section ( self , section_name ) result ( pres ) !--------------------------------------------------------------------------------------------------------------------------------- !< Inquire the presence of (at least one) section with the name passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. logical :: pres !< Inquiring flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pres = ( self % index ( section_name = section_name ) > 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction has_section subroutine load ( self , separator , filename , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get file data from a file or a source string. !< !<### Usage !< !<##### Loading from a file !<```bash !<type(file_ini):: fini !<call fini%load(filename='path_to_my_file.ini') !<``` !< !<##### Loading from a source string !<```bash !<type(file_ini):: fini !<call fini%load(source='[section-1] option-1=one [section-2] option-2=due') !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( 1 ), optional , intent ( in ) :: separator !< Separator of options name/value. character ( * ), optional , intent ( in ) :: filename !< File name. character ( * ), optional , intent ( in ) :: source !< File source. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: sourced !< Dummy source string. type ( string ) :: source_ !< Dummy source string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_source_missing if ( present ( separator )) self % opt_sep = separator if ( present ( filename )) then self % filename = trim ( adjustl ( filename )) ! to remove after StringiFor adoption call source_ % read_file ( file = self % filename ) sourced = source_ % chars () ! call read_file_as_stream(filename=self%filename, fast_read=.true., stream=sourced) ! to remove after StringiFor adoption call self % parse ( source = sourced , error = errd ) elseif ( present ( source )) then call self % parse ( source = source , error = errd ) elseif ( allocated ( self % filename )) then ! to remove after StringiFor adoption call source_ % read_file ( file = self % filename ) sourced = source_ % chars () ! call read_file_as_stream(filename=self%filename, fast_read=.true., stream=sourced) call self % parse ( source = sourced , error = errd ) endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine load subroutine print_file_ini ( self , unit , pref , retain_comments , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print data with a pretty format. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% print ( pref = prefd , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_file_ini subroutine save_file_ini ( self , retain_comments , iostat , iomsg , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save data. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( * ), optional , intent ( in ) :: filename !< File name. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: unit !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( present ( filename )) self % filename = filename if ( allocated ( self % filename ). and . allocated ( self % sections )) then open ( newunit = unit , file = self % filename , action = 'WRITE' , iostat = iostatd , iomsg = iomsgd ) do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo close ( unit = unit , iostat = iostatd , iomsg = iomsgd ) endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_file_ini pure function section_file_ini ( self , section_index ) result ( sname ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get section name once an index (valid) is provided. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: section_index !< Section index. character ( len = :), allocatable :: sname !< Section name. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then if (( section_index >= lbound ( self % sections , dim = 1 )). and .( section_index <= ubound ( self % sections , dim = 1 ))) then sname = self % sections ( section_index )% name () endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction section_file_ini ! private methods pure subroutine add_a_option ( self , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with array value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val ( 1 :) !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_a_option pure subroutine add_option ( self , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_option pure subroutine add_section ( self , error , section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add a section. !< !< If the section already exists, it is left unchanged. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: errd !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section if ( allocated ( self % sections )) then if ( self % index ( section_name = section_name ) == 0 ) then ! section not present allocate ( sections ( 1 : size ( self % sections , dim = 1 ) + 1 )) sections ( 1 : size ( self % sections , dim = 1 )) = self % sections sections ( size ( self % sections , dim = 1 ) + 1 ) = section ( section_name = trim ( adjustl ( section_name ))) call move_alloc ( sections , self % sections ) self % Ns = self % Ns + 1 endif else allocate ( self % sections ( 1 : 1 )) self % sections ( 1 ) = section ( section_name = section_name ) self % Ns = self % Ns + 1 endif if ( self % index ( section_name = section_name ) > 0 ) errd = 0 if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_section elemental subroutine free_options_all ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of all sections. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) call self % sections % free_options return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_options_all elemental subroutine free_option_of_section ( self , section_name , option_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of a section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option  name. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s = self % index ( section_name = section_name ) if ( s > 0 ) call self % sections ( s )% free_option ( option_name = option_name ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_option_of_section elemental subroutine free_options_of_section ( self , section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of a section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% free_options exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_options_of_section elemental subroutine free_section ( self , section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of a section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s = self % index ( section_name = section_name ) if ( s > 0 ) then allocate ( sections ( 1 : size ( self % sections , dim = 1 ) - 1 )) if ( s == 1 ) then sections = self % sections ( 2 :) elseif ( s == size ( self % sections , dim = 1 )) then sections = self % sections (: s - 1 ) else sections (: s - 1 ) = self % sections (: s - 1 ) sections ( s : ) = self % sections ( s + 1 :) endif call move_alloc ( sections , self % sections ) self % Ns = self % Ns - 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_section subroutine get_a_option ( self , delimiter , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option value (array) !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( delimiter = dlm , error = errd , option_name = option_name , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_a_option subroutine get_option ( self , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( error = errd , option_name = option_name , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_option elemental function index_option ( self , back , section_name , option_name ) result ( ind ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the index of the option (inside a  section) matching the name(s) passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. logical , optional , intent ( in ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( in ) :: option_name !< Option  name. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back s = self % index ( section_name = section_name , back = backd ) if ( s > 0 ) then ind = self % sections ( s )% index ( option_name = option_name , back = backd ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction index_option elemental function index_section ( self , back , section_name ) result ( ind ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the index of the section matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( IN ) :: self !< File data. logical , optional , intent ( IN ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( IN ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do s = size ( self % sections , dim = 1 ), 1 , - 1 if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo else do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction index_section function loop_options_section ( self , section_name , option_pairs ) result ( again ) !--------------------------------------------------------------------------------------------------------------------------------- !< Loop returning option name/value defined into section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- again = . false . s = self % index ( section_name = section_name ) if ( s > 0 ) then again = self % sections ( s )% loop ( option_pairs = option_pairs ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction loop_options_section recursive function loop_options ( self , option_pairs ) result ( again ) !--------------------------------------------------------------------------------------------------------------------------------- !< Loop returning option name/value defined into all sections. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( IN ) :: self !< File data. character ( len = :), allocatable , intent ( OUT ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. logical , save :: againO = . false . !< Flag continuing the loop. integer ( I4P ), save :: s = 0 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- again = . false . if ( allocated ( self % sections )) then if ( s == 0 ) then s = lbound ( self % sections , dim = 1 ) againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) again = . true . elseif ( s < ubound ( self % sections , dim = 1 )) then if (. not . againO ) s = s + 1 againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) if (. not . againO ) then again = self % loop ( option_pairs = option_pairs ) else again = . true . endif else s = 0 againO = . false . again = . false . endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction loop_options subroutine parse ( self , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse file either from the self source data or from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: source !< String source. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. type ( string ) :: dummy_str !< Dummy string. character ( len = len ( source )), allocatable :: toks (:) !< Dummies tokens. character ( len ( source )) :: dummy !< Dummy string for parsing sections. integer ( I4P ) :: Ns !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: ss !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_source_missing ! to remove after StringiFor adoption dummy_str = source call dummy_str % split ( tokens = tokens , sep = new_line ( 'a' )) allocate ( toks ( 1 : size ( tokens , dim = 1 ))) do s = 1 , size ( tokens , dim = 1 ) toks ( s ) = tokens ( s )% chars () enddo ! call tokenize(strin=source, delimiter=new_line('A'), toks=toks) ! to remove after StringiFor adoption Ns = 0 s = 0 do while ( s + 1 <= size ( toks , dim = 1 )) s = s + 1 if ( scan ( adjustl ( toks ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( toks ( s ))), \"[\" ) == 1 ) then Ns = Ns + 1 dummy = trim ( adjustl ( toks ( s ))) // new_line ( 'A' ) ss = s do while ( ss + 1 <= size ( toks , dim = 1 )) ss = ss + 1 if ( index ( trim ( adjustl ( toks ( ss ))), \"[\" ) == 1 ) then ! new section... go back exit else ! continuation of current section dummy = trim ( adjustl ( dummy )) // new_line ( 'A' ) // trim ( adjustl ( toks ( ss ))) toks ( ss ) = comments ! forcing skip this in the following scan endif enddo toks ( s ) = trim ( adjustl ( dummy )) endif enddo if ( Ns > 0 ) then if ( allocated ( self % sections )) deallocate ( self % sections ) ; allocate ( self % sections ( 1 : Ns )) s = 0 ss = 0 do while ( s + 1 <= size ( toks , dim = 1 )) s = s + 1 if ( scan ( adjustl ( toks ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( toks ( s ))), \"[\" ) == 1 ) then ss = ss + 1 call self % sections ( ss )% parse ( sep = self % opt_sep , source = toks ( s ), error = errd ) endif enddo endif self % Ns = size ( self % sections , dim = 1 ) if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse ! assignments elemental subroutine assign_file_ini ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two INI files. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: lhs !< Left hand side. type ( file_ini ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % filename )) lhs % filename = rhs % filename if ( allocated ( rhs % sections )) then if ( allocated ( lhs % sections )) deallocate ( lhs % sections ) ; allocate ( lhs % sections ( 1 : size ( rhs % sections , dim = 1 ))) lhs % sections = rhs % sections endif lhs % Ns = rhs % Ns return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_file_ini ! non TBP methods subroutine file_ini_autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Autotest the library functionalities. !--------------------------------------------------------------------------------------------------------------------------------- type ( file_ini ) :: fini !< INI File. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. real ( R4P ), allocatable :: array (:) !< Array option. integer ( I4P ) :: error !< Error code. character ( len = :), allocatable :: items (:,:) !< List of all options name/value couples. character ( len = :), allocatable :: item (:) !< Option name/value couple. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- source = '[section-1]' // new_line ( 'A' ) // & 'option-1 = one' // new_line ( 'A' ) // & 'option-2 = 2.' // new_line ( 'A' ) // & '           3. ; this is an inline comment' // new_line ( 'A' ) // & 'option-3 = bar ; this is an inline comment' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 = foo' print \"(A)\" , '' print \"(A)\" , \"Testing parsing procedures\" print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % load ( source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" string = '   ' call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-1 has values: ' , string allocate ( array ( 1 : fini % count_values ( section_name = 'section-1' , option_name = 'option-2' ))) call fini % get ( section_name = 'section-1' , option_name = 'option-2' , val = array , error = error ) if ( error == 0 ) print \"(A,3(F4.1,1X))\" , '  option-2 of section-1 has values: ' , array call fini % get ( section_name = 'section-1' , option_name = 'option-3' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-3 of section-1 has values: ' , string call fini % get ( section_name = 'section-2' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-2 has values: ' , string print \"(A)\" , '' print \"(A)\" , \"Parsed data will be saved as (having retained inline comments that are trimmed out by default):\" call fini % print ( pref = '  ' , unit = stdout , retain_comments = . true .) call fini % save ( filename = 'foo.ini' , retain_comments = . true .) call fini % free print \"(A)\" , '' print \"(A)\" , \"Testing generating procedures\" call fini % add ( section_name = 'sec-foo' ) call fini % add ( section_name = 'sec-foo' , option_name = 'bar' , val =- 3 2.1_R8P ) call fini % add ( section_name = 'sec-foo' , option_name = 'baz' , val = ' hello FiNeR! ' ) call fini % add ( section_name = 'sec-foo' , option_name = 'array' , val = [ 1 , 2 , 3 , 4 ]) call fini % add ( section_name = 'sec-bar' ) call fini % add ( section_name = 'sec-bar' , option_name = 'bools' , val = [. true .,. false .,. false .]) call fini % add ( section_name = 'sec-bartolomeo' ) call fini % add ( section_name = 'sec-bartolomeo' , option_name = 'help' , val = 'I am Bartolomeo' ) print \"(A)\" , \"The autogenerated INI file will be saved as:\" call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing option baz\" call fini % del ( section_name = 'sec-foo' , option_name = 'baz' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing section sec-bar\" call fini % del ( section_name = 'sec-bar' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing introspective methods\" print \"(A,L1)\" , \"Is there option bar? \" , fini % has_option ( option_name = 'bar' ) print \"(A,L1)\" , \"Is there option baz? \" , fini % has_option ( option_name = 'baz' ) print \"(A,L1)\" , \"Is there section sec-bar? \" , fini % has_section ( section_name = 'sec-bar' ) print \"(A,L1)\" , \"Is there section sec-foo? \" , fini % has_section ( section_name = 'sec-foo' ) print \"(A)\" , '' print \"(A)\" , \"What are all options name/values couples? Can I have a list? Yes, you can:\" call fini % get_items ( items = items ) do i = 1 , size ( items , dim = 1 ) print \"(A)\" , trim ( items ( i , 1 )) // ' = ' // trim ( items ( i , 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over options of a section:\" do s = 1 , fini % Ns print \"(A)\" , fini % section ( s ) do while ( fini % loop ( section_name = fini % section ( s ), option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over all options:\" do while ( fini % loop ( option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing custom separator of option name/value:, use ':' instead of '='\" source = '[section-1]' // new_line ( 'A' ) // & 'option-1 : one' // new_line ( 'A' ) // & 'option-2 : 2.' // new_line ( 'A' ) // & '           3.' // new_line ( 'A' ) // & 'option-3 : bar' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 : foo' print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % free call fini % load ( separator = ':' , source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" call fini % print ( pref = '  ' , unit = stdout ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine file_ini_autotest endmodule finer_file_ini_t","tags":"","loc":"sourcefile/finer_file_ini_t.f90.html","title":"finer_file_ini_t.f90 â€“ FiNeR"},{"text":"Option class definition. Source Code !< Option class definition. module finer_option_t !----------------------------------------------------------------------------------------------------------------------------------- !< Option class definition. !----------------------------------------------------------------------------------------------------------------------------------- use finer_backend use penf use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: option !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: option !< Option data of sections. private type ( string ) :: oname !< Option name. type ( string ) :: ovals !< Option values. type ( string ) :: ocomm !< Eventual option inline comment. contains ! public methods procedure , pass ( self ) :: count_values !< Counting option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_pairs !< Return option name/values pairs. procedure , pass ( self ) :: name_len !< Return option name length. procedure , pass ( self ) :: parse !< Parse option data. procedure , pass ( self ) :: print => print_option !< Pretty print data. procedure , pass ( self ) :: save => save_option !< Save data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: values_len !< Return option values length. ! operators overloading generic :: assignment ( = ) => assign_option !< Assignment overloading. generic :: operator ( == ) => option_eq_string , & option_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_comment !< Parse option inline comment. procedure , private , pass ( self ) :: parse_name !< Parse option name. procedure , private , pass ( self ) :: parse_value !< Parse option values. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_option !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: option_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: option_eq_character !< Equal to character logical operator. endtype option interface option !< Overload `option` name with a function returning a new (itiliazed) option instance. module procedure new_option endinterface option !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental function count_values ( self , delimiter ) result ( Nv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the number of values of option data. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % ovals % is_allocated ()) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter Nv = self % ovals % count ( dlm ) + 1 else Nv = 0 endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_values elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % oname % free call self % ovals % free call self % ocomm % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free pure subroutine get_pairs ( self , pairs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return option name/values pairs. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: Nc !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nc = max ( self % oname % len (), self % ovals % len ()) allocate ( character ( Nc ) :: pairs ( 1 : 2 )) pairs ( 1 ) = self % oname % chars () pairs ( 2 ) = self % ovals % chars () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_pairs elemental function name_len ( self ) result ( length ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return option name length. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option name length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % oname % is_allocated ()) length = self % oname % len () return !--------------------------------------------------------------------------------------------------------------------------------- endfunction name_len elemental function values_len ( self ) result ( length ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return option values length. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option values length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % ovals % is_allocated ()) length = self % ovals % len () return !--------------------------------------------------------------------------------------------------------------------------------- endfunction values_len elemental subroutine parse ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse option data from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_option if ( scan ( adjustl ( source ), comments ) == 1 ) return call self % parse_name ( sep = sep , source = source , error = error ) call self % parse_value ( sep = sep , source = source , error = error ) call self % parse_comment return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse ! private methods subroutine get_option ( self , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< for getting option data value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_option_vals if ( self % ovals % is_allocated ()) then errd = 0 select type ( val ) #ifdef r16p type is ( real ( R16P )) val = self % ovals % to_number ( kind = 1._R16P ) #endif type is ( real ( R8P )) val = self % ovals % to_number ( kind = 1._R8P ) type is ( real ( R4P )) val = self % ovals % to_number ( kind = 1._R4P ) type is ( integer ( I8P )) val = self % ovals % to_number ( kind = 1_I8P ) type is ( integer ( I4P )) val = self % ovals % to_number ( kind = 1_I4P ) type is ( integer ( I2P )) val = self % ovals % to_number ( kind = 1_I2P ) type is ( integer ( I1P )) val = self % ovals % to_number ( kind = 1_I1P ) type is ( logical ) buffer = self % ovals % chars () read ( buffer , * ) val type is ( character ( * )) val = self % ovals % chars () endselect endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_option subroutine get_a_option ( self , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option data values (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. type ( string ), allocatable :: valsV (:) !< String array of values. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. integer ( I4P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_option_vals dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( self % ovals % is_allocated ()) then errd = 0 call self % ovals % split ( tokens = valsV , sep = dlm ) Nv = size ( valsV , dim = 1 ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R16P ) enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R8P ) enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R4P ) enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I8P ) enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I4P ) enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I2P ) enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I1P ) enddo type is ( logical ) do v = 1 , Nv buffer = valsV ( v )% chars () read ( buffer , * ) val ( v ) enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v )% chars () enddo endselect endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_a_option elemental subroutine parse_comment ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse eventaul option inline comment trimming it out from pure value string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. integer ( I4P ) :: pos !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % ovals % is_allocated ()) then pos = self % ovals % index ( inline_comment ) if ( pos > 0 ) then if ( pos < self % ovals % len ()) self % ocomm = trim ( adjustl ( self % ovals % slice ( pos + 1 , self % ovals % len ()))) self % ovals = trim ( adjustl ( self % ovals % slice ( 1 , pos - 1 ))) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_comment elemental subroutine parse_name ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse option name from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_option_name pos = index ( source , sep ) if ( pos > 0 ) then self % oname = trim ( adjustl ( source (: pos - 1 ))) error = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_name elemental subroutine parse_value ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse option value from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_option_vals pos = index ( source , sep ) if ( pos > 0 ) then if ( pos < len ( source )) self % ovals = trim ( adjustl ( source ( pos + 1 :))) error = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_value subroutine print_option ( self , unit , retain_comments , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print data with a pretty format. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % oname % is_allocated ()) then prefd = '' ; if ( present ( pref )) prefd = pref comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_option pure subroutine set_option ( self , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option data value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val !< Value. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( val ) #ifdef r16p type is ( real ( R16P )) self % ovals = val #endif type is ( real ( R8P )) self % ovals = val type is ( real ( R4P )) self % ovals = val type is ( integer ( I8P )) self % ovals = val type is ( integer ( I4P )) self % ovals = val type is ( integer ( I2P )) self % ovals = val type is ( integer ( I1P )) self % ovals = val type is ( logical ) self % ovals = trim ( str ( n = val )) type is ( character ( * )) self % ovals = val endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_option pure subroutine set_a_option ( self , val , delimiter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option data value (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val ( 1 :) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter self % ovals = '' select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () #endif type is ( real ( R8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( real ( R4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I2P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I1P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( logical ) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( character ( * )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( val ( v )) enddo self % ovals = self % ovals % strip () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_a_option subroutine save_option ( self , unit , retain_comments , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save data. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % oname % is_allocated ()) then comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_option ! assignments elemental subroutine assign_option ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two options. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: lhs !< Left hand side. type ( option ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( rhs % oname % is_allocated ()) lhs % oname = rhs % oname if ( rhs % ovals % is_allocated ()) lhs % ovals = rhs % ovals if ( rhs % ocomm % is_allocated ()) lhs % ocomm = rhs % ocomm return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_option ! logical operators elemental function option_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % oname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction option_eq_string elemental function option_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % oname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction option_eq_character ! non TBP methods elemental function new_option ( option_name , option_values , option_comment ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a new (initiliazed) option instance. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ), optional :: option_name !< Option name. character ( * ), intent ( in ), optional :: option_values !< Option values. character ( * ), intent ( in ), optional :: option_comment !< Option comment. type ( option ) :: new_option !< New (initiliazed) option instance. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( option_name )) new_option % oname = option_name if ( present ( option_values )) new_option % ovals = option_values if ( present ( option_comment )) new_option % ocomm = option_comment return !--------------------------------------------------------------------------------------------------------------------------------- endfunction new_option endmodule finer_option_t","tags":"","loc":"sourcefile/finer_option_t.f90.html","title":"finer_option_t.F90 â€“ FiNeR"},{"text":"Portability Environment for Fortran poor people. Source Code !< Portability Environment for Fortran poor people. module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !<{!README-PENF.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 â€“ FiNeR"},{"text":"FiNeR backends: globals definition. Source Code !< FiNeR backends: globals definition. module finer_backend !----------------------------------------------------------------------------------------------------------------------------------- !< FiNeR backends: globals definition. !----------------------------------------------------------------------------------------------------------------------------------- use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none save private !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), parameter , public :: err_option_name = 1 !< Error flag for trapping errors in option name. integer ( I4P ), parameter , public :: err_option_vals = 2 !< Error flag for trapping errors in option values. integer ( I4P ), parameter , public :: err_option = 3 !< Error flag for trapping errors in option. integer ( I4P ), parameter , public :: err_section_name = 4 !< Error flag for trapping errors in section name. integer ( I4P ), parameter , public :: err_section_options = 5 !< Error flag for trapping errors in section options. integer ( I4P ), parameter , public :: err_section = 6 !< Error flag for trapping errors in section. integer ( I4P ), parameter , public :: err_source_missing = 7 !< Error flag for trapping errors in file when source is missing. character ( 1 ), parameter , public :: def_opt_sep = '=' !< Default separator of option name/value. character ( * ), parameter , public :: comments = \"!;#\" !< Characters used for defining a comment line. character ( 1 ), parameter , public :: inline_comment = ';' !< Inline comment delimiter. !----------------------------------------------------------------------------------------------------------------------------------- endmodule finer_backend","tags":"","loc":"sourcefile/finer_backend.f90.html","title":"finer_backend.f90 â€“ FiNeR"},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Source Code !< StringiFor, Strings Fortran, yet another stringify Fortran module module stringifor !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, Strings Fortran, yet another stringify Fortran module !----------------------------------------------------------------------------------------------------------------------------------- use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P use stringifor_string_t , only : CK , & sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim , & string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! expose StingiFor objects public :: CK public :: string ! expose StingiFor overloaded builtins public :: adjustl , adjustr , count , index , len , len_trim , repeat , scan , trim ! expose StingiFor new procedures public :: read_file , read_lines , write_file , write_lines ! expose PENF kinds public :: I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! builtins overloading interfaces interface adjustl !< Builtin adjustl overloading. module procedure sadjustl_character endinterface adjustl interface adjustr !< Builtin adjustr overloading. module procedure sadjustr_character endinterface adjustr interface count !< Builtin count overloading. module procedure count_substring endinterface interface index !< Builtin index overloading. module procedure sindex_string_string , sindex_string_character , sindex_character_string endinterface index interface len !< Builtin len overloading. module procedure slen endinterface len interface len_trim !< Builtin len_trim overloading. module procedure slen_trim endinterface len_trim interface repeat !< Builtin repeat overloading. module procedure srepeat_string_string endinterface repeat interface scan !< Builtin scan overloading. module procedure sscan_string_string , sscan_string_character , sscan_character_string endinterface scan interface trim !< Builtin trim overloading. module procedure strim endinterface trim !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function count_substring ( string_ , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string_ !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string_ )) return c1 = 1 do c2 = index ( string = string_ ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring subroutine read_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file subroutine read_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines subroutine write_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected-formatted unit. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines subroutine write_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html","title":"stringifor.F90 â€“ FiNeR"},{"text":"Section class definition. Source Code !< Section class definition. module finer_section_t !----------------------------------------------------------------------------------------------------------------------------------- !< Section class definition. !----------------------------------------------------------------------------------------------------------------------------------- use finer_backend use finer_option_t , only : option use penf use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: section !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: section !< Section data of file INI. private character ( len = :), allocatable :: sname !< Section name. type ( option ), allocatable :: options (:) !< Section options. contains ! public methods generic :: add => add_option , & !< Add an option (scalar). add_a_option !< Add an option (array). procedure , pass ( self ) :: count_values !< Count option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: free_options !< Free all options. procedure , pass ( self ) :: free_option !< Free a option. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: has_options !< Inquire if section has options. procedure , pass ( self ) :: index => index_option !< Return the index of an option. procedure , pass ( self ) :: loop !< Loop over options. procedure , pass ( self ) :: max_chars_len !< Return max len of option-name/values on all options. procedure , pass ( self ) :: name !< Return section name. procedure , pass ( self ) :: options_number !< Return the options number. procedure , pass ( self ) :: option_pairs !< Return an option pairs. procedure , pass ( self ) :: parse !< Parse section data. procedure , pass ( self ) :: print => print_section !< Pretty print data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: save => save_section !< Save data. ! operators overloading generic :: assignment ( = ) => assign_section !< Assignment overloading. generic :: operator ( == ) => section_eq_string , & section_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: add_option !< Add an option (scalar). procedure , private , pass ( self ) :: add_a_option !< Add an option (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_name !< Get section name. procedure , private , pass ( self ) :: parse_options !< Get section options. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_section !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: section_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: section_eq_character !< Equal to character logical operator. endtype section interface section !< Overload `section` name with a function returning a new (itiliazed) section instance. module procedure new_section endinterface section !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental function count_values ( self , option_name , delimiter ) result ( Nv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the number of values of option into section data. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then Nv = self % options ( o )% count_values ( delimiter = dlm ) exit endif enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_values elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sname )) deallocate ( self % sname ) if ( allocated ( self % options )) then call self % options % free deallocate ( self % options ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine free_options ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then call self % options % free deallocate ( self % options ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_options elemental subroutine free_option ( self , option_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free an option. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then o = self % index ( option_name = option_name ) if ( o > 0 ) then allocate ( options ( 1 : size ( self % options , dim = 1 ) - 1 )) if ( o == 1 ) then options = self % options ( 2 :) elseif ( o == size ( self % options , dim = 1 )) then options = self % options (: o - 1 ) else options (: o - 1 ) = self % options (: o - 1 ) options ( o : ) = self % options ( o + 1 :) endif call move_alloc ( options , self % options ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_option elemental function has_options ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Inquire is section has options (at least one). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. logical :: has_options !< Inquire result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- has_options = allocated ( self % options ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction has_options elemental function index_option ( self , option_name , back ) result ( ind ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the index of the option matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. logical , optional , intent ( in ) :: back !< If back appears with the value true, the last matching index is returned. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ind = 0 if ( allocated ( self % options )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do o = size ( self % options , dim = 1 ), 1 , - 1 if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo else do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction index_option function loop ( self , option_pairs ) result ( again ) !--------------------------------------------------------------------------------------------------------------------------------- !< Loop returning option name/value defined into section. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ), save :: o = 0 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- again = . false . if ( allocated ( self % options )) then if ( o == 0 ) then o = lbound ( self % options , dim = 1 ) call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . elseif ( o < ubound ( self % options , dim = 1 )) then o = o + 1 call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . else o = 0 again = . false . endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction loop elemental function max_chars_len ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of characters between option-name/option-values on all options. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer :: max_chars_len !< Inquire result. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_chars_len = MinI4P if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) max_chars_len = max ( max_chars_len , self % options ( o )% name_len (), self % options ( o )% values_len ()) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_chars_len pure function name ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return section name. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( len = len ( self % sname )) :: name !< Section data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sname )) name = self % sname return !--------------------------------------------------------------------------------------------------------------------------------- endfunction name pure subroutine option_pairs ( self , option_index , pairs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return an option pairs. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Option data. integer , intent ( in ) :: option_index !< Option index. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % options ( option_index )% get_pairs ( pairs = pairs ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine option_pairs elemental function options_number ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the options number. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer :: options_number !< Options number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) options_number = size ( self % options , dim = 1 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction options_number elemental subroutine parse ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Gett section data from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % parse_name ( source = source , error = error ) call self % parse_options ( sep = sep , source = source , error = error ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse subroutine print_section ( self , unit , retain_comments , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print data with a pretty format. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% print ( pref = prefd // '  ' , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_section subroutine save_section ( self , unit , retain_comments , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save data. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_section ! private methods pure subroutine add_option ( self , option_name , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options if ( allocated ( self % options )) then call self % set ( error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_option pure subroutine add_a_option ( self , option_name , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with array value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Option value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = err_section_options if ( allocated ( self % options )) then call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_a_option subroutine get_option ( self , option_name , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( error = errd , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_option subroutine get_a_option ( self , option_name , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for getting option value (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( delimiter = dlm , error = errd , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_a_option elemental subroutine parse_name ( self , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get section name from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos ( 1 : 2 ) !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_section_name pos ( 1 ) = index ( source , \"[\" ) pos ( 2 ) = index ( source , \"]\" ) if ( all ( pos > 0 )) then self % sname = trim ( adjustl ( source ( pos ( 1 ) + 1 : pos ( 2 ) - 1 ))) error = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_name elemental subroutine parse_options ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get section options from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. character ( len ( source )) :: osource !< String containing options data. character ( len ( source )), allocatable :: options (:) !< Options strings tokenized. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. character ( len ( source )) :: dummy !< Dummy string for parsing options. type ( string ) :: dummy_str !< Dummy string. integer ( I4P ) :: No !< Counter. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: oo !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = 0 osource = trim ( adjustl ( source ( index ( source , \"]\" ) + 1 :))) ! to remove after StringiFor adoption dummy_str = osource call dummy_str % split ( tokens = tokens , sep = new_line ( 'a' )) allocate ( options ( 1 : size ( tokens , dim = 1 ))) do o = 1 , size ( tokens , dim = 1 ) options ( o ) = tokens ( o )% chars () enddo ! call tokenize(strin=osource, delimiter=new_line('A'), toks=options) ! to remove after StringiFor adoption No = 0 o = 0 do while ( o + 1 <= size ( options , dim = 1 )) o = o + 1 if ( scan ( adjustl ( options ( o )), comments ) == 1 ) cycle if ( index ( options ( o ), sep ) > 0 ) then No = No + 1 dummy = options ( o ) oo = o do while ( oo + 1 <= size ( options , dim = 1 )) oo = oo + 1 if ( index ( options ( oo ), sep ) > 0 ) then ! new option... go back exit else ! continuation of current option dummy = trim ( adjustl ( dummy )) // \" \" // trim ( adjustl ( options ( oo ))) options ( oo ) = comments ! forcing skip this in the following scan endif enddo options ( o ) = trim ( adjustl ( dummy )) endif enddo if ( No > 0 ) then if ( allocated ( self % options )) deallocate ( self % options ) ; allocate ( self % options ( 1 : No )) o = 0 oo = 0 do while ( o + 1 <= size ( options , dim = 1 )) o = o + 1 if ( scan ( adjustl ( options ( o )), comments ) == 1 ) cycle if ( index ( options ( o ), sep ) > 0 ) then oo = oo + 1 call self % options ( oo )% parse ( sep = sep , source = options ( o ), error = error ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_options pure subroutine set_option ( self , option_name , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_option pure subroutine set_a_option ( self , option_name , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option value (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = err_section_options if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( delimiter = dlm , val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_a_option ! assignments elemental subroutine assign_section ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two sections. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( section ), intent ( INOUT ) :: lhs !< Left hand side. type ( section ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % sname )) lhs % sname = rhs % sname if ( allocated ( rhs % options )) then if ( allocated ( lhs % options )) deallocate ( lhs % options ) ; allocate ( lhs % options ( 1 : size ( rhs % options , dim = 1 ))) lhs % options = rhs % options endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_section ! logical operators elemental function section_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % sname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction section_eq_string elemental function section_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % sname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction section_eq_character ! non TBP methods elemental function new_section ( section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a new (initiliazed) section instance. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ), optional :: section_name !< Option name. type ( section ) :: new_section !< New (initiliazed) section instance. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( section_name )) new_section % sname = section_name return !--------------------------------------------------------------------------------------------------------------------------------- endfunction new_section endmodule finer_section_t","tags":"","loc":"sourcefile/finer_section_t.f90.html","title":"finer_section_t.f90 â€“ FiNeR"},{"text":"KISS library for packing heterogeneous data into single (homogeneous) packed one. Source Code !< KISS library for packing heterogeneous data into single (homogeneous) packed one. module befor64_pack_data_m !----------------------------------------------------------------------------------------------------------------------------------- !< KISS library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: pack_data !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface pack_data !< Pack different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```fortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```fortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4 pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2 endmodule befor64_pack_data_m","tags":"","loc":"sourcefile/befor64_pack_data_m.f90.html","title":"befor64_pack_data_m.F90 â€“ FiNeR"},{"text":"BeFoR64, Base64 encoding/decoding library for FoRtran poor people. Source Code !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. module befor64 !----------------------------------------------------------------------------------------------------------------------------------- !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. !<{!README-BeFoR64.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. use befor64_pack_data_m ! Library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: is_b64_initialized , b64_init public :: b64_encode , b64_encode_up public :: b64_decode , b64_decode_up public :: pack_data public :: autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_b64_initialized = . false . !< Flag for checking the initialization of the library. character ( 64 ) :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" !< Base64 alphabet. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface b64_encode !< Encode numbers (integer and real) to base64. !< !< This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both !< scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_encode_R16 , b64_encode_R16_a , & #endif b64_encode_R8 , b64_encode_R8_a , & b64_encode_R4 , b64_encode_R4_a , & b64_encode_I8 , b64_encode_I8_a , & b64_encode_I4 , b64_encode_I4_a , & b64_encode_I2 , b64_encode_I2_a , & b64_encode_I1 , b64_encode_I1_a , & b64_encode_string , b64_encode_string_a endinterface interface b64_encode_up !< Encode unlimited polymorphic variable to base64. !< !< This is an interface for encoding both scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_encode_up , b64_encode_up_a endinterface interface b64_decode !< Decode numbers (integer and real) from base64. !< !< This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both !< scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode(code='AAAAAAAA8D8=',n=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_decode_R16 , b64_decode_R16_a , & #endif b64_decode_R8 , b64_decode_R8_a , & b64_decode_R4 , b64_decode_R4_a , & b64_decode_I8 , b64_decode_I8_a , & b64_decode_I4 , b64_decode_I4_a , & b64_decode_I2 , b64_decode_I2_a , & b64_decode_I1 , b64_decode_I1_a , & b64_decode_string , b64_decode_string_a endinterface interface b64_decode_up !< Decode unlimited polymorphic variable from base64. !< !< This is an interface for decoding both scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode_up(code='AAAAAAAA8D8=',up=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',up=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_decode_up , b64_decode_up_a endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16 pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8 pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4 pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8 pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4 pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2 pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1 pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16 elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8 elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4 elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8 elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4 elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2 elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1 elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest endmodule befor64","tags":"","loc":"sourcefile/befor64.f90.html","title":"befor64.F90 â€“ FiNeR"},{"text":"FiNeR, Fortran INI ParseR and generator. Source Code !< FiNeR, Fortran INI ParseR and generator. module finer !----------------------------------------------------------------------------------------------------------------------------------- !< FiNeR, Fortran INI ParseR and generator. !----------------------------------------------------------------------------------------------------------------------------------- use finer_backend use finer_file_ini_t !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: err_option_name public :: err_option_vals public :: err_option public :: err_section_name public :: err_section_options public :: err_section public :: err_source_missing public :: file_ini public :: file_ini_autotest !----------------------------------------------------------------------------------------------------------------------------------- endmodule finer","tags":"","loc":"sourcefile/finer.f90.html","title":"finer.f90 â€“ FiNeR"},{"text":"StringiFor, definition of string type. Source Code !< StringiFor, definition of `string` type. module stringifor_string_t !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, definition of `string` type. !----------------------------------------------------------------------------------------------------------------------------------- use befor64 , only : b64_decode , b64_encode use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P , str !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: CK public :: sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim public :: string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. procedure , pass ( self ) :: verify => sverify !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. #endif ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , pass ( self ) :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. ! auxiliary methods procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string ! internal parameters character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len = 1 ), parameter :: SPACE = ' ' !< Space character. character ( kind = CK , len = 1 ), parameter :: TAB = achar ( 9 ) !< Tab character. character ( kind = CK , len = 1 ), parameter :: UIX_DIR_SEP = char ( 47 ) !< Unix/Linux directories separator (/). character ( kind = CK , len = 1 ), parameter :: BACKSLASH = char ( 92 ) !< Backslash character. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl pure function sadjustl_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustl ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl_character elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr pure function sadjustr_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustr ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr_character elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount elemental function sindex_string_string ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_string elemental function sindex_string_character ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_character elemental function sindex_character_string ( string_ , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: string_ !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( substring % raw )) then i = index ( string = string_ , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_character_string elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_string_string elemental function srepeat_character_string ( self , rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_character_string elemental function sscan_string_string ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_string elemental function sscan_string_character ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_character elemental function sscan_character_string ( sstring , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: sstring !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( set % raw )) then i = scan ( string = sstring , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_character_string elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify ! auxiliary methods elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental function insert_character ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_character elemental function insert_string ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_string pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition subroutine read_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file subroutine read_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_eor !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_line subroutine read_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search pure function slice ( self , istart , iend ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data sliced. !< !<### Example !< !<```fortran !< type(string) :: astring        !< A string. !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) ! print \"Brown fox Jumps\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slice elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase elemental function strip ( self , remove_nulls ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unescape double backslashes (or custom escaped character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unescape elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper subroutine write_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file subroutine write_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_line subroutine write_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines ! inquire elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with ! private methods ! assignments elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P ! contatenation operators pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string ! logical operators elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_string elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_character elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw == lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_eq_string elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_string elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_character elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw /= lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ne_string elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_string elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_character elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_lt_string elemental function string_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_string elemental function string_le_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_character elemental function character_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_le_string elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_string elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_character elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ge_string elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_string elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_character elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_gt_string ! IO subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the end of record condition to the ! caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_delimited subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited_listdirected subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted ! miscellanea elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence ! non type-bound-procedures subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_delimiter_mode subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character in the current record. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_this_record subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character, advancing records if necessary. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_any_record subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_decimal_mode endmodule stringifor_string_t","tags":"","loc":"sourcefile/stringifor_string_t.f90.html","title":"stringifor_string_t.F90 â€“ FiNeR"},{"text":"type, public :: file_ini type~~file_ini~~InheritsGraph type~file_ini file_ini type~section section type~section->type~file_ini sections type~option option type~option->type~section options type~string string type~string->type~option oname, ovals, ocomm Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. INI file class. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: filename File name integer(kind=I4P), private :: Ns = 0 Number of sections. character(len=1), private :: opt_sep = def_opt_sep Separator character of option name/value. type( section ), private, allocatable :: sections (:) Sections. Type-Bound Procedures generic, public :: add => add_section , add_option , add_a_option Add a section.\n Add an option to a section (scalar).\n Add an option to a section (array). private pure subroutine add_section (self, error, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. Description Add a section. private pure subroutine add_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. Description Add an option (with scalar value). private pure subroutine add_a_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. Description Add an option (with array value). procedure, public, pass(self) :: count_values Count option value(s). private elemental function count_values (self, delimiter, section_name, option_name) result(Nv) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option into section data. generic, public :: del => free_option_of_section , free_section Remove (freeing) an option of a section.\n Remove (freeing) a section. private elemental subroutine free_option_of_section (self, section_name, option_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Description Free all options of a section. private elemental subroutine free_section (self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. procedure, public, pass(self) :: free Free dynamic memory destroyng file data. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Description Free dynamic memory. generic, public :: free_options => free_options_all , free_options_of_section , free_option_of_section Free all options.\n Free all options of a section.\n Free an option of a section. private elemental subroutine free_options_all (self) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Description Free all options of all sections. private elemental subroutine free_options_of_section (self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. private elemental subroutine free_option_of_section (self, section_name, option_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Description Free all options of a section. generic, public :: get => get_option , get_a_option Get option value (scalar).\n Get option value (array). private subroutine get_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. Description Get option value (scalar). private subroutine get_a_option (self, delimiter, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. Description Get option value (array) procedure, public, pass(self) :: get_items Get list of couples option name/value. private pure subroutine get_items (self, items) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: items (:,:) Items, list of couples option name/value for all options [1:No,1:2]. Description Get list of couples option name/value. procedure, public, pass(self) :: has_option Inquire the presence of an option. private function has_option (self, option_name, section_name) result(pres) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: option_name Option name. character(len=*), intent(inout), optional :: section_name Section name. Return Value logical Inquiring flag. Description Inquire the presence of (at least one) option with the name passed. procedure, public, pass(self) :: has_section Inquire the presence of a section. private elemental function has_section (self, section_name) result(pres) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: section_name Section name. Return Value logical Inquiring flag. Description Inquire the presence of (at least one) section with the name passed. generic, public :: index => index_section , index_option Return the index of a section.\n Return the index of an option. private elemental function index_section (self, back, section_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the section matching the name passed. private elemental function index_option (self, back, section_name, option_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the option (inside a  section) matching the name(s) passed. procedure, public, pass(self) :: load Load file data. private subroutine load (self, separator, filename, source, error) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=1), intent(in), optional :: separator Separator of options name/value. character(len=*), intent(in), optional :: filename File name. character(len=*), intent(in), optional :: source File source. integer(kind=I4P), intent(out), optional :: error Error code. Description Get file data from a file or a source string. generic, public :: loop => loop_options_section , loop_options Loop over options of a section.\n Loop over all options. private function loop_options_section (self, section_name, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into section. private recursive function loop_options (self, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into all sections. procedure, public, pass(self) :: print => print_file_ini Pretty printing data. private subroutine print_file_ini (self, unit, pref, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. procedure, public, pass(self) :: save => save_file_ini Save data. private subroutine save_file_ini (self, retain_comments, iostat, iomsg, filename) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. character(len=*), intent(in), optional :: filename File name. Description Save data. procedure, public, pass(self) :: section => section_file_ini Get section name once provided an index. private pure function section_file_ini (self, section_index) result(sname) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: section_index Section index. Return Value character(len=:),\n  allocatable Section name. Description Get section name once an index (valid) is provided. generic, public :: assignment(=) => assign_file_ini Procedure for section assignment overloading. private elemental subroutine assign_file_ini (lhs, rhs) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. Description Assignment between two INI files. procedure, private, pass(self) :: add_a_option Add an option to a section (array). private pure subroutine add_a_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. Description Add an option (with array value). procedure, private, pass(self) :: add_option Add an option to a section (scalar). private pure subroutine add_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. Description Add an option (with scalar value). procedure, private, pass(self) :: add_section Add a section. private pure subroutine add_section (self, error, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. Description Add a section. procedure, private, pass(self) :: free_options_all Free all options of all sections. private elemental subroutine free_options_all (self) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Description Free all options of all sections. procedure, private, pass(self) :: free_options_of_section Free all options of a section. private elemental subroutine free_options_of_section (self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. procedure, private, pass(self) :: free_option_of_section Free an option of a section. private elemental subroutine free_option_of_section (self, section_name, option_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Description Free all options of a section. procedure, private, pass(self) :: free_section Free a section. private elemental subroutine free_section (self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. procedure, private, pass(self) :: get_a_option Get option value (array). private subroutine get_a_option (self, delimiter, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. Description Get option value (array) procedure, private, pass(self) :: get_option Get option value (scalar). private subroutine get_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. Description Get option value (scalar). procedure, private, pass(self) :: index_option Return the index of an option. private elemental function index_option (self, back, section_name, option_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the option (inside a  section) matching the name(s) passed. procedure, private, pass(self) :: index_section Return the index of a section. private elemental function index_section (self, back, section_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the section matching the name passed. procedure, private, pass(self) :: loop_options Loop over all options. private recursive function loop_options (self, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into all sections. procedure, private, pass(self) :: loop_options_section Loop over options of a section. private function loop_options_section (self, section_name, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into section. procedure, private, pass(self) :: parse Parse file data. private subroutine parse (self, source, error) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: source String source. integer(kind=I4P), intent(out), optional :: error Error code. Description Parse file either from the self source data or from a source string. procedure, private, pass(lhs) :: assign_file_ini Assignment overloading. private elemental subroutine assign_file_ini (lhs, rhs) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. Description Assignment between two INI files. Source Code type :: file_ini !< INI file class. private character ( len = :), allocatable :: filename !< File name integer ( I4P ) :: Ns = 0 !< Number of sections. character ( 1 ) :: opt_sep = def_opt_sep !< Separator character of option name/value. type ( section ), allocatable :: sections (:) !< Sections. contains ! public methods generic :: add => add_section , & !< Add a section. add_option , & !< Add an option to a section (scalar). add_a_option !< Add an option to a section (array). procedure , pass ( self ) :: count_values !< Count option value(s). generic :: del => free_option_of_section , & !< Remove (freeing) an option of a section. free_section !< Remove (freeing) a section. procedure , pass ( self ) :: free !< Free dynamic memory destroyng file data. generic :: free_options => free_options_all , & !< Free all options. free_options_of_section , & !< Free all options of a section. free_option_of_section !< Free an option of a section. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_items !< Get list of couples option name/value. procedure , pass ( self ) :: has_option !< Inquire the presence of an option. procedure , pass ( self ) :: has_section !< Inquire the presence of a section. generic :: index => index_section , & !< Return the index of a section. index_option !< Return the index of an option. procedure , pass ( self ) :: load !< Load file data. generic :: loop => loop_options_section , & !< Loop over options of a section. loop_options !< Loop over all options. procedure , pass ( self ) :: print => print_file_ini !< Pretty printing data. procedure , pass ( self ) :: save => save_file_ini !< Save data. procedure , pass ( self ) :: section => section_file_ini !< Get section name once provided an index. ! operators overloading generic :: assignment ( = ) => assign_file_ini !< Procedure for section assignment overloading. ! private methods procedure , private , pass ( self ) :: add_a_option !< Add an option to a section (array). procedure , private , pass ( self ) :: add_option !< Add an option to a section (scalar). procedure , private , pass ( self ) :: add_section !< Add a section. procedure , private , pass ( self ) :: free_options_all !< Free all options of all sections. procedure , private , pass ( self ) :: free_options_of_section !< Free all options of a section. procedure , private , pass ( self ) :: free_option_of_section !< Free an option of a section. procedure , private , pass ( self ) :: free_section !< Free a section. procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: index_option !< Return the index of an option. procedure , private , pass ( self ) :: index_section !< Return the index of a section. procedure , private , pass ( self ) :: loop_options !< Loop over all options. procedure , private , pass ( self ) :: loop_options_section !< Loop over options of a section. procedure , private , pass ( self ) :: parse !< Parse file data. ! assignments procedure , private , pass ( lhs ) :: assign_file_ini !< Assignment overloading. endtype file_ini","tags":"","loc":"type/file_ini.html","title":"file_ini â€“ FiNeR "},{"text":"type, public :: option type~~option~~InheritsGraph type~option option type~string string type~string->type~option oname, ovals, ocomm Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Option data of sections. Inherited By type~~option~~InheritedByGraph type~option option type~section section type~option->type~section options type~file_ini file_ini type~section->type~file_ini sections Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type( string ), private :: oname Option name. type( string ), private :: ovals Option values. type( string ), private :: ocomm Eventual option inline comment. Constructor public interface option Overload option name with a function returning a new (itiliazed) option instance. private elemental function new_option (option_name, option_values, option_comment) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: option_name Option name. character(len=*), intent(in), optional :: option_values Option values. character(len=*), intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Description Return a new (initiliazed) option instance. Type-Bound Procedures procedure, public, pass(self) :: count_values Counting option value(s). private elemental function count_values (self, delimiter) result(Nv) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option data. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Description Free dynamic memory. generic, public :: get => get_option , get_a_option Get option value (scalar).\n Get option value (array). private subroutine get_option (self, val, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description for getting option data value (scalar). private subroutine get_a_option (self, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option data values (array). procedure, public, pass(self) :: get_pairs Return option name/values pairs. private pure subroutine get_pairs (self, pairs) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Description Return option name/values pairs. procedure, public, pass(self) :: name_len Return option name length. private elemental function name_len (self) result(length) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option name length. Description Return option name length. procedure, public, pass(self) :: parse Parse option data. private elemental subroutine parse (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option data from a source string. procedure, public, pass(self) :: print => print_option Pretty print data. private subroutine print_option (self, unit, retain_comments, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. procedure, public, pass(self) :: save => save_option Save data. private subroutine save_option (self, unit, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Save data. generic, public :: set => set_option , set_a_option Set option value (scalar).\n Set option value (array). private pure subroutine set_option (self, val) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value. Description Set option data value (scalar). private pure subroutine set_a_option (self, val, delimiter) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Description Set option data value (array). procedure, public, pass(self) :: values_len Return option values length. private elemental function values_len (self) result(length) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option values length. Description Return option values length. generic, public :: assignment(=) => assign_option Assignment overloading. private elemental subroutine assign_option (lhs, rhs) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. Description Assignment between two options. generic, public :: operator(==) => option_eq_string , option_eq_character Equal operator overloading. private elemental function option_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function option_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. procedure, private, pass(self) :: get_option Get option value (scalar). private subroutine get_option (self, val, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description for getting option data value (scalar). procedure, private, pass(self) :: get_a_option Get option value (array). private subroutine get_a_option (self, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option data values (array). procedure, private, pass(self) :: parse_comment Parse option inline comment. private elemental subroutine parse_comment (self) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Description Parse eventaul option inline comment trimming it out from pure value string. procedure, private, pass(self) :: parse_name Parse option name. private elemental subroutine parse_name (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option name from a source string. procedure, private, pass(self) :: parse_value Parse option values. private elemental subroutine parse_value (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option value from a source string. procedure, private, pass(self) :: set_option Set option value (scalar). private pure subroutine set_option (self, val) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value. Description Set option data value (scalar). procedure, private, pass(self) :: set_a_option Set option value (array). private pure subroutine set_a_option (self, val, delimiter) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Description Set option data value (array). procedure, private, pass(lhs) :: assign_option Assignment overloading. private elemental subroutine assign_option (lhs, rhs) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. Description Assignment between two options. procedure, private, pass(lhs) :: option_eq_string Equal to string logical operator. private elemental function option_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. procedure, private, pass(lhs) :: option_eq_character Equal to character logical operator. private elemental function option_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. Source Code type :: option !< Option data of sections. private type ( string ) :: oname !< Option name. type ( string ) :: ovals !< Option values. type ( string ) :: ocomm !< Eventual option inline comment. contains ! public methods procedure , pass ( self ) :: count_values !< Counting option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_pairs !< Return option name/values pairs. procedure , pass ( self ) :: name_len !< Return option name length. procedure , pass ( self ) :: parse !< Parse option data. procedure , pass ( self ) :: print => print_option !< Pretty print data. procedure , pass ( self ) :: save => save_option !< Save data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: values_len !< Return option values length. ! operators overloading generic :: assignment ( = ) => assign_option !< Assignment overloading. generic :: operator ( == ) => option_eq_string , & option_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_comment !< Parse option inline comment. procedure , private , pass ( self ) :: parse_name !< Parse option name. procedure , private , pass ( self ) :: parse_value !< Parse option values. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_option !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: option_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: option_eq_character !< Equal to character logical operator. endtype option","tags":"","loc":"type/option.html","title":"option â€“ FiNeR "},{"text":"type, public :: section type~~section~~InheritsGraph type~section section type~option option type~option->type~section options type~string string type~string->type~option oname, ovals, ocomm Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Section data of file INI. Inherited By type~~section~~InheritedByGraph type~section section type~file_ini file_ini type~section->type~file_ini sections Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: sname Section name. type( option ), private, allocatable :: options (:) Section options. Constructor public interface section Overload section name with a function returning a new (itiliazed) section instance. private elemental function new_section (section_name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Description Return a new (initiliazed) section instance. Type-Bound Procedures generic, public :: add => add_option , add_a_option Add an option (scalar).\n Add an option (array). private pure subroutine add_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with scalar value). private pure subroutine add_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with array value). procedure, public, pass(self) :: count_values Count option value(s). private elemental function count_values (self, option_name, delimiter) result(Nv) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option into section data. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Description Free dynamic memory. procedure, public, pass(self) :: free_options Free all options. private elemental subroutine free_options (self) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Description Free all options. procedure, public, pass(self) :: free_option Free a option. private elemental subroutine free_option (self, option_name) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. Description Free an option. generic, public :: get => get_option , get_a_option Get option value (scalar).\n Get option value (array). private subroutine get_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option value (scalar). private subroutine get_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Procedure for getting option value (array). procedure, public, pass(self) :: has_options Inquire if section has options. private elemental function has_options (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value logical Inquire result. Description Inquire is section has options (at least one). procedure, public, pass(self) :: index => index_option Return the index of an option. private elemental function index_option (self, option_name, back) result(ind) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the option matching the name passed. procedure, public, pass(self) :: loop Loop over options. private function loop (self, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into section. procedure, public, pass(self) :: max_chars_len Return max len of option-name/values on all options. private elemental function max_chars_len (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer Inquire result. Description Return the maximum number of characters between option-name/option-values on all options. procedure, public, pass(self) :: name Return section name. private pure function name (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value character(len=len(self%sname)) Section data. Description Return section name. procedure, public, pass(self) :: options_number Return the options number. private elemental function options_number (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer Options number. Description Return the options number. procedure, public, pass(self) :: option_pairs Return an option pairs. private pure subroutine option_pairs (self, option_index, pairs) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Option data. integer, intent(in) :: option_index Option index. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Description Return an option pairs. procedure, public, pass(self) :: parse Parse section data. private elemental subroutine parse (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Gett section data from a source string. procedure, public, pass(self) :: print => print_section Pretty print data. private subroutine print_section (self, unit, retain_comments, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. generic, public :: set => set_option , set_a_option Set option value (scalar).\n Set option value (array). private pure subroutine set_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (scalar). private pure subroutine set_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (array). procedure, public, pass(self) :: save => save_section Save data. private subroutine save_section (self, unit, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Save data. generic, public :: assignment(=) => assign_section Assignment overloading. private elemental subroutine assign_section (lhs, rhs) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. Description Assignment between two sections. generic, public :: operator(==) => section_eq_string , section_eq_character Equal operator overloading. private elemental function section_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function section_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. procedure, private, pass(self) :: add_option Add an option (scalar). private pure subroutine add_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with scalar value). procedure, private, pass(self) :: add_a_option Add an option (array). private pure subroutine add_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with array value). procedure, private, pass(self) :: get_option Get option value (scalar). private subroutine get_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option value (scalar). procedure, private, pass(self) :: get_a_option Get option value (array). private subroutine get_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Procedure for getting option value (array). procedure, private, pass(self) :: parse_name Get section name. private elemental subroutine parse_name (self, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Get section name from a source string. procedure, private, pass(self) :: parse_options Get section options. private elemental subroutine parse_options (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Get section options from a source string. procedure, private, pass(self) :: set_option Set option value (scalar). private pure subroutine set_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (scalar). procedure, private, pass(self) :: set_a_option Set option value (array). private pure subroutine set_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (array). procedure, private, pass(lhs) :: assign_section Assignment overloading. private elemental subroutine assign_section (lhs, rhs) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. Description Assignment between two sections. procedure, private, pass(lhs) :: section_eq_string Equal to string logical operator. private elemental function section_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. procedure, private, pass(lhs) :: section_eq_character Equal to character logical operator. private elemental function section_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. Source Code type :: section !< Section data of file INI. private character ( len = :), allocatable :: sname !< Section name. type ( option ), allocatable :: options (:) !< Section options. contains ! public methods generic :: add => add_option , & !< Add an option (scalar). add_a_option !< Add an option (array). procedure , pass ( self ) :: count_values !< Count option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: free_options !< Free all options. procedure , pass ( self ) :: free_option !< Free a option. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: has_options !< Inquire if section has options. procedure , pass ( self ) :: index => index_option !< Return the index of an option. procedure , pass ( self ) :: loop !< Loop over options. procedure , pass ( self ) :: max_chars_len !< Return max len of option-name/values on all options. procedure , pass ( self ) :: name !< Return section name. procedure , pass ( self ) :: options_number !< Return the options number. procedure , pass ( self ) :: option_pairs !< Return an option pairs. procedure , pass ( self ) :: parse !< Parse section data. procedure , pass ( self ) :: print => print_section !< Pretty print data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: save => save_section !< Save data. ! operators overloading generic :: assignment ( = ) => assign_section !< Assignment overloading. generic :: operator ( == ) => section_eq_string , & section_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: add_option !< Add an option (scalar). procedure , private , pass ( self ) :: add_a_option !< Add an option (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_name !< Get section name. procedure , private , pass ( self ) :: parse_options !< Get section options. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_section !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: section_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: section_eq_character !< Equal to character logical operator. endtype section","tags":"","loc":"type/section.html","title":"section â€“ FiNeR "},{"text":"type, public :: string OOP designed string class. Inherited By type~~string~~InheritedByGraph type~string string type~option option type~string->type~option oname, ovals, ocomm type~section section type~option->type~section options type~file_ini file_ini type~section->type~file_ini sections Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. procedure, public, pass(self) :: count => scount Count replacement. private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. generic, public :: index => sindex_string_string , sindex_string_character Index replacement. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, public, pass(self) :: len => slen Len replacement. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. generic, public :: repeat => srepeat_string_string , srepeat_character_string Repeat replacement. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. generic, public :: scan => sscan_string_string , sscan_string_character Scan replacement. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, public, pass(self) :: trim => strim Trim replacement. public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. procedure, public, pass(self) :: verify => sverify Verify replacement. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. procedure, public, pass(self) :: decode Decode string. private elemental function decode (self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. procedure, public, pass(self) :: encode Encode string. private elemental function encode (self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. generic, public :: insert => insert_string , insert_character Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. generic, public :: join => join_strings , join_characters Return a string that is a join of an array of strings or characters. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file Read a file a single string stream. private subroutine read_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. private subroutine read_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. private subroutine read_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. procedure, public, pass(self) :: slice Return the raw characters data sliced. private pure function slice (self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. private elemental function strip (self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P , to_integer_I2P , to_integer_I4P , to_integer_I8P , to_real_R4P , to_real_R8P Cast string to number. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. procedure, public, pass(self) :: write_file Write a single string stream into file. private subroutine write_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. private subroutine write_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. private subroutine write_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string , string_assign_character , string_assign_integer_I1P , string_assign_integer_I2P , string_assign_integer_I4P , string_assign_integer_I8P , string_assign_real_R4P , string_assign_real_R8P Assignment operator overloading. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(==) => string_eq_string , string_eq_character , character_eq_string Equal operator overloading. private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. generic, public :: operator(/=) => string_ne_string , string_ne_character , character_ne_string Not equal operator overloading. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. generic, public :: operator(<) => string_lt_string , string_lt_character , character_lt_string Lower than operator overloading. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. generic, public :: operator(<=) => string_le_string , string_le_character , character_le_string Lower equal than operator overloading. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. generic, public :: operator(>=) => string_ge_string , string_ge_character , character_ge_string Greater equal than operator overloading. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. generic, public :: operator(>) => string_gt_string , string_gt_character , character_gt_string Greater than operator overloading. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. generic, public :: read(formatted) => read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. generic, public :: write(formatted) => write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. generic, public :: read(unformatted) => read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. generic, public :: write(unformatted) => write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: sindex_string_string Index replacement. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, private, pass(self) :: sindex_string_character Index replacement. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. procedure, private, pass(self) :: srepeat_character_string Repeat replacement. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. procedure, private, pass(self) :: sscan_string_string Scan replacement. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, private, pass(self) :: sscan_string_character Scan replacement. public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings Return join string of an array of strings. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). procedure, private, pass(self) :: to_integer_I2P Cast string to integer. private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). procedure, private, pass(self) :: to_integer_I4P Cast string to integer. private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). procedure, private, pass(self) :: to_integer_I8P Cast string to integer. private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). procedure, private, pass(self) :: to_real_R4P Cast string to real. private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). procedure, private, pass(self) :: to_real_R8P Cast string to real. private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, private, pass(self) :: to_real_R16P Cast string to real. private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, private, pass(dtv) :: read_delimited Read a delimited input. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. procedure, private, pass(dtv) :: write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, private, pass(dtv) :: read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. procedure, private, pass(dtv) :: write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Source Code type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. procedure , pass ( self ) :: verify => sverify !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. #endif ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , pass ( self ) :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. ! auxiliary methods procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string","tags":"","loc":"type/string.html","title":"string â€“ FiNeR "},{"text":"private elemental function count_values(self, delimiter, section_name, option_name) result(Nv) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option into section data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. integer(kind=I4P), public :: s Counter. Source Code elemental function count_values ( self , delimiter , section_name , option_name ) result ( Nv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the number of values of option into section data. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then Nv = self % sections ( s )% count_values ( delimiter = dlm , option_name = option_name ) exit endif enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_values","tags":"","loc":"proc/count_values.html","title":"count_values â€“ FiNeR"},{"text":"private function has_option(self, option_name, section_name) result(pres) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: option_name Option name. character(len=*), intent(inout), optional :: section_name Section name. Return Value logical Inquiring flag. Description Inquire the presence of (at least one) option with the name passed. Optionall, the first matching section name is returned. Note All sections are searched and the first occurence is returned. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: s Counter. Source Code function has_option ( self , option_name , section_name ) result ( pres ) !--------------------------------------------------------------------------------------------------------------------------------- !< Inquire the presence of (at least one) option with the name passed. !< !< Optionall, the first matching section name is returned. !< !< @note All sections are searched and the first occurence is returned. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), optional , intent ( inout ) :: section_name !< Section name. logical :: pres !< Inquiring flag. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pres = . false . if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) pres = ( self % sections ( s )% index ( option_name = option_name ) > 0 ) if ( pres ) then if ( present ( section_name )) section_name = self % sections ( s )% name () exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction has_option","tags":"","loc":"proc/has_option.html","title":"has_option â€“ FiNeR"},{"text":"private elemental function has_section(self, section_name) result(pres) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: section_name Section name. Return Value logical Inquiring flag. Description Inquire the presence of (at least one) section with the name passed. Source Code elemental function has_section ( self , section_name ) result ( pres ) !--------------------------------------------------------------------------------------------------------------------------------- !< Inquire the presence of (at least one) section with the name passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. logical :: pres !< Inquiring flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pres = ( self % index ( section_name = section_name ) > 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction has_section","tags":"","loc":"proc/has_section.html","title":"has_section â€“ FiNeR"},{"text":"private pure function section_file_ini(self, section_index) result(sname) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: section_index Section index. Return Value character(len=:),\n  allocatable Section name. Description Get section name once an index (valid) is provided. Source Code pure function section_file_ini ( self , section_index ) result ( sname ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get section name once an index (valid) is provided. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: section_index !< Section index. character ( len = :), allocatable :: sname !< Section name. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then if (( section_index >= lbound ( self % sections , dim = 1 )). and .( section_index <= ubound ( self % sections , dim = 1 ))) then sname = self % sections ( section_index )% name () endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction section_file_ini","tags":"","loc":"proc/section_file_ini.html","title":"section_file_ini â€“ FiNeR"},{"text":"private elemental function index_option(self, back, section_name, option_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the option (inside a  section) matching the name(s) passed. Note The matching index returned is the first found if back is not passed or if back=.false. . On the contrary the last\n found is returned if back=.true. . Variables Type Visibility Attributes Name Initial logical, public :: backd Dummy back flag. integer(kind=I4P), public :: s Counter. Source Code elemental function index_option ( self , back , section_name , option_name ) result ( ind ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the index of the option (inside a  section) matching the name(s) passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. logical , optional , intent ( in ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( in ) :: option_name !< Option  name. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back s = self % index ( section_name = section_name , back = backd ) if ( s > 0 ) then ind = self % sections ( s )% index ( option_name = option_name , back = backd ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction index_option","tags":"","loc":"proc/index_option.html","title":"index_option â€“ FiNeR"},{"text":"private elemental function index_section(self, back, section_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the section matching the name passed. Note The matching index returned is the first found if back is not passed or if back=.false. . On the contrary the last\n found is returned if back=.true. . Variables Type Visibility Attributes Name Initial logical, public :: backd Dummy back flag. integer(kind=I4P), public :: s Counter. Source Code elemental function index_section ( self , back , section_name ) result ( ind ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the index of the section matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( IN ) :: self !< File data. logical , optional , intent ( IN ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( IN ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do s = size ( self % sections , dim = 1 ), 1 , - 1 if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo else do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction index_section","tags":"","loc":"proc/index_section.html","title":"index_section â€“ FiNeR"},{"text":"private function loop_options_section(self, section_name, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into section. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: s Counter. Source Code function loop_options_section ( self , section_name , option_pairs ) result ( again ) !--------------------------------------------------------------------------------------------------------------------------------- !< Loop returning option name/value defined into section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- again = . false . s = self % index ( section_name = section_name ) if ( s > 0 ) then again = self % sections ( s )% loop ( option_pairs = option_pairs ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction loop_options_section","tags":"","loc":"proc/loop_options_section.html","title":"loop_options_section â€“ FiNeR"},{"text":"private recursive function loop_options(self, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into all sections. Variables Type Visibility Attributes Name Initial logical, public, save :: againO = .false. Flag continuing the loop. integer(kind=I4P), public, save :: s = 0 Counter. Source Code recursive function loop_options ( self , option_pairs ) result ( again ) !--------------------------------------------------------------------------------------------------------------------------------- !< Loop returning option name/value defined into all sections. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( IN ) :: self !< File data. character ( len = :), allocatable , intent ( OUT ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. logical , save :: againO = . false . !< Flag continuing the loop. integer ( I4P ), save :: s = 0 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- again = . false . if ( allocated ( self % sections )) then if ( s == 0 ) then s = lbound ( self % sections , dim = 1 ) againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) again = . true . elseif ( s < ubound ( self % sections , dim = 1 )) then if (. not . againO ) s = s + 1 againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) if (. not . againO ) then again = self % loop ( option_pairs = option_pairs ) else again = . true . endif else s = 0 againO = . false . again = . false . endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction loop_options","tags":"","loc":"proc/loop_options.html","title":"loop_options â€“ FiNeR"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % filename )) deallocate ( self % filename ) if ( allocated ( self % sections )) then call self % sections % free deallocate ( self % sections ) endif self % Ns = 0 self % opt_sep = def_opt_sep return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free â€“ FiNeR"},{"text":"private pure subroutine get_items(self, items) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: items (:,:) Items, list of couples option name/value for all options [1:No,1:2]. Description Get list of couples option name/value. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: pairs (:) Option name/values pairs. integer(kind=I4P), public :: mx_chars Maximum number of chars into name/value within all options. integer(kind=I4P), public :: o Counter. integer(kind=I4P), public :: s Counter. integer(kind=I4P), public :: No Counter. Source Code pure subroutine get_items ( self , items ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get list of couples option name/value. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( len = :), allocatable , intent ( out ) :: items (:,:) !< Items, list of couples option name/value for all options [1:No,1:2]. character ( len = :), allocatable :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: mx_chars !< Maximum number of chars into name/value within all options. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: No !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mx_chars = MinI4P if ( allocated ( self % sections )) then No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then mx_chars = max ( mx_chars , self % sections ( s )% max_chars_len ()) No = No + self % sections ( s )% options_number () endif enddo if (( mx_chars > 0 ). and .( No > 0 )) then allocate ( character ( mx_chars ) :: items ( 1 : No , 1 : 2 )) No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then do o = 1 , self % sections ( s )% options_number () No = No + 1 call self % sections ( s )% option_pairs ( option_index = o , pairs = pairs ) items ( No , 1 ) = pairs ( 1 ) items ( No , 2 ) = pairs ( 2 ) enddo endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_items","tags":"","loc":"proc/get_items.html","title":"get_items â€“ FiNeR"},{"text":"private subroutine load(self, separator, filename, source, error) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=1), intent(in), optional :: separator Separator of options name/value. character(len=*), intent(in), optional :: filename File name. character(len=*), intent(in), optional :: source File source. integer(kind=I4P), intent(out), optional :: error Error code. Description Get file data from a file or a source string. Usage Loading from a file type ( file_ini ) :: fini\ncall fini%load ( filename = 'path_to_my_file.ini' ) Loading from a source string type ( file_ini ) :: fini\ncall fini%load ( source = '[section-1] option-1=one [section-2] option-2=due' ) Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. character(len=:), public, allocatable :: sourced Dummy source string. type( string ), public :: source_ Dummy source string. Source Code subroutine load ( self , separator , filename , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get file data from a file or a source string. !< !<### Usage !< !<##### Loading from a file !<```bash !<type(file_ini):: fini !<call fini%load(filename='path_to_my_file.ini') !<``` !< !<##### Loading from a source string !<```bash !<type(file_ini):: fini !<call fini%load(source='[section-1] option-1=one [section-2] option-2=due') !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( 1 ), optional , intent ( in ) :: separator !< Separator of options name/value. character ( * ), optional , intent ( in ) :: filename !< File name. character ( * ), optional , intent ( in ) :: source !< File source. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: sourced !< Dummy source string. type ( string ) :: source_ !< Dummy source string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_source_missing if ( present ( separator )) self % opt_sep = separator if ( present ( filename )) then self % filename = trim ( adjustl ( filename )) ! to remove after StringiFor adoption call source_ % read_file ( file = self % filename ) sourced = source_ % chars () ! call read_file_as_stream(filename=self%filename, fast_read=.true., stream=sourced) ! to remove after StringiFor adoption call self % parse ( source = sourced , error = errd ) elseif ( present ( source )) then call self % parse ( source = source , error = errd ) elseif ( allocated ( self % filename )) then ! to remove after StringiFor adoption call source_ % read_file ( file = self % filename ) sourced = source_ % chars () ! call read_file_as_stream(filename=self%filename, fast_read=.true., stream=sourced) call self % parse ( source = sourced , error = errd ) endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine load","tags":"","loc":"proc/load.html","title":"load â€“ FiNeR"},{"text":"private subroutine print_file_ini(self, unit, pref, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: rt_comm Flag for retaining eventual comments. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. integer(kind=I4P), public :: s Counter. Source Code subroutine print_file_ini ( self , unit , pref , retain_comments , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print data with a pretty format. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% print ( pref = prefd , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_file_ini","tags":"","loc":"proc/print_file_ini.html","title":"print_file_ini â€“ FiNeR"},{"text":"private subroutine save_file_ini(self, retain_comments, iostat, iomsg, filename) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. character(len=*), intent(in), optional :: filename File name. Description Save data. Variables Type Visibility Attributes Name Initial logical, public :: rt_comm Flag for retaining eventual comments. integer(kind=I4P), public :: unit Logic unit. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. integer(kind=I4P), public :: s Counter. Source Code subroutine save_file_ini ( self , retain_comments , iostat , iomsg , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save data. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( * ), optional , intent ( in ) :: filename !< File name. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: unit !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( present ( filename )) self % filename = filename if ( allocated ( self % filename ). and . allocated ( self % sections )) then open ( newunit = unit , file = self % filename , action = 'WRITE' , iostat = iostatd , iomsg = iomsgd ) do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo close ( unit = unit , iostat = iostatd , iomsg = iomsgd ) endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_file_ini","tags":"","loc":"proc/save_file_ini.html","title":"save_file_ini â€“ FiNeR"},{"text":"private pure subroutine add_a_option(self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. Description Add an option (with array value). If the option already exists, its value is updated. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. integer(kind=I4P), public :: s Counter. Source Code pure subroutine add_a_option ( self , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with array value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val ( 1 :) !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_a_option","tags":"","loc":"proc/add_a_option.html","title":"add_a_option â€“ FiNeR"},{"text":"private pure subroutine add_option(self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. Description Add an option (with scalar value). If the option already exists, its value is updated. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. integer(kind=I4P), public :: s Counter. Source Code pure subroutine add_option ( self , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_option","tags":"","loc":"proc/add_option.html","title":"add_option â€“ FiNeR"},{"text":"private pure subroutine add_section(self, error, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. Description Add a section. If the section already exists, it is left unchanged. Calls proc~~add_section~~CallsGraph proc~add_section add_section interface~section section proc~add_section->interface~section proc~new_section new_section interface~section->proc~new_section Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( section ), public, allocatable :: sections (:) Temporary sections array. integer(kind=I4P), public :: errd Error code. Source Code pure subroutine add_section ( self , error , section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add a section. !< !< If the section already exists, it is left unchanged. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: errd !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section if ( allocated ( self % sections )) then if ( self % index ( section_name = section_name ) == 0 ) then ! section not present allocate ( sections ( 1 : size ( self % sections , dim = 1 ) + 1 )) sections ( 1 : size ( self % sections , dim = 1 )) = self % sections sections ( size ( self % sections , dim = 1 ) + 1 ) = section ( section_name = trim ( adjustl ( section_name ))) call move_alloc ( sections , self % sections ) self % Ns = self % Ns + 1 endif else allocate ( self % sections ( 1 : 1 )) self % sections ( 1 ) = section ( section_name = section_name ) self % Ns = self % Ns + 1 endif if ( self % index ( section_name = section_name ) > 0 ) errd = 0 if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_section","tags":"","loc":"proc/add_section.html","title":"add_section â€“ FiNeR"},{"text":"private elemental subroutine free_options_all(self) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Description Free all options of all sections. Source Code elemental subroutine free_options_all ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of all sections. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) call self % sections % free_options return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_options_all","tags":"","loc":"proc/free_options_all.html","title":"free_options_all â€“ FiNeR"},{"text":"private elemental subroutine free_option_of_section(self, section_name, option_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Description Free all options of a section. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: s Counter. Source Code elemental subroutine free_option_of_section ( self , section_name , option_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of a section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option  name. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s = self % index ( section_name = section_name ) if ( s > 0 ) call self % sections ( s )% free_option ( option_name = option_name ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_option_of_section","tags":"","loc":"proc/free_option_of_section.html","title":"free_option_of_section â€“ FiNeR"},{"text":"private elemental subroutine free_options_of_section(self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: s Counter. Source Code elemental subroutine free_options_of_section ( self , section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of a section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% free_options exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_options_of_section","tags":"","loc":"proc/free_options_of_section.html","title":"free_options_of_section â€“ FiNeR"},{"text":"private elemental subroutine free_section(self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. Variables Type Visibility Attributes Name Initial type( section ), public, allocatable :: sections (:) Temporary sections array. integer(kind=I4P), public :: s Counter. Source Code elemental subroutine free_section ( self , section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options of a section. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s = self % index ( section_name = section_name ) if ( s > 0 ) then allocate ( sections ( 1 : size ( self % sections , dim = 1 ) - 1 )) if ( s == 1 ) then sections = self % sections ( 2 :) elseif ( s == size ( self % sections , dim = 1 )) then sections = self % sections (: s - 1 ) else sections (: s - 1 ) = self % sections (: s - 1 ) sections ( s : ) = self % sections ( s + 1 :) endif call move_alloc ( sections , self % sections ) self % Ns = self % Ns - 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_section","tags":"","loc":"proc/free_section.html","title":"free_section â€“ FiNeR"},{"text":"private subroutine get_a_option(self, delimiter, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. Description Get option value (array) Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. integer(kind=I4P), public :: errd Error code. integer(kind=I4P), public :: s Counter. Source Code subroutine get_a_option ( self , delimiter , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option value (array) !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( delimiter = dlm , error = errd , option_name = option_name , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_a_option","tags":"","loc":"proc/get_a_option.html","title":"get_a_option â€“ FiNeR"},{"text":"private subroutine get_option(self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. Description Get option value (scalar). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. integer(kind=I4P), public :: s Counter. Source Code subroutine get_option ( self , error , section_name , option_name , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( error = errd , option_name = option_name , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_option","tags":"","loc":"proc/get_option.html","title":"get_option â€“ FiNeR"},{"text":"private subroutine parse(self, source, error) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: source String source. integer(kind=I4P), intent(out), optional :: error Error code. Description Parse file either from the self source data or from a source string. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. type( string ), public, allocatable :: tokens (:) Options strings tokenized. type( string ), public :: dummy_str Dummy string. character(len=len(source)), public, allocatable :: toks (:) Dummies tokens. character(len=len(source)), public :: dummy Dummy string for parsing sections. integer(kind=I4P), public :: Ns Counter. integer(kind=I4P), public :: s Counter. integer(kind=I4P), public :: ss Counter. Source Code subroutine parse ( self , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse file either from the self source data or from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: source !< String source. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. type ( string ) :: dummy_str !< Dummy string. character ( len = len ( source )), allocatable :: toks (:) !< Dummies tokens. character ( len ( source )) :: dummy !< Dummy string for parsing sections. integer ( I4P ) :: Ns !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: ss !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_source_missing ! to remove after StringiFor adoption dummy_str = source call dummy_str % split ( tokens = tokens , sep = new_line ( 'a' )) allocate ( toks ( 1 : size ( tokens , dim = 1 ))) do s = 1 , size ( tokens , dim = 1 ) toks ( s ) = tokens ( s )% chars () enddo ! call tokenize(strin=source, delimiter=new_line('A'), toks=toks) ! to remove after StringiFor adoption Ns = 0 s = 0 do while ( s + 1 <= size ( toks , dim = 1 )) s = s + 1 if ( scan ( adjustl ( toks ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( toks ( s ))), \"[\" ) == 1 ) then Ns = Ns + 1 dummy = trim ( adjustl ( toks ( s ))) // new_line ( 'A' ) ss = s do while ( ss + 1 <= size ( toks , dim = 1 )) ss = ss + 1 if ( index ( trim ( adjustl ( toks ( ss ))), \"[\" ) == 1 ) then ! new section... go back exit else ! continuation of current section dummy = trim ( adjustl ( dummy )) // new_line ( 'A' ) // trim ( adjustl ( toks ( ss ))) toks ( ss ) = comments ! forcing skip this in the following scan endif enddo toks ( s ) = trim ( adjustl ( dummy )) endif enddo if ( Ns > 0 ) then if ( allocated ( self % sections )) deallocate ( self % sections ) ; allocate ( self % sections ( 1 : Ns )) s = 0 ss = 0 do while ( s + 1 <= size ( toks , dim = 1 )) s = s + 1 if ( scan ( adjustl ( toks ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( toks ( s ))), \"[\" ) == 1 ) then ss = ss + 1 call self % sections ( ss )% parse ( sep = self % opt_sep , source = toks ( s ), error = errd ) endif enddo endif self % Ns = size ( self % sections , dim = 1 ) if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse.html","title":"parse â€“ FiNeR"},{"text":"private elemental subroutine assign_file_ini(lhs, rhs) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. Description Assignment between two INI files. Source Code elemental subroutine assign_file_ini ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two INI files. !--------------------------------------------------------------------------------------------------------------------------------- class ( file_ini ), intent ( inout ) :: lhs !< Left hand side. type ( file_ini ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % filename )) lhs % filename = rhs % filename if ( allocated ( rhs % sections )) then if ( allocated ( lhs % sections )) deallocate ( lhs % sections ) ; allocate ( lhs % sections ( 1 : size ( rhs % sections , dim = 1 ))) lhs % sections = rhs % sections endif lhs % Ns = rhs % Ns return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_file_ini","tags":"","loc":"proc/assign_file_ini.html","title":"assign_file_ini â€“ FiNeR"},{"text":"public subroutine file_ini_autotest() Arguments None Description Autotest the library functionalities. Called By proc~~file_ini_autotest~~CalledByGraph proc~file_ini_autotest file_ini_autotest program~test_driver Test_Driver program~test_driver->proc~file_ini_autotest Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( file_ini ), public :: fini INI File. character(len=:), public, allocatable :: source Testing string. character(len=:), public, allocatable :: string String option. real(kind=R4P), public, allocatable :: array (:) Array option. integer(kind=I4P), public :: error Error code. character(len=:), public, allocatable :: items (:,:) List of all options name/value couples. character(len=:), public, allocatable :: item (:) Option name/value couple. integer(kind=I4P), public :: i Counter. integer(kind=I4P), public :: s Counter. Source Code subroutine file_ini_autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Autotest the library functionalities. !--------------------------------------------------------------------------------------------------------------------------------- type ( file_ini ) :: fini !< INI File. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. real ( R4P ), allocatable :: array (:) !< Array option. integer ( I4P ) :: error !< Error code. character ( len = :), allocatable :: items (:,:) !< List of all options name/value couples. character ( len = :), allocatable :: item (:) !< Option name/value couple. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- source = '[section-1]' // new_line ( 'A' ) // & 'option-1 = one' // new_line ( 'A' ) // & 'option-2 = 2.' // new_line ( 'A' ) // & '           3. ; this is an inline comment' // new_line ( 'A' ) // & 'option-3 = bar ; this is an inline comment' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 = foo' print \"(A)\" , '' print \"(A)\" , \"Testing parsing procedures\" print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % load ( source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" string = '   ' call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-1 has values: ' , string allocate ( array ( 1 : fini % count_values ( section_name = 'section-1' , option_name = 'option-2' ))) call fini % get ( section_name = 'section-1' , option_name = 'option-2' , val = array , error = error ) if ( error == 0 ) print \"(A,3(F4.1,1X))\" , '  option-2 of section-1 has values: ' , array call fini % get ( section_name = 'section-1' , option_name = 'option-3' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-3 of section-1 has values: ' , string call fini % get ( section_name = 'section-2' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-2 has values: ' , string print \"(A)\" , '' print \"(A)\" , \"Parsed data will be saved as (having retained inline comments that are trimmed out by default):\" call fini % print ( pref = '  ' , unit = stdout , retain_comments = . true .) call fini % save ( filename = 'foo.ini' , retain_comments = . true .) call fini % free print \"(A)\" , '' print \"(A)\" , \"Testing generating procedures\" call fini % add ( section_name = 'sec-foo' ) call fini % add ( section_name = 'sec-foo' , option_name = 'bar' , val =- 3 2.1_R8P ) call fini % add ( section_name = 'sec-foo' , option_name = 'baz' , val = ' hello FiNeR! ' ) call fini % add ( section_name = 'sec-foo' , option_name = 'array' , val = [ 1 , 2 , 3 , 4 ]) call fini % add ( section_name = 'sec-bar' ) call fini % add ( section_name = 'sec-bar' , option_name = 'bools' , val = [. true .,. false .,. false .]) call fini % add ( section_name = 'sec-bartolomeo' ) call fini % add ( section_name = 'sec-bartolomeo' , option_name = 'help' , val = 'I am Bartolomeo' ) print \"(A)\" , \"The autogenerated INI file will be saved as:\" call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing option baz\" call fini % del ( section_name = 'sec-foo' , option_name = 'baz' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing section sec-bar\" call fini % del ( section_name = 'sec-bar' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing introspective methods\" print \"(A,L1)\" , \"Is there option bar? \" , fini % has_option ( option_name = 'bar' ) print \"(A,L1)\" , \"Is there option baz? \" , fini % has_option ( option_name = 'baz' ) print \"(A,L1)\" , \"Is there section sec-bar? \" , fini % has_section ( section_name = 'sec-bar' ) print \"(A,L1)\" , \"Is there section sec-foo? \" , fini % has_section ( section_name = 'sec-foo' ) print \"(A)\" , '' print \"(A)\" , \"What are all options name/values couples? Can I have a list? Yes, you can:\" call fini % get_items ( items = items ) do i = 1 , size ( items , dim = 1 ) print \"(A)\" , trim ( items ( i , 1 )) // ' = ' // trim ( items ( i , 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over options of a section:\" do s = 1 , fini % Ns print \"(A)\" , fini % section ( s ) do while ( fini % loop ( section_name = fini % section ( s ), option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over all options:\" do while ( fini % loop ( option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing custom separator of option name/value:, use ':' instead of '='\" source = '[section-1]' // new_line ( 'A' ) // & 'option-1 : one' // new_line ( 'A' ) // & 'option-2 : 2.' // new_line ( 'A' ) // & '           3.' // new_line ( 'A' ) // & 'option-3 : bar' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 : foo' print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % free call fini % load ( separator = ':' , source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" call fini % print ( pref = '  ' , unit = stdout ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine file_ini_autotest","tags":"","loc":"proc/file_ini_autotest.html","title":"file_ini_autotest â€“ FiNeR"},{"text":"private elemental function count_values(self, delimiter) result(Nv) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. Source Code elemental function count_values ( self , delimiter ) result ( Nv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the number of values of option data. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % ovals % is_allocated ()) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter Nv = self % ovals % count ( dlm ) + 1 else Nv = 0 endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_values","tags":"","loc":"proc/count_values~2.html","title":"count_values â€“ FiNeR"},{"text":"private elemental function name_len(self) result(length) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option name length. Description Return option name length. Source Code elemental function name_len ( self ) result ( length ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return option name length. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option name length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % oname % is_allocated ()) length = self % oname % len () return !--------------------------------------------------------------------------------------------------------------------------------- endfunction name_len","tags":"","loc":"proc/name_len.html","title":"name_len â€“ FiNeR"},{"text":"private elemental function values_len(self) result(length) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option values length. Description Return option values length. Source Code elemental function values_len ( self ) result ( length ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return option values length. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option values length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % ovals % is_allocated ()) length = self % ovals % len () return !--------------------------------------------------------------------------------------------------------------------------------- endfunction values_len","tags":"","loc":"proc/values_len.html","title":"values_len â€“ FiNeR"},{"text":"private elemental function option_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. Source Code elemental function option_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % oname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction option_eq_string","tags":"","loc":"proc/option_eq_string.html","title":"option_eq_string â€“ FiNeR"},{"text":"private elemental function option_eq_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. Source Code elemental function option_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % oname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction option_eq_character","tags":"","loc":"proc/option_eq_character.html","title":"option_eq_character â€“ FiNeR"},{"text":"private elemental function new_option(option_name, option_values, option_comment) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: option_name Option name. character(len=*), intent(in), optional :: option_values Option values. character(len=*), intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Description Return a new (initiliazed) option instance. Called By proc~~new_option~~CalledByGraph proc~new_option new_option interface~option option interface~option->proc~new_option proc~add_option~2 add_option proc~add_option~2->interface~option proc~add_a_option~2 add_a_option proc~add_a_option~2->interface~option Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function new_option ( option_name , option_values , option_comment ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a new (initiliazed) option instance. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ), optional :: option_name !< Option name. character ( * ), intent ( in ), optional :: option_values !< Option values. character ( * ), intent ( in ), optional :: option_comment !< Option comment. type ( option ) :: new_option !< New (initiliazed) option instance. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( option_name )) new_option % oname = option_name if ( present ( option_values )) new_option % ovals = option_values if ( present ( option_comment )) new_option % ocomm = option_comment return !--------------------------------------------------------------------------------------------------------------------------------- endfunction new_option","tags":"","loc":"proc/new_option.html","title":"new_option â€“ FiNeR"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % oname % free call self % ovals % free call self % ocomm % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~2.html","title":"free â€“ FiNeR"},{"text":"private pure subroutine get_pairs(self, pairs) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Description Return option name/values pairs. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nc Counter. Source Code pure subroutine get_pairs ( self , pairs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return option name/values pairs. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: Nc !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nc = max ( self % oname % len (), self % ovals % len ()) allocate ( character ( Nc ) :: pairs ( 1 : 2 )) pairs ( 1 ) = self % oname % chars () pairs ( 2 ) = self % ovals % chars () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_pairs","tags":"","loc":"proc/get_pairs.html","title":"get_pairs â€“ FiNeR"},{"text":"private elemental subroutine parse(self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option data from a source string. Source Code elemental subroutine parse ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse option data from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_option if ( scan ( adjustl ( source ), comments ) == 1 ) return call self % parse_name ( sep = sep , source = source , error = error ) call self % parse_value ( sep = sep , source = source , error = error ) call self % parse_comment return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse~2.html","title":"parse â€“ FiNeR"},{"text":"private subroutine get_option(self, val, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description for getting option data value (scalar). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. character(len=:), public, allocatable :: buffer Dummy buffer. Source Code subroutine get_option ( self , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< for getting option data value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_option_vals if ( self % ovals % is_allocated ()) then errd = 0 select type ( val ) #ifdef r16p type is ( real ( R16P )) val = self % ovals % to_number ( kind = 1._R16P ) #endif type is ( real ( R8P )) val = self % ovals % to_number ( kind = 1._R8P ) type is ( real ( R4P )) val = self % ovals % to_number ( kind = 1._R4P ) type is ( integer ( I8P )) val = self % ovals % to_number ( kind = 1_I8P ) type is ( integer ( I4P )) val = self % ovals % to_number ( kind = 1_I4P ) type is ( integer ( I2P )) val = self % ovals % to_number ( kind = 1_I2P ) type is ( integer ( I1P )) val = self % ovals % to_number ( kind = 1_I1P ) type is ( logical ) buffer = self % ovals % chars () read ( buffer , * ) val type is ( character ( * )) val = self % ovals % chars () endselect endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_option","tags":"","loc":"proc/get_option~2.html","title":"get_option â€“ FiNeR"},{"text":"private subroutine get_a_option(self, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option data values (array). Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. integer(kind=I4P), public :: Nv Number of values. type( string ), public, allocatable :: valsV (:) String array of values. integer(kind=I4P), public :: errd Error code. character(len=:), public, allocatable :: buffer Dummy buffer. integer(kind=I4P), public :: v Counter. Source Code subroutine get_a_option ( self , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option data values (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. type ( string ), allocatable :: valsV (:) !< String array of values. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. integer ( I4P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_option_vals dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( self % ovals % is_allocated ()) then errd = 0 call self % ovals % split ( tokens = valsV , sep = dlm ) Nv = size ( valsV , dim = 1 ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R16P ) enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R8P ) enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R4P ) enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I8P ) enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I4P ) enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I2P ) enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I1P ) enddo type is ( logical ) do v = 1 , Nv buffer = valsV ( v )% chars () read ( buffer , * ) val ( v ) enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v )% chars () enddo endselect endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_a_option","tags":"","loc":"proc/get_a_option~2.html","title":"get_a_option â€“ FiNeR"},{"text":"private elemental subroutine parse_comment(self) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Description Parse eventaul option inline comment trimming it out from pure value string. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: pos Characters counter. Source Code elemental subroutine parse_comment ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse eventaul option inline comment trimming it out from pure value string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. integer ( I4P ) :: pos !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % ovals % is_allocated ()) then pos = self % ovals % index ( inline_comment ) if ( pos > 0 ) then if ( pos < self % ovals % len ()) self % ocomm = trim ( adjustl ( self % ovals % slice ( pos + 1 , self % ovals % len ()))) self % ovals = trim ( adjustl ( self % ovals % slice ( 1 , pos - 1 ))) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_comment","tags":"","loc":"proc/parse_comment.html","title":"parse_comment â€“ FiNeR"},{"text":"private elemental subroutine parse_name(self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option name from a source string. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: pos Characters counter. Source Code elemental subroutine parse_name ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse option name from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_option_name pos = index ( source , sep ) if ( pos > 0 ) then self % oname = trim ( adjustl ( source (: pos - 1 ))) error = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_name","tags":"","loc":"proc/parse_name.html","title":"parse_name â€“ FiNeR"},{"text":"private elemental subroutine parse_value(self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option value from a source string. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: pos Characters counter. Source Code elemental subroutine parse_value ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse option value from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_option_vals pos = index ( source , sep ) if ( pos > 0 ) then if ( pos < len ( source )) self % ovals = trim ( adjustl ( source ( pos + 1 :))) error = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_value","tags":"","loc":"proc/parse_value.html","title":"parse_value â€“ FiNeR"},{"text":"private subroutine print_option(self, unit, retain_comments, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. character(len=:), public, allocatable :: comment Eventual option comments. Source Code subroutine print_option ( self , unit , retain_comments , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print data with a pretty format. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % oname % is_allocated ()) then prefd = '' ; if ( present ( pref )) prefd = pref comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_option","tags":"","loc":"proc/print_option.html","title":"print_option â€“ FiNeR"},{"text":"private pure subroutine set_option(self, val) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value. Description Set option data value (scalar). Calls proc~~set_option~~CallsGraph proc~set_option set_option interface~str str proc~set_option->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine set_option ( self , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option data value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val !< Value. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( val ) #ifdef r16p type is ( real ( R16P )) self % ovals = val #endif type is ( real ( R8P )) self % ovals = val type is ( real ( R4P )) self % ovals = val type is ( integer ( I8P )) self % ovals = val type is ( integer ( I4P )) self % ovals = val type is ( integer ( I2P )) self % ovals = val type is ( integer ( I1P )) self % ovals = val type is ( logical ) self % ovals = trim ( str ( n = val )) type is ( character ( * )) self % ovals = val endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_option","tags":"","loc":"proc/set_option.html","title":"set_option â€“ FiNeR"},{"text":"private pure subroutine set_a_option(self, val, delimiter) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Description Set option data value (array). Calls proc~~set_a_option~~CallsGraph proc~set_a_option set_a_option interface~str str proc~set_a_option->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. integer(kind=I4P), public :: v Counter. Source Code pure subroutine set_a_option ( self , val , delimiter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option data value (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val ( 1 :) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter self % ovals = '' select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () #endif type is ( real ( R8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( real ( R4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I2P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I1P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( logical ) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( character ( * )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( val ( v )) enddo self % ovals = self % ovals % strip () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_a_option","tags":"","loc":"proc/set_a_option.html","title":"set_a_option â€“ FiNeR"},{"text":"private subroutine save_option(self, unit, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Save data. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. character(len=:), public, allocatable :: comment Eventual option comments. Source Code subroutine save_option ( self , unit , retain_comments , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save data. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % oname % is_allocated ()) then comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_option","tags":"","loc":"proc/save_option.html","title":"save_option â€“ FiNeR"},{"text":"private elemental subroutine assign_option(lhs, rhs) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. Description Assignment between two options. Source Code elemental subroutine assign_option ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two options. !--------------------------------------------------------------------------------------------------------------------------------- class ( option ), intent ( inout ) :: lhs !< Left hand side. type ( option ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( rhs % oname % is_allocated ()) lhs % oname = rhs % oname if ( rhs % ovals % is_allocated ()) lhs % ovals = rhs % ovals if ( rhs % ocomm % is_allocated ()) lhs % ocomm = rhs % ocomm return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_option","tags":"","loc":"proc/assign_option.html","title":"assign_option â€“ FiNeR"},{"text":"public interface option Overload option name with a function returning a new (itiliazed) option instance. Calls interface~~option~~CallsGraph interface~option option proc~new_option new_option interface~option->proc~new_option Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~option~~CalledByGraph interface~option option proc~add_option~2 add_option proc~add_option~2->interface~option proc~add_a_option~2 add_a_option proc~add_a_option~2->interface~option Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function new_option (option_name, option_values, option_comment) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: option_name Option name. character(len=*), intent(in), optional :: option_values Option values. character(len=*), intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Description Return a new (initiliazed) option instance.","tags":"","loc":"interface/option.html","title":"option â€“ FiNeR"},{"text":"private elemental function bit_size_R16P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P â€“ FiNeR"},{"text":"private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size bit_size interface~bit_size->proc~bit_size_r8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P â€“ FiNeR"},{"text":"private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size bit_size interface~bit_size->proc~bit_size_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P â€“ FiNeR"},{"text":"private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size bit_size interface~bit_size->proc~bit_size_chr Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr â€“ FiNeR"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P â€“ FiNeR"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P â€“ FiNeR"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P â€“ FiNeR"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P â€“ FiNeR"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P â€“ FiNeR"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P â€“ FiNeR"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P â€“ FiNeR"},{"text":"private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr â€“ FiNeR"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~~CallsGraph interface~bit_size bit_size proc~bit_size_r8p bit_size_R8P interface~bit_size->proc~bit_size_r8p proc~bit_size_chr bit_size_chr interface~bit_size->proc~bit_size_chr proc~bit_size_r4p bit_size_R4P interface~bit_size->proc~bit_size_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable.","tags":"","loc":"interface/bit_size.html","title":"bit_size â€“ FiNeR"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~byte_size~~CalledByGraph interface~byte_size byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~decode decode proc~decode->interface~b64_decode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"interface/byte_size.html","title":"byte_size â€“ FiNeR"},{"text":"private elemental function strf_R16P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P â€“ FiNeR"},{"text":"private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P â€“ FiNeR"},{"text":"private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P â€“ FiNeR"},{"text":"private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P â€“ FiNeR"},{"text":"private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P â€“ FiNeR"},{"text":"private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P â€“ FiNeR"},{"text":"private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P â€“ FiNeR"},{"text":"private elemental function str_R16P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P â€“ FiNeR"},{"text":"private elemental function str_R8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P â€“ FiNeR"},{"text":"private elemental function str_R4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P â€“ FiNeR"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P â€“ FiNeR"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P â€“ FiNeR"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P â€“ FiNeR"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P â€“ FiNeR"},{"text":"private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol â€“ FiNeR"},{"text":"private pure function str_a_R16P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P â€“ FiNeR"},{"text":"private pure function str_a_R8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P â€“ FiNeR"},{"text":"private pure function str_a_R4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P â€“ FiNeR"},{"text":"private pure function str_a_I8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P â€“ FiNeR"},{"text":"private pure function str_a_I4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P â€“ FiNeR"},{"text":"private pure function str_a_I2P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P â€“ FiNeR"},{"text":"private pure function str_a_I1P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P â€“ FiNeR"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P â€“ FiNeR"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P â€“ FiNeR"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P â€“ FiNeR"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P â€“ FiNeR"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P â€“ FiNeR"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P â€“ FiNeR"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P â€“ FiNeR"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P â€“ FiNeR"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P â€“ FiNeR"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P â€“ FiNeR"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P â€“ FiNeR"},{"text":"private elemental function bstr_R16P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P â€“ FiNeR"},{"text":"private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P â€“ FiNeR"},{"text":"private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P â€“ FiNeR"},{"text":"private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P â€“ FiNeR"},{"text":"private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P â€“ FiNeR"},{"text":"private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P â€“ FiNeR"},{"text":"private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P â€“ FiNeR"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P â€“ FiNeR"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P â€“ FiNeR"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P â€“ FiNeR"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P â€“ FiNeR"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P â€“ FiNeR"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P â€“ FiNeR"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P â€“ FiNeR"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~set_a_option set_a_option proc~set_a_option->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~set_option set_option proc~set_option->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string.","tags":"","loc":"interface/str.html","title":"str â€“ FiNeR"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros.","tags":"","loc":"interface/strz.html","title":"strz â€“ FiNeR"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer.","tags":"","loc":"interface/cton.html","title":"cton â€“ FiNeR"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits.","tags":"","loc":"interface/bstr.html","title":"bstr â€“ FiNeR"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p interface~str str proc~bctoi_i4p->interface~str proc~bctor_r4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"interface/bcton.html","title":"bcton â€“ FiNeR"},{"text":"private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 â€“ FiNeR"},{"text":"private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 â€“ FiNeR"},{"text":"private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 â€“ FiNeR"},{"text":"private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 â€“ FiNeR"},{"text":"public subroutine check_endian() Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Calls proc~~check_endian~~CallsGraph proc~check_endian check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function is_little_endian() result(is_little) Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Check if the type of the bit ordering of the running architecture is little endian. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian â€“ FiNeR"},{"text":"public subroutine penf_init() Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init â€“ FiNeR"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print â€“ FiNeR"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit.html","title":"digit â€“ FiNeR"},{"text":"private elemental function count_substring(string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. Called By proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: c1 Counters. integer(kind=I4P), public :: c2 Counters. Source Code elemental function count_substring ( string_ , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string_ !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string_ )) return c1 = 1 do c2 = index ( string = string_ ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring","tags":"","loc":"proc/count_substring.html","title":"count_substring â€“ FiNeR"},{"text":"public subroutine read_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Calls proc~~read_file~~CallsGraph proc~read_file read_file proc~read_lines read_lines proc~read_file->proc~read_lines Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. logical, public :: does_exist Check if file exist. Source Code subroutine read_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file","tags":"","loc":"proc/read_file.html","title":"read_file â€“ FiNeR"},{"text":"public subroutine read_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read lines (records) from a connected-formatted unit. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Called By proc~~read_lines~~CalledByGraph proc~read_lines read_lines proc~read_file read_file proc~read_file->proc~read_lines Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. character(kind=CK,len=1), public :: ch Character storage. integer, public :: l Counter. Source Code subroutine read_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines","tags":"","loc":"proc/read_lines.html","title":"read_lines â€“ FiNeR"},{"text":"public subroutine write_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected-formatted unit. Called By proc~~write_lines~~CalledByGraph proc~write_lines write_lines proc~write_file write_file proc~write_file->proc~write_lines Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: l Counter. Source Code subroutine write_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected-formatted unit. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines","tags":"","loc":"proc/write_lines.html","title":"write_lines â€“ FiNeR"},{"text":"public subroutine write_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. Calls proc~~write_file~~CallsGraph proc~write_file write_file proc~write_lines write_lines proc~write_file->proc~write_lines Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. Source Code subroutine write_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file","tags":"","loc":"proc/write_file.html","title":"write_file â€“ FiNeR"},{"text":"public interface adjustl Builtin adjustl overloading. Calls interface~~adjustl~~CallsGraph interface~adjustl adjustl proc~sadjustl_character sadjustl_character interface~adjustl->proc~sadjustl_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output).","tags":"","loc":"interface/adjustl.html","title":"adjustl â€“ FiNeR"},{"text":"public interface adjustr Builtin adjustr overloading. Calls interface~~adjustr~~CallsGraph interface~adjustr adjustr proc~sadjustr_character sadjustr_character interface~adjustr->proc~sadjustr_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output).","tags":"","loc":"interface/adjustr.html","title":"adjustr â€“ FiNeR"},{"text":"public interface count Builtin count overloading. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string.","tags":"","loc":"interface/count.html","title":"count â€“ FiNeR"},{"text":"public interface index Builtin index overloading. Calls interface~~index~~CallsGraph interface~index index proc~sindex_string_character sindex_string_character interface~index->proc~sindex_string_character proc~sindex_string_string sindex_string_string interface~index->proc~sindex_string_string proc~sindex_character_string sindex_character_string interface~index->proc~sindex_character_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first.","tags":"","loc":"interface/index.html","title":"index â€“ FiNeR"},{"text":"public interface len Builtin len overloading. Calls interface~~len~~CallsGraph interface~len len proc~slen slen interface~len->proc~slen Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string.","tags":"","loc":"interface/len.html","title":"len â€“ FiNeR"},{"text":"public interface len_trim Builtin len_trim overloading. Calls interface~~len_trim~~CallsGraph interface~len_trim len_trim proc~slen_trim slen_trim interface~len_trim->proc~slen_trim Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks.","tags":"","loc":"interface/len_trim.html","title":"len_trim â€“ FiNeR"},{"text":"public interface repeat Builtin repeat overloading. Calls interface~~repeat~~CallsGraph interface~repeat repeat proc~srepeat_string_string srepeat_string_string interface~repeat->proc~srepeat_string_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string.","tags":"","loc":"interface/repeat.html","title":"repeat â€“ FiNeR"},{"text":"public interface scan Builtin scan overloading. Calls interface~~scan~~CallsGraph interface~scan scan proc~sscan_string_character sscan_string_character interface~scan->proc~sscan_string_character proc~sscan_string_string sscan_string_string interface~scan->proc~sscan_string_string proc~sscan_character_string sscan_character_string interface~scan->proc~sscan_character_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set .","tags":"","loc":"interface/scan.html","title":"scan â€“ FiNeR"},{"text":"public interface trim Builtin trim overloading. Calls interface~~trim~~CallsGraph interface~trim trim proc~strim strim interface~trim->proc~strim Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces.","tags":"","loc":"interface/trim.html","title":"trim â€“ FiNeR"},{"text":"private elemental function count_values(self, option_name, delimiter) result(Nv) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option into section data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. integer(kind=I4P), public :: o Counter. Source Code elemental function count_values ( self , option_name , delimiter ) result ( Nv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the number of values of option into section data. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then Nv = self % options ( o )% count_values ( delimiter = dlm ) exit endif enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_values","tags":"","loc":"proc/count_values~3.html","title":"count_values â€“ FiNeR"},{"text":"private elemental function has_options(self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value logical Inquire result. Description Inquire is section has options (at least one). Source Code elemental function has_options ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Inquire is section has options (at least one). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. logical :: has_options !< Inquire result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- has_options = allocated ( self % options ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction has_options","tags":"","loc":"proc/has_options.html","title":"has_options â€“ FiNeR"},{"text":"private elemental function index_option(self, option_name, back) result(ind) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the option matching the name passed. Note The matching index returned is the first found if back is not passed or if back=.false. . On the contrary the last\n found is returned if back=.true. . Variables Type Visibility Attributes Name Initial logical, public :: backd Dummy back flag. integer(kind=I4P), public :: o Counter. Source Code elemental function index_option ( self , option_name , back ) result ( ind ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the index of the option matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. logical , optional , intent ( in ) :: back !< If back appears with the value true, the last matching index is returned. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ind = 0 if ( allocated ( self % options )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do o = size ( self % options , dim = 1 ), 1 , - 1 if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo else do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction index_option","tags":"","loc":"proc/index_option~2.html","title":"index_option â€“ FiNeR"},{"text":"private function loop(self, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into section. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, save :: o = 0 Counter. Source Code function loop ( self , option_pairs ) result ( again ) !--------------------------------------------------------------------------------------------------------------------------------- !< Loop returning option name/value defined into section. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ), save :: o = 0 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- again = . false . if ( allocated ( self % options )) then if ( o == 0 ) then o = lbound ( self % options , dim = 1 ) call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . elseif ( o < ubound ( self % options , dim = 1 )) then o = o + 1 call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . else o = 0 again = . false . endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction loop","tags":"","loc":"proc/loop.html","title":"loop â€“ FiNeR"},{"text":"private elemental function max_chars_len(self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer Inquire result. Description Return the maximum number of characters between option-name/option-values on all options. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: o Counter. Source Code elemental function max_chars_len ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of characters between option-name/option-values on all options. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer :: max_chars_len !< Inquire result. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_chars_len = MinI4P if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) max_chars_len = max ( max_chars_len , self % options ( o )% name_len (), self % options ( o )% values_len ()) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_chars_len","tags":"","loc":"proc/max_chars_len.html","title":"max_chars_len â€“ FiNeR"},{"text":"private pure function name(self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value character(len=len(self%sname)) Section data. Description Return section name. Source Code pure function name ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return section name. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( len = len ( self % sname )) :: name !< Section data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sname )) name = self % sname return !--------------------------------------------------------------------------------------------------------------------------------- endfunction name","tags":"","loc":"proc/name.html","title":"name â€“ FiNeR"},{"text":"private elemental function options_number(self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer Options number. Description Return the options number. Source Code elemental function options_number ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the options number. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer :: options_number !< Options number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) options_number = size ( self % options , dim = 1 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction options_number","tags":"","loc":"proc/options_number.html","title":"options_number â€“ FiNeR"},{"text":"private elemental function section_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. Source Code elemental function section_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % sname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction section_eq_string","tags":"","loc":"proc/section_eq_string.html","title":"section_eq_string â€“ FiNeR"},{"text":"private elemental function section_eq_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. Source Code elemental function section_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % sname == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction section_eq_character","tags":"","loc":"proc/section_eq_character.html","title":"section_eq_character â€“ FiNeR"},{"text":"private elemental function new_section(section_name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Description Return a new (initiliazed) section instance. Called By proc~~new_section~~CalledByGraph proc~new_section new_section interface~section section interface~section->proc~new_section proc~add_section add_section proc~add_section->interface~section Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function new_section ( section_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a new (initiliazed) section instance. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ), optional :: section_name !< Option name. type ( section ) :: new_section !< New (initiliazed) section instance. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( section_name )) new_section % sname = section_name return !--------------------------------------------------------------------------------------------------------------------------------- endfunction new_section","tags":"","loc":"proc/new_section.html","title":"new_section â€“ FiNeR"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sname )) deallocate ( self % sname ) if ( allocated ( self % options )) then call self % options % free deallocate ( self % options ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~3.html","title":"free â€“ FiNeR"},{"text":"private elemental subroutine free_options(self) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Description Free all options. Source Code elemental subroutine free_options ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free all options. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then call self % options % free deallocate ( self % options ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_options","tags":"","loc":"proc/free_options.html","title":"free_options â€“ FiNeR"},{"text":"private elemental subroutine free_option(self, option_name) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. Description Free an option. Variables Type Visibility Attributes Name Initial type( option ), public, allocatable :: options (:) Temporary options array. integer(kind=I4P), public :: o Counter. Source Code elemental subroutine free_option ( self , option_name ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free an option. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then o = self % index ( option_name = option_name ) if ( o > 0 ) then allocate ( options ( 1 : size ( self % options , dim = 1 ) - 1 )) if ( o == 1 ) then options = self % options ( 2 :) elseif ( o == size ( self % options , dim = 1 )) then options = self % options (: o - 1 ) else options (: o - 1 ) = self % options (: o - 1 ) options ( o : ) = self % options ( o + 1 :) endif call move_alloc ( options , self % options ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_option","tags":"","loc":"proc/free_option.html","title":"free_option â€“ FiNeR"},{"text":"private pure subroutine option_pairs(self, option_index, pairs) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Option data. integer, intent(in) :: option_index Option index. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Description Return an option pairs. Source Code pure subroutine option_pairs ( self , option_index , pairs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return an option pairs. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Option data. integer , intent ( in ) :: option_index !< Option index. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % options ( option_index )% get_pairs ( pairs = pairs ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine option_pairs","tags":"","loc":"proc/option_pairs.html","title":"option_pairs â€“ FiNeR"},{"text":"private elemental subroutine parse(self, sep, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Gett section data from a source string. Source Code elemental subroutine parse ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Gett section data from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % parse_name ( source = source , error = error ) call self % parse_options ( sep = sep , source = source , error = error ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse~3.html","title":"parse â€“ FiNeR"},{"text":"private subroutine print_section(self, unit, retain_comments, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. integer(kind=I4P), public :: o Counter. Source Code subroutine print_section ( self , unit , retain_comments , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print data with a pretty format. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% print ( pref = prefd // '  ' , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_section","tags":"","loc":"proc/print_section.html","title":"print_section â€“ FiNeR"},{"text":"private subroutine save_section(self, unit, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Save data. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. integer(kind=I4P), public :: o Counter. Source Code subroutine save_section ( self , unit , retain_comments , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save data. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_section","tags":"","loc":"proc/save_section.html","title":"save_section â€“ FiNeR"},{"text":"private pure subroutine add_option(self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with scalar value). If the option already exists, its value is updated. Calls proc~~add_option~2~~CallsGraph proc~add_option~2 add_option interface~option option proc~add_option~2->interface~option proc~new_option new_option interface~option->proc~new_option Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( option ), public, allocatable :: options (:) Temporary options array. integer(kind=I4P), public :: errd Error code. Source Code pure subroutine add_option ( self , option_name , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options if ( allocated ( self % options )) then call self % set ( error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_option","tags":"","loc":"proc/add_option~2.html","title":"add_option â€“ FiNeR"},{"text":"private pure subroutine add_a_option(self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with array value). If the option already exists, its value is updated. Calls proc~~add_a_option~2~~CallsGraph proc~add_a_option~2 add_a_option interface~option option proc~add_a_option~2->interface~option proc~new_option new_option interface~option->proc~new_option Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( option ), public, allocatable :: options (:) Temporary options array. integer(kind=I4P), public :: errd Error code. character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. Source Code pure subroutine add_a_option ( self , option_name , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add an option (with array value). !< !< If the option already exists, its value is updated. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Option value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = err_section_options if ( allocated ( self % options )) then call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_a_option","tags":"","loc":"proc/add_a_option~2.html","title":"add_a_option â€“ FiNeR"},{"text":"private subroutine get_option(self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option value (scalar). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. integer(kind=I4P), public :: o Counter. Source Code subroutine get_option ( self , option_name , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get option value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( error = errd , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_option","tags":"","loc":"proc/get_option~3.html","title":"get_option â€“ FiNeR"},{"text":"private subroutine get_a_option(self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Procedure for getting option value (array). Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. integer(kind=I4P), public :: errd Error code. integer(kind=I4P), public :: o Counter. Source Code subroutine get_a_option ( self , option_name , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for getting option value (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( delimiter = dlm , error = errd , val = val ) if ( present ( error )) error = errd exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_a_option","tags":"","loc":"proc/get_a_option~3.html","title":"get_a_option â€“ FiNeR"},{"text":"private elemental subroutine parse_name(self, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Get section name from a source string. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: pos (1:2) Characters counter. Source Code elemental subroutine parse_name ( self , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get section name from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos ( 1 : 2 ) !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = err_section_name pos ( 1 ) = index ( source , \"[\" ) pos ( 2 ) = index ( source , \"]\" ) if ( all ( pos > 0 )) then self % sname = trim ( adjustl ( source ( pos ( 1 ) + 1 : pos ( 2 ) - 1 ))) error = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_name","tags":"","loc":"proc/parse_name~2.html","title":"parse_name â€“ FiNeR"},{"text":"private elemental subroutine parse_options(self, sep, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Get section options from a source string. Variables Type Visibility Attributes Name Initial character(len=len(source)), public :: osource String containing options data. character(len=len(source)), public, allocatable :: options (:) Options strings tokenized. type( string ), public, allocatable :: tokens (:) Options strings tokenized. character(len=len(source)), public :: dummy Dummy string for parsing options. type( string ), public :: dummy_str Dummy string. integer(kind=I4P), public :: No Counter. integer(kind=I4P), public :: o Counter. integer(kind=I4P), public :: oo Counter. Source Code elemental subroutine parse_options ( self , sep , source , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get section options from a source string. !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. character ( * ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. character ( len ( source )) :: osource !< String containing options data. character ( len ( source )), allocatable :: options (:) !< Options strings tokenized. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. character ( len ( source )) :: dummy !< Dummy string for parsing options. type ( string ) :: dummy_str !< Dummy string. integer ( I4P ) :: No !< Counter. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: oo !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- error = 0 osource = trim ( adjustl ( source ( index ( source , \"]\" ) + 1 :))) ! to remove after StringiFor adoption dummy_str = osource call dummy_str % split ( tokens = tokens , sep = new_line ( 'a' )) allocate ( options ( 1 : size ( tokens , dim = 1 ))) do o = 1 , size ( tokens , dim = 1 ) options ( o ) = tokens ( o )% chars () enddo ! call tokenize(strin=osource, delimiter=new_line('A'), toks=options) ! to remove after StringiFor adoption No = 0 o = 0 do while ( o + 1 <= size ( options , dim = 1 )) o = o + 1 if ( scan ( adjustl ( options ( o )), comments ) == 1 ) cycle if ( index ( options ( o ), sep ) > 0 ) then No = No + 1 dummy = options ( o ) oo = o do while ( oo + 1 <= size ( options , dim = 1 )) oo = oo + 1 if ( index ( options ( oo ), sep ) > 0 ) then ! new option... go back exit else ! continuation of current option dummy = trim ( adjustl ( dummy )) // \" \" // trim ( adjustl ( options ( oo ))) options ( oo ) = comments ! forcing skip this in the following scan endif enddo options ( o ) = trim ( adjustl ( dummy )) endif enddo if ( No > 0 ) then if ( allocated ( self % options )) deallocate ( self % options ) ; allocate ( self % options ( 1 : No )) o = 0 oo = 0 do while ( o + 1 <= size ( options , dim = 1 )) o = o + 1 if ( scan ( adjustl ( options ( o )), comments ) == 1 ) cycle if ( index ( options ( o ), sep ) > 0 ) then oo = oo + 1 call self % options ( oo )% parse ( sep = sep , source = options ( o ), error = error ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_options","tags":"","loc":"proc/parse_options.html","title":"parse_options â€“ FiNeR"},{"text":"private pure subroutine set_option(self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (scalar). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. integer(kind=I4P), public :: o Counter. Source Code pure subroutine set_option ( self , option_name , val , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option value (scalar). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Value. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- errd = err_section_options if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_option","tags":"","loc":"proc/set_option~2.html","title":"set_option â€“ FiNeR"},{"text":"private pure subroutine set_a_option(self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (array). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: errd Error code. character(len=:), public, allocatable :: dlm Dummy string for delimiter handling. integer(kind=I4P), public :: o Counter. Source Code pure subroutine set_a_option ( self , option_name , val , delimiter , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set option value (array). !--------------------------------------------------------------------------------------------------------------------------------- class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Value. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = err_section_options if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( delimiter = dlm , val = val ) exit endif enddo endif if ( present ( error )) error = errd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_a_option","tags":"","loc":"proc/set_a_option~2.html","title":"set_a_option â€“ FiNeR"},{"text":"private elemental subroutine assign_section(lhs, rhs) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. Description Assignment between two sections. Source Code elemental subroutine assign_section ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two sections. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( section ), intent ( INOUT ) :: lhs !< Left hand side. type ( section ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % sname )) lhs % sname = rhs % sname if ( allocated ( rhs % options )) then if ( allocated ( lhs % options )) deallocate ( lhs % options ) ; allocate ( lhs % options ( 1 : size ( rhs % options , dim = 1 ))) lhs % options = rhs % options endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_section","tags":"","loc":"proc/assign_section.html","title":"assign_section â€“ FiNeR"},{"text":"public interface section Overload section name with a function returning a new (itiliazed) section instance. Calls interface~~section~~CallsGraph interface~section section proc~new_section new_section interface~section->proc~new_section Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~section~~CalledByGraph interface~section section proc~add_section add_section proc~add_section->interface~section Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function new_section (section_name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Description Return a new (initiliazed) section instance.","tags":"","loc":"interface/section.html","title":"section â€“ FiNeR"},{"text":"private pure subroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_r4~~CalledByGraph proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_r4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4","tags":"","loc":"proc/pack_data_r8_r4.html","title":"pack_data_R8_R4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i8~~CalledByGraph proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8","tags":"","loc":"proc/pack_data_r8_i8.html","title":"pack_data_R8_I8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i4~~CalledByGraph proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4","tags":"","loc":"proc/pack_data_r8_i4.html","title":"pack_data_R8_I4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i2~~CalledByGraph proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2","tags":"","loc":"proc/pack_data_r8_i2.html","title":"pack_data_R8_I2 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i1~~CalledByGraph proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1","tags":"","loc":"proc/pack_data_r8_i1.html","title":"pack_data_R8_I1 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_r8~~CalledByGraph proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_r8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8","tags":"","loc":"proc/pack_data_r4_r8.html","title":"pack_data_R4_R8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i8~~CalledByGraph proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8","tags":"","loc":"proc/pack_data_r4_i8.html","title":"pack_data_R4_I8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i4~~CalledByGraph proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4","tags":"","loc":"proc/pack_data_r4_i4.html","title":"pack_data_R4_I4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i2~~CalledByGraph proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2","tags":"","loc":"proc/pack_data_r4_i2.html","title":"pack_data_R4_I2 â€“ FiNeR"},{"text":"private pure subroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i1~~CalledByGraph proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1","tags":"","loc":"proc/pack_data_r4_i1.html","title":"pack_data_R4_I1 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r8~~CalledByGraph proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8","tags":"","loc":"proc/pack_data_i8_r8.html","title":"pack_data_I8_R8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r4~~CalledByGraph proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4","tags":"","loc":"proc/pack_data_i8_r4.html","title":"pack_data_I8_R4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i4~~CalledByGraph proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4","tags":"","loc":"proc/pack_data_i8_i4.html","title":"pack_data_I8_I4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i2~~CalledByGraph proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2","tags":"","loc":"proc/pack_data_i8_i2.html","title":"pack_data_I8_I2 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i1~~CalledByGraph proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1","tags":"","loc":"proc/pack_data_i8_i1.html","title":"pack_data_I8_I1 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r8~~CalledByGraph proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8","tags":"","loc":"proc/pack_data_i4_r8.html","title":"pack_data_I4_R8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r4~~CalledByGraph proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4","tags":"","loc":"proc/pack_data_i4_r4.html","title":"pack_data_I4_R4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i8~~CalledByGraph proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8","tags":"","loc":"proc/pack_data_i4_i8.html","title":"pack_data_I4_I8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i2~~CalledByGraph proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2","tags":"","loc":"proc/pack_data_i4_i2.html","title":"pack_data_I4_I2 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i1~~CalledByGraph proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1","tags":"","loc":"proc/pack_data_i4_i1.html","title":"pack_data_I4_I1 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r8~~CalledByGraph proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8","tags":"","loc":"proc/pack_data_i2_r8.html","title":"pack_data_I2_R8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r4~~CalledByGraph proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4","tags":"","loc":"proc/pack_data_i2_r4.html","title":"pack_data_I2_R4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i8~~CalledByGraph proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8","tags":"","loc":"proc/pack_data_i2_i8.html","title":"pack_data_I2_I8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i4~~CalledByGraph proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4","tags":"","loc":"proc/pack_data_i2_i4.html","title":"pack_data_I2_I4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i1~~CalledByGraph proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1","tags":"","loc":"proc/pack_data_i2_i1.html","title":"pack_data_I2_I1 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r8~~CalledByGraph proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8","tags":"","loc":"proc/pack_data_i1_r8.html","title":"pack_data_I1_R8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r4~~CalledByGraph proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4","tags":"","loc":"proc/pack_data_i1_r4.html","title":"pack_data_I1_R4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i8~~CalledByGraph proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8","tags":"","loc":"proc/pack_data_i1_i8.html","title":"pack_data_I1_I8 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i4~~CalledByGraph proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4","tags":"","loc":"proc/pack_data_i1_i4.html","title":"pack_data_I1_I4 â€“ FiNeR"},{"text":"private pure subroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i2~~CalledByGraph proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2","tags":"","loc":"proc/pack_data_i1_i2.html","title":"pack_data_I1_I2 â€“ FiNeR"},{"text":"public interface pack_data Pack different kinds of data into single I1P array. This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. Note This procedure exploits the transfer builtin function, that from the standard (2003+) is defined as TRANSFER(SOURCE, MOLD [, SIZE]) . Data object having a physical representation identical to that of SOURCE but with the type\n and type parameters of MOLD . The result is of the same type and type parameters as MOLD .\n If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small as possible such\n that its physical representation is not shorter than that of SOURCE . Presently, the following combinations are available: Arrays-Arrays: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Scalars-Scalars: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Examples of usage Packing two real arrays, one with kind R8P and one with R4P real ( R8P ) :: array_r8 ( 1 : 12 ) real ( R4P ) :: array_r4 ( - 1 : 5 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r8 , a2 = array_r4 , packed = rpack ) Packing two arrays, one real with kind R4P and one integer with I4P real ( R4P ) :: array_r4 ( 2 ) integer ( I4P ) :: array_i4 ( 0 : 2 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r4 , a2 = array_i4 , packed = rpack ) Calls interface~~pack_data~~CallsGraph interface~pack_data pack_data proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data->proc~pack_data_r8_i4 proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data->proc~pack_data_i4_i2 proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data->proc~pack_data_r8_i2 proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data->proc~pack_data_i4_i1 proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data->proc~pack_data_r8_i1 proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data->proc~pack_data_i2_r8 proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data->proc~pack_data_r4_r8 proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data->proc~pack_data_i2_r4 proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data->proc~pack_data_r4_i8 proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data->proc~pack_data_i2_i8 proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data->proc~pack_data_r8_r4 proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data->proc~pack_data_r4_i4 proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data->proc~pack_data_i2_i4 proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data->proc~pack_data_r4_i2 proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data->proc~pack_data_i2_i1 proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data->proc~pack_data_r4_i1 proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data->proc~pack_data_i1_r8 proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data->proc~pack_data_i8_r8 proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data->proc~pack_data_i1_r4 proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data->proc~pack_data_i8_r4 proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data->proc~pack_data_i1_i8 proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data->proc~pack_data_i8_i4 proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data->proc~pack_data_i1_i4 proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data->proc~pack_data_i4_i8 proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data->proc~pack_data_i8_i2 proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data->proc~pack_data_i1_i2 proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data->proc~pack_data_i8_i1 proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data->proc~pack_data_i4_r8 proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data->proc~pack_data_i4_r4 proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data->proc~pack_data_r8_i8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"interface/pack_data.html","title":"pack_data â€“ FiNeR"},{"text":"public subroutine b64_init() Arguments None Description Initialize the BeFoR64 library. Note This procedure must be called before encoding/decoding anything! Called By proc~~b64_init~~CalledByGraph proc~b64_init b64_init proc~autotest autotest proc~autotest->proc~b64_init Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init","tags":"","loc":"proc/b64_init.html","title":"b64_init â€“ FiNeR"},{"text":"private pure subroutine encode_bits(bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) +--first octet--+-second octet--+--third octet--+\n |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n +-----------+---+-------+-------+---+-----------+\n |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n +--1.index--+--2.index--+--3.index--+--4.index--+ Note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. Note The number of paddings must be computed outside this procedure, into the calling scope. Warning This procedure is the backend of encoding, thus it must be never called outside the module. Called By proc~~encode_bits~~CalledByGraph proc~encode_bits encode_bits proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_i2->proc~encode_bits proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r16 b64_encode_R16 proc~b64_encode_r16->proc~encode_bits proc~b64_encode_r16_a b64_encode_R16_a proc~b64_encode_r16_a->proc~encode_bits proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_r4->proc~encode_bits proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_i1->proc~encode_bits proc~b64_encode_string b64_encode_string proc~b64_encode_string->proc~encode_bits proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8_a interface~b64_encode->proc~b64_encode_i8 interface~b64_encode->proc~b64_encode_i2_a interface~b64_encode->proc~b64_encode_i2 interface~b64_encode->proc~b64_encode_i4 interface~b64_encode->proc~b64_encode_r4_a interface~b64_encode->proc~b64_encode_i4_a interface~b64_encode->proc~b64_encode_r8 interface~b64_encode->proc~b64_encode_i1_a interface~b64_encode->proc~b64_encode_r4 interface~b64_encode->proc~b64_encode_i1 interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_i8_a interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_up->proc~b64_encode_i2 proc~b64_encode_up->proc~b64_encode_i4 proc~b64_encode_up->proc~b64_encode_r8 proc~b64_encode_up->proc~b64_encode_r4 proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_up->proc~b64_encode_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits","tags":"","loc":"proc/encode_bits.html","title":"encode_bits â€“ FiNeR"},{"text":"private pure subroutine decode_bits(code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code QUJD the decoding process must do +-b64 char--+-b64 char--+-b64 char--+-b64 char--+\n |      Q    |      U    |      J    |      D    |\n +-b64 index-+-b64 index-+-b64 index-+-b64 index-+\n !      16   |      20   |      9    |      3    |\n +-6 bits----+-6 bits----+-6 bits----+-6 bits----+\n |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1|\n +-----------+---+-------+-------+---+-----------+\n |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1|\n +-----8 bits----+-----8 bits----+-----8 bits----+ Note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. Warning This procedure is the backend of decoding, thus it must be never called outside the module. Called By proc~~decode_bits~~CalledByGraph proc~decode_bits decode_bits proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_r16_a b64_decode_R16_a proc~b64_decode_r16_a->proc~decode_bits proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_i8->proc~decode_bits proc~b64_decode_string b64_decode_string proc~b64_decode_string->proc~decode_bits proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r16 b64_decode_R16 proc~b64_decode_r16->proc~decode_bits proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_r8->proc~decode_bits proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_up_a->proc~b64_decode_i1_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8_a interface~b64_decode->proc~b64_decode_i8 interface~b64_decode->proc~b64_decode_string interface~b64_decode->proc~b64_decode_i8_a interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_i4 interface~b64_decode->proc~b64_decode_i2_a interface~b64_decode->proc~b64_decode_r4 interface~b64_decode->proc~b64_decode_i2 interface~b64_decode->proc~b64_decode_r4_a interface~b64_decode->proc~b64_decode_i4_a interface~b64_decode->proc~b64_decode_i1 interface~b64_decode->proc~b64_decode_i1_a interface~b64_decode->proc~b64_decode_r8 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_up->proc~b64_decode_string proc~b64_decode_up->proc~b64_decode_i4 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_up->proc~b64_decode_r8 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits","tags":"","loc":"proc/decode_bits.html","title":"decode_bits â€“ FiNeR"},{"text":"public subroutine b64_encode_up(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. Calls proc~~b64_encode_up~~CallsGraph proc~b64_encode_up b64_encode_up proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up->proc~b64_encode_i2 proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up->proc~b64_encode_i4 proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up->proc~b64_encode_r8 proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up->proc~b64_encode_r4 proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_string b64_encode_string proc~b64_encode_up->proc~b64_encode_string proc~encode_bits encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_string->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up","tags":"","loc":"proc/b64_encode_up.html","title":"b64_encode_up â€“ FiNeR"},{"text":"private pure subroutine b64_encode_up_a(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. Calls proc~~b64_encode_up_a~~CallsGraph proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_up_a~~CalledByGraph proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a","tags":"","loc":"proc/b64_encode_up_a.html","title":"b64_encode_up_a â€“ FiNeR"},{"text":"public subroutine b64_decode_up(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. Calls proc~~b64_decode_up~~CallsGraph proc~b64_decode_up b64_decode_up proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_string b64_decode_string proc~b64_decode_up->proc~b64_decode_string proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up->proc~b64_decode_i4 proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up->proc~b64_decode_r8 proc~decode_bits decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_string->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~b64_decode_i4->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up","tags":"","loc":"proc/b64_decode_up.html","title":"b64_decode_up â€“ FiNeR"},{"text":"private subroutine b64_decode_up_a(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Calls proc~~b64_decode_up_a~~CallsGraph proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~decode_bits decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_up_a~~CalledByGraph proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a","tags":"","loc":"proc/b64_decode_up_a.html","title":"b64_decode_up_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_R16(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). Calls proc~~b64_encode_r16~~CallsGraph proc~b64_encode_r16 b64_encode_R16 proc~encode_bits encode_bits proc~b64_encode_r16->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16","tags":"","loc":"proc/b64_encode_r16.html","title":"b64_encode_R16 â€“ FiNeR"},{"text":"private pure subroutine b64_encode_R8(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). Calls proc~~b64_encode_r8~~CallsGraph proc~b64_encode_r8 b64_encode_R8 proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8~~CalledByGraph proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8","tags":"","loc":"proc/b64_encode_r8.html","title":"b64_encode_R8 â€“ FiNeR"},{"text":"private pure subroutine b64_encode_R4(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). Calls proc~~b64_encode_r4~~CallsGraph proc~b64_encode_r4 b64_encode_R4 proc~encode_bits encode_bits proc~b64_encode_r4->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4~~CalledByGraph proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4","tags":"","loc":"proc/b64_encode_r4.html","title":"b64_encode_R4 â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I8(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). Calls proc~~b64_encode_i8~~CallsGraph proc~b64_encode_i8 b64_encode_I8 proc~encode_bits encode_bits proc~b64_encode_i8->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8~~CalledByGraph proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8","tags":"","loc":"proc/b64_encode_i8.html","title":"b64_encode_I8 â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I4(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). Calls proc~~b64_encode_i4~~CallsGraph proc~b64_encode_i4 b64_encode_I4 proc~encode_bits encode_bits proc~b64_encode_i4->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4~~CalledByGraph proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4","tags":"","loc":"proc/b64_encode_i4.html","title":"b64_encode_I4 â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I2(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). Calls proc~~b64_encode_i2~~CallsGraph proc~b64_encode_i2 b64_encode_I2 proc~encode_bits encode_bits proc~b64_encode_i2->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2~~CalledByGraph proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i2 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2","tags":"","loc":"proc/b64_encode_i2.html","title":"b64_encode_I2 â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I1(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). Calls proc~~b64_encode_i1~~CallsGraph proc~b64_encode_i1 b64_encode_I1 proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1~~CalledByGraph proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i1 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1","tags":"","loc":"proc/b64_encode_i1.html","title":"b64_encode_I1 â€“ FiNeR"},{"text":"private pure subroutine b64_encode_string(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. Calls proc~~b64_encode_string~~CallsGraph proc~b64_encode_string b64_encode_string interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string->proc~encode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string~~CalledByGraph proc~b64_encode_string b64_encode_string proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string","tags":"","loc":"proc/b64_encode_string.html","title":"b64_encode_string â€“ FiNeR"},{"text":"private pure subroutine b64_encode_R16_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). Calls proc~~b64_encode_r16_a~~CallsGraph proc~b64_encode_r16_a b64_encode_R16_a proc~encode_bits encode_bits proc~b64_encode_r16_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a","tags":"","loc":"proc/b64_encode_r16_a.html","title":"b64_encode_R16_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_R8_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). Calls proc~~b64_encode_r8_a~~CallsGraph proc~b64_encode_r8_a b64_encode_R8_a proc~encode_bits encode_bits proc~b64_encode_r8_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8_a~~CalledByGraph proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a","tags":"","loc":"proc/b64_encode_r8_a.html","title":"b64_encode_R8_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_R4_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). Calls proc~~b64_encode_r4_a~~CallsGraph proc~b64_encode_r4_a b64_encode_R4_a proc~encode_bits encode_bits proc~b64_encode_r4_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4_a~~CalledByGraph proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a","tags":"","loc":"proc/b64_encode_r4_a.html","title":"b64_encode_R4_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I8_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). Calls proc~~b64_encode_i8_a~~CallsGraph proc~b64_encode_i8_a b64_encode_I8_a proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8_a~~CalledByGraph proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a","tags":"","loc":"proc/b64_encode_i8_a.html","title":"b64_encode_I8_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I4_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). Calls proc~~b64_encode_i4_a~~CallsGraph proc~b64_encode_i4_a b64_encode_I4_a proc~encode_bits encode_bits proc~b64_encode_i4_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4_a~~CalledByGraph proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a","tags":"","loc":"proc/b64_encode_i4_a.html","title":"b64_encode_I4_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I2_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). Calls proc~~b64_encode_i2_a~~CallsGraph proc~b64_encode_i2_a b64_encode_I2_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2_a~~CalledByGraph proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i2_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a","tags":"","loc":"proc/b64_encode_i2_a.html","title":"b64_encode_I2_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_I1_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). Calls proc~~b64_encode_i1_a~~CallsGraph proc~b64_encode_i1_a b64_encode_I1_a proc~encode_bits encode_bits proc~b64_encode_i1_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1_a~~CalledByGraph proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i1_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a","tags":"","loc":"proc/b64_encode_i1_a.html","title":"b64_encode_I1_a â€“ FiNeR"},{"text":"private pure subroutine b64_encode_string_a(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. Calls proc~~b64_encode_string_a~~CallsGraph proc~b64_encode_string_a b64_encode_string_a interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string_a->proc~encode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string_a~~CalledByGraph proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a","tags":"","loc":"proc/b64_encode_string_a.html","title":"b64_encode_string_a â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_R16(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). Calls proc~~b64_decode_r16~~CallsGraph proc~b64_decode_r16 b64_decode_R16 proc~decode_bits decode_bits proc~b64_decode_r16->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16","tags":"","loc":"proc/b64_decode_r16.html","title":"b64_decode_R16 â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_R8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). Calls proc~~b64_decode_r8~~CallsGraph proc~b64_decode_r8 b64_decode_R8 proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8~~CalledByGraph proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8","tags":"","loc":"proc/b64_decode_r8.html","title":"b64_decode_R8 â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_R4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). Calls proc~~b64_decode_r4~~CallsGraph proc~b64_decode_r4 b64_decode_R4 proc~decode_bits decode_bits proc~b64_decode_r4->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4~~CalledByGraph proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4","tags":"","loc":"proc/b64_decode_r4.html","title":"b64_decode_R4 â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_I8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). Calls proc~~b64_decode_i8~~CallsGraph proc~b64_decode_i8 b64_decode_I8 proc~decode_bits decode_bits proc~b64_decode_i8->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8~~CalledByGraph proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8","tags":"","loc":"proc/b64_decode_i8.html","title":"b64_decode_I8 â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_I4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). Calls proc~~b64_decode_i4~~CallsGraph proc~b64_decode_i4 b64_decode_I4 proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4~~CalledByGraph proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4","tags":"","loc":"proc/b64_decode_i4.html","title":"b64_decode_I4 â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_I2(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). Calls proc~~b64_decode_i2~~CallsGraph proc~b64_decode_i2 b64_decode_I2 proc~decode_bits decode_bits proc~b64_decode_i2->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2~~CalledByGraph proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i2 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2","tags":"","loc":"proc/b64_decode_i2.html","title":"b64_decode_I2 â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_I1(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). Calls proc~~b64_decode_i1~~CallsGraph proc~b64_decode_i1 b64_decode_I1 proc~decode_bits decode_bits proc~b64_decode_i1->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1~~CalledByGraph proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i1 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1","tags":"","loc":"proc/b64_decode_i1.html","title":"b64_decode_I1 â€“ FiNeR"},{"text":"private elemental subroutine b64_decode_string(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. Calls proc~~b64_decode_string~~CallsGraph proc~b64_decode_string b64_decode_string interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string~~CalledByGraph proc~b64_decode_string b64_decode_string proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string","tags":"","loc":"proc/b64_decode_string.html","title":"b64_decode_string â€“ FiNeR"},{"text":"private pure subroutine b64_decode_R16_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). Calls proc~~b64_decode_r16_a~~CallsGraph proc~b64_decode_r16_a b64_decode_R16_a proc~decode_bits decode_bits proc~b64_decode_r16_a->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a","tags":"","loc":"proc/b64_decode_r16_a.html","title":"b64_decode_R16_a â€“ FiNeR"},{"text":"private pure subroutine b64_decode_R8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). Calls proc~~b64_decode_r8_a~~CallsGraph proc~b64_decode_r8_a b64_decode_R8_a proc~decode_bits decode_bits proc~b64_decode_r8_a->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8_a~~CalledByGraph proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a","tags":"","loc":"proc/b64_decode_r8_a.html","title":"b64_decode_R8_a â€“ FiNeR"},{"text":"private pure subroutine b64_decode_R4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). Calls proc~~b64_decode_r4_a~~CallsGraph proc~b64_decode_r4_a b64_decode_R4_a proc~decode_bits decode_bits proc~b64_decode_r4_a->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4_a~~CalledByGraph proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a","tags":"","loc":"proc/b64_decode_r4_a.html","title":"b64_decode_R4_a â€“ FiNeR"},{"text":"private pure subroutine b64_decode_I8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). Calls proc~~b64_decode_i8_a~~CallsGraph proc~b64_decode_i8_a b64_decode_I8_a proc~decode_bits decode_bits proc~b64_decode_i8_a->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8_a~~CalledByGraph proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a","tags":"","loc":"proc/b64_decode_i8_a.html","title":"b64_decode_I8_a â€“ FiNeR"},{"text":"private pure subroutine b64_decode_I4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). Calls proc~~b64_decode_i4_a~~CallsGraph proc~b64_decode_i4_a b64_decode_I4_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4_a~~CalledByGraph proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a","tags":"","loc":"proc/b64_decode_i4_a.html","title":"b64_decode_I4_a â€“ FiNeR"},{"text":"private pure subroutine b64_decode_I2_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). Calls proc~~b64_decode_i2_a~~CallsGraph proc~b64_decode_i2_a b64_decode_I2_a proc~decode_bits decode_bits proc~b64_decode_i2_a->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2_a~~CalledByGraph proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i2_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a","tags":"","loc":"proc/b64_decode_i2_a.html","title":"b64_decode_I2_a â€“ FiNeR"},{"text":"private pure subroutine b64_decode_I1_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). Calls proc~~b64_decode_i1_a~~CallsGraph proc~b64_decode_i1_a b64_decode_I1_a proc~decode_bits decode_bits proc~b64_decode_i1_a->proc~decode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1_a~~CalledByGraph proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i1_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a","tags":"","loc":"proc/b64_decode_i1_a.html","title":"b64_decode_I1_a â€“ FiNeR"},{"text":"private pure subroutine b64_decode_string_a(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. Calls proc~~b64_decode_string_a~~CallsGraph proc~b64_decode_string_a b64_decode_string_a interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string_a->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string_a~~CalledByGraph proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a","tags":"","loc":"proc/b64_decode_string_a.html","title":"b64_decode_string_a â€“ FiNeR"},{"text":"public subroutine autotest() Arguments None Description Procedure for autotesting the library functionalities. Note Into the src directory there is a small python script ( validation.py ) that can be used to validate the library\n correctness by a comparison with other widely used tools such as the python builtin module struct . Calls proc~~autotest~~CallsGraph proc~autotest autotest interface~b64_decode b64_decode proc~autotest->interface~b64_decode interface~str str proc~autotest->interface~str proc~b64_init b64_init proc~autotest->proc~b64_init interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p proc~b64_encode_string->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_string_a->proc~encode_bits Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: code64 Base64 code. logical, public :: ok Flag for checking the result of encoding/decoding. real(kind=R8P), public :: scalar_R8 Decoded scalar. real(kind=R4P), public :: scalar_R4 Decoded scalar. integer(kind=I8P), public :: scalar_I8 Decoded scalar. integer(kind=I4P), public :: scalar_I4 Decoded scalar. integer(kind=I2P), public :: scalar_I2 Decoded scalar. integer(kind=I1P), public :: scalar_I1 Decoded scalar. real(kind=R8P), public :: array_R8 (1:2) Decoded array. real(kind=R4P), public :: array_R4 (1:2) Decoded array. integer(kind=I8P), public :: array_I8 (1:4) Decoded array. integer(kind=I4P), public :: array_I4 (1:2) Decoded array. integer(kind=I2P), public :: array_I2 (1:2) Decoded array. integer(kind=I1P), public :: array_I1 (1:2) Decoded array. character(len=5), public :: array_s (1:2) Decoded array. Source Code subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest","tags":"","loc":"proc/autotest.html","title":"autotest â€“ FiNeR"},{"text":"public interface b64_encode Encode numbers (integer and real) to base64. This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both\n scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode~~CallsGraph interface~b64_encode b64_encode proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_string_a->proc~encode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_encode~~CalledByGraph interface~b64_encode b64_encode proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64.","tags":"","loc":"interface/b64_encode.html","title":"b64_encode â€“ FiNeR"},{"text":"public interface b64_encode_up Encode unlimited polymorphic variable to base64. This is an interface for encoding both scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode_up~~CallsGraph interface~b64_encode_up b64_encode_up interface~b64_encode_up->interface~b64_encode_up proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64.","tags":"","loc":"interface/b64_encode_up.html","title":"b64_encode_up â€“ FiNeR"},{"text":"public interface b64_decode Decode numbers (integer and real) from base64. This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both\n scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode ( code = 'AAAAAAAA8D8=' , n = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode~~CallsGraph interface~b64_decode b64_decode proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_decode~~CalledByGraph interface~b64_decode b64_decode proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings.","tags":"","loc":"interface/b64_decode.html","title":"b64_decode â€“ FiNeR"},{"text":"public interface b64_decode_up Decode unlimited polymorphic variable from base64. This is an interface for decoding both scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode_up ( code = 'AAAAAAAA8D8=' , up = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode_up ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , up = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode_up~~CallsGraph interface~b64_decode_up b64_decode_up interface~b64_decode_up->interface~b64_decode_up proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~decode_bits decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64.","tags":"","loc":"interface/b64_decode_up.html","title":"b64_decode_up â€“ FiNeR"},{"text":"private elemental function sadjustl(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. Source Code elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl","tags":"","loc":"proc/sadjustl.html","title":"sadjustl â€“ FiNeR"},{"text":"public pure function sadjustl_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). Called By proc~~sadjustl_character~~CalledByGraph proc~sadjustl_character sadjustl_character interface~adjustl adjustl interface~adjustl->proc~sadjustl_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustl_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustl ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl_character","tags":"","loc":"proc/sadjustl_character.html","title":"sadjustl_character â€“ FiNeR"},{"text":"private elemental function sadjustr(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. Source Code elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr","tags":"","loc":"proc/sadjustr.html","title":"sadjustr â€“ FiNeR"},{"text":"public pure function sadjustr_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). Called By proc~~sadjustr_character~~CalledByGraph proc~sadjustr_character sadjustr_character interface~adjustr adjustr interface~adjustr->proc~sadjustr_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustr_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustr ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr_character","tags":"","loc":"proc/sadjustr_character.html","title":"sadjustr_character â€“ FiNeR"},{"text":"private elemental function scount(self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. Note If ignore_isolated is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those\n occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a\n right companion). Variables Type Visibility Attributes Name Initial logical, public :: ignore_isolated_ Ignore \"isolated\" occurrences, local variable. integer, public :: c1 Counter. integer, public :: c2 Counter. Source Code elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount","tags":"","loc":"proc/scount.html","title":"scount â€“ FiNeR"},{"text":"public elemental function sindex_string_string(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_string_string~~CalledByGraph proc~sindex_string_string sindex_string_string interface~index index interface~index->proc~sindex_string_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_string ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_string","tags":"","loc":"proc/sindex_string_string.html","title":"sindex_string_string â€“ FiNeR"},{"text":"public elemental function sindex_string_character(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_string_character~~CalledByGraph proc~sindex_string_character sindex_string_character interface~index index interface~index->proc~sindex_string_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_character ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_character","tags":"","loc":"proc/sindex_string_character.html","title":"sindex_string_character â€“ FiNeR"},{"text":"public elemental function sindex_character_string(string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_character_string~~CalledByGraph proc~sindex_character_string sindex_character_string interface~index index interface~index->proc~sindex_character_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_character_string ( string_ , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: string_ !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( substring % raw )) then i = index ( string = string_ , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_character_string","tags":"","loc":"proc/sindex_character_string.html","title":"sindex_character_string â€“ FiNeR"},{"text":"public elemental function slen(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. Called By proc~~slen~~CalledByGraph proc~slen slen interface~len len interface~len->proc~slen Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen","tags":"","loc":"proc/slen.html","title":"slen â€“ FiNeR"},{"text":"public elemental function slen_trim(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. Called By proc~~slen_trim~~CalledByGraph proc~slen_trim slen_trim interface~len_trim len_trim interface~len_trim->proc~slen_trim Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim","tags":"","loc":"proc/slen_trim.html","title":"slen_trim â€“ FiNeR"},{"text":"public elemental function srepeat_string_string(self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. Called By proc~~srepeat_string_string~~CalledByGraph proc~srepeat_string_string srepeat_string_string interface~repeat repeat interface~repeat->proc~srepeat_string_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_string_string","tags":"","loc":"proc/srepeat_string_string.html","title":"srepeat_string_string â€“ FiNeR"},{"text":"private elemental function srepeat_character_string(self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. Source Code elemental function srepeat_character_string ( self , rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_character_string","tags":"","loc":"proc/srepeat_character_string.html","title":"srepeat_character_string â€“ FiNeR"},{"text":"public elemental function sscan_string_string(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_string_string~~CalledByGraph proc~sscan_string_string sscan_string_string interface~scan scan interface~scan->proc~sscan_string_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_string ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_string","tags":"","loc":"proc/sscan_string_string.html","title":"sscan_string_string â€“ FiNeR"},{"text":"public elemental function sscan_string_character(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_string_character~~CalledByGraph proc~sscan_string_character sscan_string_character interface~scan scan interface~scan->proc~sscan_string_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_character ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_character","tags":"","loc":"proc/sscan_string_character.html","title":"sscan_string_character â€“ FiNeR"},{"text":"public elemental function sscan_character_string(sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_character_string~~CalledByGraph proc~sscan_character_string sscan_character_string interface~scan scan interface~scan->proc~sscan_character_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_character_string ( sstring , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: sstring !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( set % raw )) then i = scan ( string = sstring , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_character_string","tags":"","loc":"proc/sscan_character_string.html","title":"sscan_character_string â€“ FiNeR"},{"text":"public elemental function strim(self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Called By proc~~strim~~CalledByGraph proc~strim strim interface~trim trim interface~trim->proc~strim Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim","tags":"","loc":"proc/strim.html","title":"strim â€“ FiNeR"},{"text":"private elemental function sverify(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Source Code elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify","tags":"","loc":"proc/sverify.html","title":"sverify â€“ FiNeR"},{"text":"private elemental function basedir(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. Example type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(A)' , astring % basedir () // '' ! print \"/bar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. Source Code elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir","tags":"","loc":"proc/basedir.html","title":"basedir â€“ FiNeR"},{"text":"private elemental function basename(self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. Optionally, the extension is also stripped if provided or the last one if required, e.g. Example type ( string ) :: astring astring = 'bar/foo.tar.bz2' print '(A)' , astring % basename ( extension = '.tar.bz2' ) // '' ! print \"foo\" print '(A)' , astring % basename ( strip_last_extension = . true .) // '' ! print \"foo.tar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename","tags":"","loc":"proc/basename.html","title":"basename â€“ FiNeR"},{"text":"private elemental function camelcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. Note Multiple subsequent separators are collapsed to one occurence. Example ```fortran\n type(string) :: astring\n astring = 'caMeL caSe var'\n print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase","tags":"","loc":"proc/camelcase.html","title":"camelcase â€“ FiNeR"},{"text":"private elemental function capitalize(self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize","tags":"","loc":"proc/capitalize.html","title":"capitalize â€“ FiNeR"},{"text":"private pure function chars(self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. Source Code pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars","tags":"","loc":"proc/chars.html","title":"chars â€“ FiNeR"},{"text":"private elemental function decode(self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. Note Only BASE64 codec is currently available. Example ```fortran\n type(string) :: astring\n astring = 'SG93IGFyZSB5b3U/'\n print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" Calls proc~~decode~~CallsGraph proc~decode decode interface~b64_decode b64_decode proc~decode->interface~b64_decode proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: codec_u Encoding codec in upper case string. Source Code elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode","tags":"","loc":"proc/decode.html","title":"decode â€“ FiNeR"},{"text":"private elemental function encode(self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. Note Only BASE64 codec is currently available. Example ```fortran\n type(string) :: astring\n astring = 'How are you?'\n print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" Calls proc~~encode~~CallsGraph proc~encode encode interface~b64_encode b64_encode proc~encode->interface~b64_encode proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_string_a->proc~encode_bits proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode","tags":"","loc":"proc/encode.html","title":"encode â€“ FiNeR"},{"text":"private elemental function escape(self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: esc_ Character to escape, local variable. integer, public :: c Character counter. Source Code elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape","tags":"","loc":"proc/escape.html","title":"escape â€“ FiNeR"},{"text":"private elemental function extension(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. Variables Type Visibility Attributes Name Initial integer, public :: pos Character position. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension","tags":"","loc":"proc/extension.html","title":"extension â€“ FiNeR"},{"text":"private elemental function fill(self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. Variables Type Visibility Attributes Name Initial logical, public :: right_ Fill on the right instead of left, local variable. character(kind=CK,len=1), public :: filling_char_ Filling character (default \"0\"), local variable. Source Code elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill","tags":"","loc":"proc/fill.html","title":"fill â€“ FiNeR"},{"text":"private elemental function insert_character(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. Variables Type Visibility Attributes Name Initial integer, public :: safepos Safe position from which insert substring. Source Code elemental function insert_character ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_character","tags":"","loc":"proc/insert_character.html","title":"insert_character â€“ FiNeR"},{"text":"private elemental function insert_string(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. Variables Type Visibility Attributes Name Initial integer, public :: safepos Safe position from which insert substring. Source Code elemental function insert_string ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_string","tags":"","loc":"proc/insert_string.html","title":"insert_string â€“ FiNeR"},{"text":"private pure function join_strings(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings","tags":"","loc":"proc/join_strings.html","title":"join_strings â€“ FiNeR"},{"text":"private pure function join_characters(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters","tags":"","loc":"proc/join_characters.html","title":"join_characters â€“ FiNeR"},{"text":"private elemental function lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower","tags":"","loc":"proc/lower.html","title":"lower â€“ FiNeR"},{"text":"private pure function partition(self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: c Character counter. Source Code pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition","tags":"","loc":"proc/partition.html","title":"partition â€“ FiNeR"},{"text":"private elemental function replace(self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: r Counter. Source Code elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace","tags":"","loc":"proc/replace.html","title":"replace â€“ FiNeR"},{"text":"private elemental function reverse(self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. Variables Type Visibility Attributes Name Initial integer, public :: length Length of the string. integer, public :: c Counter. Source Code elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse","tags":"","loc":"proc/reverse.html","title":"reverse â€“ FiNeR"},{"text":"private function search(self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. Optionally, returns the indexes of tag start/end, thus this is not an elemental function. Note The tagged record is searched into self if allocated otherwise into in_string if passed or, eventually, into in_character is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are\n zero. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: raw Raw string into which search the tag. integer, public :: istart_ Starting index of tag inside the string, local variable. integer, public :: iend_ Ending index of tag inside the string, local variable. logical, public :: found Flag for inquiring search result. integer, public :: nested_tags Number of nested tags inside tag. integer, public :: t Counter. Source Code function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search","tags":"","loc":"proc/search.html","title":"search â€“ FiNeR"},{"text":"private pure function slice(self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. Example type ( string ) :: astring !< A string. astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) ! print \"Brown fox Jumps\" Source Code pure function slice ( self , istart , iend ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data sliced. !< !<### Example !< !<```fortran !< type(string) :: astring        !< A string. !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) ! print \"Brown fox Jumps\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slice","tags":"","loc":"proc/slice.html","title":"slice â€“ FiNeR"},{"text":"private elemental function snakecase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase","tags":"","loc":"proc/snakecase.html","title":"snakecase â€“ FiNeR"},{"text":"private elemental function startcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase","tags":"","loc":"proc/startcase.html","title":"startcase â€“ FiNeR"},{"text":"private elemental function strip(self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. Variables Type Visibility Attributes Name Initial integer, public :: c Counter. Source Code elemental function strip ( self , remove_nulls ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip","tags":"","loc":"proc/strip.html","title":"strip â€“ FiNeR"},{"text":"private elemental function swapcase(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase","tags":"","loc":"proc/swapcase.html","title":"swapcase â€“ FiNeR"},{"text":"private elemental function to_integer_I1P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). Source Code elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P","tags":"","loc":"proc/to_integer_i1p.html","title":"to_integer_I1P â€“ FiNeR"},{"text":"private elemental function to_integer_I2P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). Source Code elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P","tags":"","loc":"proc/to_integer_i2p.html","title":"to_integer_I2P â€“ FiNeR"},{"text":"private elemental function to_integer_I4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). Source Code elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P","tags":"","loc":"proc/to_integer_i4p.html","title":"to_integer_I4P â€“ FiNeR"},{"text":"private elemental function to_integer_I8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). Source Code elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P","tags":"","loc":"proc/to_integer_i8p.html","title":"to_integer_I8P â€“ FiNeR"},{"text":"private elemental function to_real_R4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). Source Code elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P","tags":"","loc":"proc/to_real_r4p.html","title":"to_real_R4P â€“ FiNeR"},{"text":"private elemental function to_real_R8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). Source Code elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P","tags":"","loc":"proc/to_real_r8p.html","title":"to_real_R8P â€“ FiNeR"},{"text":"private elemental function to_real_R16P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). Source Code elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P","tags":"","loc":"proc/to_real_r16p.html","title":"to_real_R16P â€“ FiNeR"},{"text":"private elemental function unescape(self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: unesc_ Character to unescape, local variable. integer, public :: c Character counter. Source Code elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unescape double backslashes (or custom escaped character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unescape","tags":"","loc":"proc/unescape.html","title":"unescape â€“ FiNeR"},{"text":"private elemental function unique(self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. Note Eventual multiple trailing white space are not reduced to one occurrence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: substring_ Substring, default value. Source Code elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique","tags":"","loc":"proc/unique.html","title":"unique â€“ FiNeR"},{"text":"private elemental function upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper","tags":"","loc":"proc/upper.html","title":"upper â€“ FiNeR"},{"text":"private elemental function end_with(self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with","tags":"","loc":"proc/end_with.html","title":"end_with â€“ FiNeR"},{"text":"private elemental function is_allocated(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. Source Code elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated","tags":"","loc":"proc/is_allocated.html","title":"is_allocated â€“ FiNeR"},{"text":"private elemental function is_digit(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit","tags":"","loc":"proc/is_digit.html","title":"is_digit â€“ FiNeR"},{"text":"private elemental function is_integer(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. The regular expression is \\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 \\s* [\\+\\-]? \\d+ [eE] \\+? \\d+ \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 F F T F F T T Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer","tags":"","loc":"proc/is_integer.html","title":"is_integer â€“ FiNeR"},{"text":"private elemental function is_lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower","tags":"","loc":"proc/is_lower.html","title":"is_lower â€“ FiNeR"},{"text":"private elemental function is_number(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). Source Code elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number","tags":"","loc":"proc/is_number.html","title":"is_number â€“ FiNeR"},{"text":"private elemental function is_real(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. The regular expression is \\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 S7 S8 \\s* [\\+\\-]? \\d* \\.? \\d* [deDE] [\\+\\-]? \\d* \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 S7 S8 Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. logical, public :: has_leading_digit Check the presence of leading digits. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real","tags":"","loc":"proc/is_real.html","title":"is_real â€“ FiNeR"},{"text":"private elemental function is_upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper","tags":"","loc":"proc/is_upper.html","title":"is_upper â€“ FiNeR"},{"text":"private elemental function start_with(self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with","tags":"","loc":"proc/start_with.html","title":"start_with â€“ FiNeR"},{"text":"private pure function string_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html","title":"string_concat_string â€“ FiNeR"},{"text":"private pure function string_concat_character(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html","title":"string_concat_character â€“ FiNeR"},{"text":"private pure function character_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html","title":"character_concat_string â€“ FiNeR"},{"text":"private elemental function string_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: temporary Temporary concatenated string. Source Code elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html","title":"string_concat_string_string â€“ FiNeR"},{"text":"private elemental function string_concat_character_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. Source Code elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html","title":"string_concat_character_string â€“ FiNeR"},{"text":"private elemental function character_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). Source Code elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html","title":"character_concat_string_string â€“ FiNeR"},{"text":"private elemental function string_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. Source Code elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_string","tags":"","loc":"proc/string_eq_string.html","title":"string_eq_string â€“ FiNeR"},{"text":"private elemental function string_eq_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. Source Code elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_character","tags":"","loc":"proc/string_eq_character.html","title":"string_eq_character â€“ FiNeR"},{"text":"private elemental function character_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. Source Code elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw == lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_eq_string","tags":"","loc":"proc/character_eq_string.html","title":"character_eq_string â€“ FiNeR"},{"text":"private elemental function string_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. Source Code elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_string","tags":"","loc":"proc/string_ne_string.html","title":"string_ne_string â€“ FiNeR"},{"text":"private elemental function string_ne_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. Source Code elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_character","tags":"","loc":"proc/string_ne_character.html","title":"string_ne_character â€“ FiNeR"},{"text":"private elemental function character_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. Source Code elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw /= lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ne_string","tags":"","loc":"proc/character_ne_string.html","title":"character_ne_string â€“ FiNeR"},{"text":"private elemental function string_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. Source Code elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_string","tags":"","loc":"proc/string_lt_string.html","title":"string_lt_string â€“ FiNeR"},{"text":"private elemental function string_lt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. Source Code elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_character","tags":"","loc":"proc/string_lt_character.html","title":"string_lt_character â€“ FiNeR"},{"text":"private elemental function character_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. Source Code elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_lt_string","tags":"","loc":"proc/character_lt_string.html","title":"character_lt_string â€“ FiNeR"},{"text":"private elemental function string_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. Source Code elemental function string_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_string","tags":"","loc":"proc/string_le_string.html","title":"string_le_string â€“ FiNeR"},{"text":"private elemental function string_le_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. Source Code elemental function string_le_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_character","tags":"","loc":"proc/string_le_character.html","title":"string_le_character â€“ FiNeR"},{"text":"private elemental function character_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. Source Code elemental function character_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_le_string","tags":"","loc":"proc/character_le_string.html","title":"character_le_string â€“ FiNeR"},{"text":"private elemental function string_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. Source Code elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_string","tags":"","loc":"proc/string_ge_string.html","title":"string_ge_string â€“ FiNeR"},{"text":"private elemental function string_ge_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. Source Code elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_character","tags":"","loc":"proc/string_ge_character.html","title":"string_ge_character â€“ FiNeR"},{"text":"private elemental function character_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. Source Code elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ge_string","tags":"","loc":"proc/character_ge_string.html","title":"character_ge_string â€“ FiNeR"},{"text":"private elemental function string_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. Source Code elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_string","tags":"","loc":"proc/string_gt_string.html","title":"string_gt_string â€“ FiNeR"},{"text":"private elemental function string_gt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. Source Code elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_character","tags":"","loc":"proc/string_gt_character.html","title":"string_gt_character â€“ FiNeR"},{"text":"private elemental function character_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. Source Code elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_gt_string","tags":"","loc":"proc/character_gt_string.html","title":"character_gt_string â€“ FiNeR"},{"text":"private elemental function replace_one_occurrence(self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: pos Position from which replace old. Source Code elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence","tags":"","loc":"proc/replace_one_occurrence.html","title":"replace_one_occurrence â€“ FiNeR"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~4.html","title":"free â€“ FiNeR"},{"text":"private subroutine read_file(self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. logical, public :: does_exist Check if file exist. Source Code subroutine read_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file","tags":"","loc":"proc/read_file~2.html","title":"read_file â€“ FiNeR"},{"text":"private subroutine read_line(self, unit, form, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. character(kind=CK,len=:), public, allocatable :: line Line storage. character(kind=CK,len=1), public :: ch Character storage. Source Code subroutine read_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_eor !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_line","tags":"","loc":"proc/read_line.html","title":"read_line â€“ FiNeR"},{"text":"private subroutine read_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. The line is read as an ascii stream read until the eor is reached. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. type( string ), public :: lines Lines storage. type( string ), public :: line Line storage. Source Code subroutine read_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines","tags":"","loc":"proc/read_lines~2.html","title":"read_lines â€“ FiNeR"},{"text":"private pure subroutine split(self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: No Number of occurrences of sep. integer, public :: t Character counter. type( string ), public :: temporary Temporary storage. type( string ), public, allocatable :: temp_toks (:,:) Temporary tokens substring. Source Code pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split","tags":"","loc":"proc/split.html","title":"split â€“ FiNeR"},{"text":"private subroutine write_file(self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. Source Code subroutine write_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file","tags":"","loc":"proc/write_file~2.html","title":"write_file â€“ FiNeR"},{"text":"private subroutine write_line(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. Source Code subroutine write_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_line","tags":"","loc":"proc/write_line.html","title":"write_line â€“ FiNeR"},{"text":"private subroutine write_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. This method checks if self contains more than one line (records) and writes them as lines (records). Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: lines (:) Lines. integer, public :: l Counter. Source Code subroutine write_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines","tags":"","loc":"proc/write_lines~2.html","title":"write_lines â€“ FiNeR"},{"text":"private elemental subroutine string_assign_string(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. Source Code elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html","title":"string_assign_string â€“ FiNeR"},{"text":"private elemental subroutine string_assign_character(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. Source Code elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html","title":"string_assign_character â€“ FiNeR"},{"text":"private elemental subroutine string_assign_integer_I1P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i1p~~CallsGraph proc~string_assign_integer_i1p string_assign_integer_I1P interface~str str proc~string_assign_integer_i1p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P","tags":"","loc":"proc/string_assign_integer_i1p.html","title":"string_assign_integer_I1P â€“ FiNeR"},{"text":"private elemental subroutine string_assign_integer_I2P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i2p~~CallsGraph proc~string_assign_integer_i2p string_assign_integer_I2P interface~str str proc~string_assign_integer_i2p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P","tags":"","loc":"proc/string_assign_integer_i2p.html","title":"string_assign_integer_I2P â€“ FiNeR"},{"text":"private elemental subroutine string_assign_integer_I4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i4p~~CallsGraph proc~string_assign_integer_i4p string_assign_integer_I4P interface~str str proc~string_assign_integer_i4p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P","tags":"","loc":"proc/string_assign_integer_i4p.html","title":"string_assign_integer_I4P â€“ FiNeR"},{"text":"private elemental subroutine string_assign_integer_I8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i8p~~CallsGraph proc~string_assign_integer_i8p string_assign_integer_I8P interface~str str proc~string_assign_integer_i8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P","tags":"","loc":"proc/string_assign_integer_i8p.html","title":"string_assign_integer_I8P â€“ FiNeR"},{"text":"private elemental subroutine string_assign_real_R4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r4p~~CallsGraph proc~string_assign_real_r4p string_assign_real_R4P interface~str str proc~string_assign_real_r4p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P","tags":"","loc":"proc/string_assign_real_r4p.html","title":"string_assign_real_R4P â€“ FiNeR"},{"text":"private elemental subroutine string_assign_real_R8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r8p~~CallsGraph proc~string_assign_real_r8p string_assign_real_R8P interface~str str proc~string_assign_real_r8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P","tags":"","loc":"proc/string_assign_real_r8p.html","title":"string_assign_real_R8P â€“ FiNeR"},{"text":"private elemental subroutine string_assign_real_R16P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r16p~~CallsGraph proc~string_assign_real_r16p string_assign_real_R16P interface~str str proc~string_assign_real_r16p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r4p->proc~str_r4p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P","tags":"","loc":"proc/string_assign_real_r16p.html","title":"string_assign_real_R16P â€“ FiNeR"},{"text":"private subroutine read_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Calls proc~~read_formatted~~CallsGraph proc~read_formatted read_formatted proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted->proc~get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. character(kind=CK,len=1), public :: delim String delimiter, if any. character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted","tags":"","loc":"proc/read_formatted.html","title":"read_formatted â€“ FiNeR"},{"text":"private subroutine read_delimited(dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. If the closing delimiter is followed by end of record, then we return end of record. Variables Type Visibility Attributes Name Initial character(kind=CK,len=1), public :: ch A character read. logical, public :: was_delim Indicates that the last character read was a delimiter. Source Code subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the end of record condition to the ! caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_delimited","tags":"","loc":"proc/read_delimited.html","title":"read_delimited â€“ FiNeR"},{"text":"private subroutine read_undelimited_listdirected(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. If input is terminated by end of record, then this procedure returns an end-of-record condition. Calls proc~~read_undelimited_listdirected~~CallsGraph proc~read_undelimited_listdirected read_undelimited_listdirected proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected->proc~get_decimal_mode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: decimal_point True if DECIMAL=POINT in effect. Source Code subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited_listdirected","tags":"","loc":"proc/read_undelimited_listdirected.html","title":"read_undelimited_listdirected â€“ FiNeR"},{"text":"private subroutine read_undelimited(dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the\n file remains at end of record. Variables Type Visibility Attributes Name Initial character(kind=CK,len=1), public :: ch A character read. Source Code subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited","tags":"","loc":"proc/read_undelimited.html","title":"read_undelimited â€“ FiNeR"},{"text":"private subroutine write_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. Source Code subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted","tags":"","loc":"proc/write_formatted.html","title":"write_formatted â€“ FiNeR"},{"text":"private subroutine read_unformatted(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted","tags":"","loc":"proc/read_unformatted.html","title":"read_unformatted â€“ FiNeR"},{"text":"private subroutine write_unformatted(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. Source Code subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted","tags":"","loc":"proc/write_unformatted.html","title":"write_unformatted â€“ FiNeR"},{"text":"private subroutine get_delimiter_mode(unit, delim, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=len=1,CK), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Description Get the DELIM changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of NONE is always returned. Variables Type Visibility Attributes Name Initial character(len=10), public :: delim_buffer Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_delimiter_mode","tags":"","loc":"proc/get_delimiter_mode.html","title":"get_delimiter_mode â€“ FiNeR"},{"text":"private subroutine get_next_non_blank_character_this_record(unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character in the current record. Called By proc~~get_next_non_blank_character_this_record~~CalledByGraph proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character in the current record. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_this_record","tags":"","loc":"proc/get_next_non_blank_character_this_record.html","title":"get_next_non_blank_character_this_record â€“ FiNeR"},{"text":"private subroutine get_next_non_blank_character_any_record(unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character, advancing records if necessary. Calls proc~~get_next_non_blank_character_any_record~~CallsGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_next_non_blank_character_any_record~~CalledByGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character, advancing records if necessary. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_any_record","tags":"","loc":"proc/get_next_non_blank_character_any_record.html","title":"get_next_non_blank_character_any_record â€“ FiNeR"},{"text":"private subroutine get_decimal_mode(unit, decimal_point, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the DECIMAL changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the\n actual value in force at the time of the call to this procedure. Called By proc~~get_decimal_mode~~CalledByGraph proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected read_undelimited_listdirected proc~read_undelimited_listdirected->proc~get_decimal_mode Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=5), public :: decimal_buffer Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_decimal_mode","tags":"","loc":"proc/get_decimal_mode.html","title":"get_decimal_mode â€“ FiNeR"},{"text":"Uses: finer_backend finer_option_t finer_section_t penf stringifor iso_fortran_env module~~finer_file_ini_t~~UsesGraph module~finer_file_ini_t finer_file_ini_t iso_fortran_env iso_fortran_env iso_fortran_env->module~finer_file_ini_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~finer_backend finer_backend module~finer_backend->module~finer_file_ini_t module~finer_option_t finer_option_t module~finer_backend->module~finer_option_t module~finer_section_t finer_section_t module~finer_backend->module~finer_section_t module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~penf penf module~penf->module~finer_file_ini_t module~penf->module~finer_backend module~penf->module~finer_option_t module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_section_t->module~finer_file_ini_t module~stringifor->module~finer_file_ini_t module~stringifor->module~finer_option_t module~stringifor->module~finer_section_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 var panmodulefiner_file_ini_tUsesGraph = svgPanZoom('#modulefiner_file_ini_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. INI file class definition. Used By module~~finer_file_ini_t~~UsedByGraph module~finer_file_ini_t finer_file_ini_t module~finer finer module~finer_file_ini_t->module~finer program~test_driver Test_Driver module~finer->program~test_driver Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: file_ini Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: filename File name integer(kind=I4P), private :: Ns = 0 Number of sections. character(len=1), private :: opt_sep = def_opt_sep Separator character of option name/value. type( section ), private, allocatable :: sections (:) Sections. Type-Bound Procedures generic, public :: add => add_section, add_option, add_a_option Add a section.\n Add an option to a section (scalar).\n Add an option to a section (array). procedure, public, pass(self) :: count_values Count option value(s). generic, public :: del => free_option_of_section, free_section Remove (freeing) an option of a section.\n Remove (freeing) a section. procedure, public, pass(self) :: free Free dynamic memory destroyng file data. generic, public :: free_options => free_options_all, free_options_of_section, free_option_of_section Free all options.\n Free all options of a section.\n Free an option of a section. generic, public :: get => get_option, get_a_option Get option value (scalar).\n Get option value (array). procedure, public, pass(self) :: get_items Get list of couples option name/value. procedure, public, pass(self) :: has_option Inquire the presence of an option. procedure, public, pass(self) :: has_section Inquire the presence of a section. generic, public :: index => index_section, index_option Return the index of a section.\n Return the index of an option. procedure, public, pass(self) :: load Load file data. generic, public :: loop => loop_options_section, loop_options Loop over options of a section.\n Loop over all options. procedure, public, pass(self) :: print => print_file_ini Pretty printing data. procedure, public, pass(self) :: save => save_file_ini Save data. procedure, public, pass(self) :: section => section_file_ini Get section name once provided an index. generic, public :: assignment(=) => assign_file_ini Procedure for section assignment overloading. procedure, private, pass(self) :: add_a_option Add an option to a section (array). procedure, private, pass(self) :: add_option Add an option to a section (scalar). procedure, private, pass(self) :: add_section Add a section. procedure, private, pass(self) :: free_options_all Free all options of all sections. procedure, private, pass(self) :: free_options_of_section Free all options of a section. procedure, private, pass(self) :: free_option_of_section Free an option of a section. procedure, private, pass(self) :: free_section Free a section. procedure, private, pass(self) :: get_a_option Get option value (array). procedure, private, pass(self) :: get_option Get option value (scalar). procedure, private, pass(self) :: index_option Return the index of an option. procedure, private, pass(self) :: index_section Return the index of a section. procedure, private, pass(self) :: loop_options Loop over all options. procedure, private, pass(self) :: loop_options_section Loop over options of a section. procedure, private, pass(self) :: parse Parse file data. procedure, private, pass(lhs) :: assign_file_ini Assignment overloading. Description INI file class. Functions private elemental function count_values (self, delimiter, section_name, option_name) result(Nv) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option into section data. private function has_option (self, option_name, section_name) result(pres) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: option_name Option name. character(len=*), intent(inout), optional :: section_name Section name. Return Value logical Inquiring flag. Description Inquire the presence of (at least one) option with the name passed. private elemental function has_section (self, section_name) result(pres) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: section_name Section name. Return Value logical Inquiring flag. Description Inquire the presence of (at least one) section with the name passed. private pure function section_file_ini (self, section_index) result(sname) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: section_index Section index. Return Value character(len=:),\n  allocatable Section name. Description Get section name once an index (valid) is provided. private elemental function index_option (self, back, section_name, option_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the option (inside a  section) matching the name(s) passed. private elemental function index_section (self, back, section_name) result(ind) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character(len=*), intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the section matching the name passed. private function loop_options_section (self, section_name, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into section. private recursive function loop_options (self, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into all sections. Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Description Free dynamic memory. private pure subroutine get_items (self, items) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: items (:,:) Items, list of couples option name/value for all options [1:No,1:2]. Description Get list of couples option name/value. private subroutine load (self, separator, filename, source, error) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=1), intent(in), optional :: separator Separator of options name/value. character(len=*), intent(in), optional :: filename File name. character(len=*), intent(in), optional :: source File source. integer(kind=I4P), intent(out), optional :: error Error code. Description Get file data from a file or a source string. private subroutine print_file_ini (self, unit, pref, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. private subroutine save_file_ini (self, retain_comments, iostat, iomsg, filename) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. character(len=*), intent(in), optional :: filename File name. Description Save data. private pure subroutine add_a_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. Description Add an option (with array value). private pure subroutine add_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. Description Add an option (with scalar value). private pure subroutine add_section (self, error, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. Description Add a section. private elemental subroutine free_options_all (self) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Description Free all options of all sections. private elemental subroutine free_option_of_section (self, section_name, option_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option  name. Description Free all options of a section. private elemental subroutine free_options_of_section (self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. private elemental subroutine free_section (self, section_name) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: section_name Section name. Description Free all options of a section. private subroutine get_a_option (self, delimiter, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. Description Get option value (array) private subroutine get_option (self, error, section_name, option_name, val) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character(len=*), intent(in) :: section_name Section name. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. Description Get option value (scalar). private subroutine parse (self, source, error) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=*), intent(in) :: source String source. integer(kind=I4P), intent(out), optional :: error Error code. Description Parse file either from the self source data or from a source string. private elemental subroutine assign_file_ini (lhs, rhs) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. Description Assignment between two INI files. public subroutine file_ini_autotest () Arguments None Description Autotest the library functionalities.","tags":"","loc":"module/finer_file_ini_t.html","title":"finer_file_ini_t â€“ FiNeR"},{"text":"Uses: finer_backend penf stringifor module~~finer_option_t~~UsesGraph module~finer_option_t finer_option_t module~penf penf module~penf->module~finer_option_t module~finer_backend finer_backend module~penf->module~finer_backend module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_backend->module~finer_option_t module~stringifor->module~finer_option_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 var panmodulefiner_option_tUsesGraph = svgPanZoom('#modulefiner_option_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Option class definition. Used By module~~finer_option_t~~UsedByGraph module~finer_option_t finer_option_t module~finer_file_ini_t finer_file_ini_t module~finer_option_t->module~finer_file_ini_t module~finer_section_t finer_section_t module~finer_option_t->module~finer_section_t module~finer finer module~finer_file_ini_t->module~finer module~finer_section_t->module~finer_file_ini_t program~test_driver Test_Driver module~finer->program~test_driver Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface option Overload option name with a function returning a new (itiliazed) option instance. private elemental function new_option (option_name, option_values, option_comment) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: option_name Option name. character(len=*), intent(in), optional :: option_values Option values. character(len=*), intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Description Return a new (initiliazed) option instance. Derived Types type, public :: option Components Type Visibility Attributes Name Initial type( string ), private :: oname Option name. type( string ), private :: ovals Option values. type( string ), private :: ocomm Eventual option inline comment. Constructor Overload option name with a function returning a new (itiliazed) option instance. private elemental function new_option (option_name, option_values, option_comment) Return a new (initiliazed) option instance. Type-Bound Procedures procedure, public, pass(self) :: count_values Counting option value(s). procedure, public, pass(self) :: free Free dynamic memory. generic, public :: get => get_option, get_a_option Get option value (scalar).\n Get option value (array). procedure, public, pass(self) :: get_pairs Return option name/values pairs. procedure, public, pass(self) :: name_len Return option name length. procedure, public, pass(self) :: parse Parse option data. procedure, public, pass(self) :: print => print_option Pretty print data. procedure, public, pass(self) :: save => save_option Save data. generic, public :: set => set_option, set_a_option Set option value (scalar).\n Set option value (array). procedure, public, pass(self) :: values_len Return option values length. generic, public :: assignment(=) => assign_option Assignment overloading. generic, public :: operator(==) => option_eq_string, option_eq_character Equal operator overloading. procedure, private, pass(self) :: get_option Get option value (scalar). procedure, private, pass(self) :: get_a_option Get option value (array). procedure, private, pass(self) :: parse_comment Parse option inline comment. procedure, private, pass(self) :: parse_name Parse option name. procedure, private, pass(self) :: parse_value Parse option values. procedure, private, pass(self) :: set_option Set option value (scalar). procedure, private, pass(self) :: set_a_option Set option value (array). procedure, private, pass(lhs) :: assign_option Assignment overloading. procedure, private, pass(lhs) :: option_eq_string Equal to string logical operator. procedure, private, pass(lhs) :: option_eq_character Equal to character logical operator. Description Option data of sections. Functions private elemental function count_values (self, delimiter) result(Nv) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option data. private elemental function name_len (self) result(length) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option name length. Description Return option name length. private elemental function values_len (self) result(length) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option values length. Description Return option values length. private elemental function option_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function option_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function new_option (option_name, option_values, option_comment) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: option_name Option name. character(len=*), intent(in), optional :: option_values Option values. character(len=*), intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Description Return a new (initiliazed) option instance. Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Description Free dynamic memory. private pure subroutine get_pairs (self, pairs) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Description Return option name/values pairs. private elemental subroutine parse (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option data from a source string. private subroutine get_option (self, val, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description for getting option data value (scalar). private subroutine get_a_option (self, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option data values (array). private elemental subroutine parse_comment (self) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Description Parse eventaul option inline comment trimming it out from pure value string. private elemental subroutine parse_name (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option name from a source string. private elemental subroutine parse_value (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Description Parse option value from a source string. private subroutine print_option (self, unit, retain_comments, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. private pure subroutine set_option (self, val) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value. Description Set option data value (scalar). private pure subroutine set_a_option (self, val, delimiter) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Description Set option data value (array). private subroutine save_option (self, unit, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Save data. private elemental subroutine assign_option (lhs, rhs) Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. Description Assignment between two options.","tags":"","loc":"module/finer_option_t.html","title":"finer_option_t â€“ FiNeR"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf penf module~penf_global_parameters_variables->module~penf module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_file_ini_t finer_file_ini_t module~penf->module~finer_file_ini_t module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~finer_backend finer_backend module~penf->module~finer_backend module~befor64 befor64 module~penf->module~befor64 module~finer_section_t finer_section_t module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~finer_option_t finer_option_t module~penf->module~finer_option_t module~penf_stringify->module~penf module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~befor64_pack_data_m->module~befor64 module~finer finer module~finer_file_ini_t->module~finer module~stringifor_string_t->module~stringifor module~finer_backend->module~finer_file_ini_t module~finer_backend->module~finer_section_t module~finer_backend->module~finer_option_t module~finer_backend->module~finer module~befor64->module~stringifor_string_t module~finer_section_t->module~finer_file_ini_t module~stringifor->module~finer_file_ini_t module~stringifor->module~finer_section_t module~stringifor->module~finer_option_t module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t program~test_driver Test_Driver module~finer->program~test_driver var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables â€“ FiNeR"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF bit/byte size functions. Used By module~~penf_b_size~~UsedByGraph module~penf_b_size penf_b_size module~penf penf module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_file_ini_t finer_file_ini_t module~penf->module~finer_file_ini_t module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~finer_backend finer_backend module~penf->module~finer_backend module~befor64 befor64 module~penf->module~befor64 module~finer_section_t finer_section_t module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~finer_option_t finer_option_t module~penf->module~finer_option_t module~penf_stringify->module~penf module~befor64_pack_data_m->module~befor64 module~finer finer module~finer_file_ini_t->module~finer module~stringifor_string_t->module~stringifor module~finer_backend->module~finer_file_ini_t module~finer_backend->module~finer_section_t module~finer_backend->module~finer_option_t module~finer_backend->module~finer module~befor64->module~stringifor_string_t module~finer_section_t->module~finer_file_ini_t module~stringifor->module~finer_file_ini_t module~stringifor->module~finer_section_t module~stringifor->module~finer_option_t module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t program~test_driver Test_Driver module~finer->program~test_driver var panmodulepenf_b_sizeUsedByGraph = svgPanZoom('#modulepenf_b_sizeUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Functions private elemental function bit_size_R16P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R16P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size â€“ FiNeR"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_b_size->module~penf_stringify Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf penf module~penf_stringify->module~penf module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_file_ini_t finer_file_ini_t module~penf->module~finer_file_ini_t module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~finer_backend finer_backend module~penf->module~finer_backend module~befor64 befor64 module~penf->module~befor64 module~finer_section_t finer_section_t module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~finer_option_t finer_option_t module~penf->module~finer_option_t module~befor64_pack_data_m->module~befor64 module~finer finer module~finer_file_ini_t->module~finer module~stringifor_string_t->module~stringifor module~finer_backend->module~finer_file_ini_t module~finer_backend->module~finer_section_t module~finer_backend->module~finer_option_t module~finer_backend->module~finer module~befor64->module~stringifor_string_t module~finer_section_t->module~finer_file_ini_t module~stringifor->module~finer_file_ini_t module~stringifor->module~finer_section_t module~stringifor->module~finer_option_t module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t program~test_driver Test_Driver module~finer->program~test_driver var panmodulepenf_stringifyUsedByGraph = svgPanZoom('#modulepenf_stringifyUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Functions private elemental function strf_R16P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_R16P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R16P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private function ctor_R16P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. private elemental function bstr_R16P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bctor_R16P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify â€“ FiNeR"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Portability Environment for Fortran poor people. PENF PENF, Portability Environment for Fortran poor people A KISS library for exploiting codes portability for modern (2003+) Fortran projects. PENF is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; PENF provides many number-to-string and viceversa facilities; PENF is Fortran 2003+ standard compliant; PENF is a Free, Open Source Project. Table of Contents What is PENF? Main features Copyrights Documentation A Taste of PENF Issues Compiler Support What is PENF? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. PENF module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights PENF is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to PENF is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the PENF documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of PENF To be written. Go to Top Used By module~~penf~~UsedByGraph module~penf penf module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_file_ini_t finer_file_ini_t module~penf->module~finer_file_ini_t module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~finer_backend finer_backend module~penf->module~finer_backend module~befor64 befor64 module~penf->module~befor64 module~finer_section_t finer_section_t module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~finer_option_t finer_option_t module~penf->module~finer_option_t module~befor64_pack_data_m->module~befor64 module~finer finer module~finer_file_ini_t->module~finer module~stringifor_string_t->module~stringifor module~finer_backend->module~finer_file_ini_t module~finer_backend->module~finer_section_t module~finer_backend->module~finer_option_t module~finer_backend->module~finer module~befor64->module~stringifor_string_t module~finer_section_t->module~finer_file_ini_t module~stringifor->module~finer_file_ini_t module~stringifor->module~finer_section_t module~stringifor->module~finer_option_t module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t program~test_driver Test_Driver module~finer->program~test_driver var panmodulepenfUsedByGraph = svgPanZoom('#modulepenfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Functions private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Subroutines public subroutine check_endian () Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. public subroutine penf_init () Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data.","tags":"","loc":"module/penf.html","title":"penf â€“ FiNeR"},{"text":"Uses: penf module~~finer_backend~~UsesGraph module~finer_backend finer_backend module~penf penf module~penf->module~finer_backend module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FiNeR backends: globals definition. Used By module~~finer_backend~~UsedByGraph module~finer_backend finer_backend module~finer_file_ini_t finer_file_ini_t module~finer_backend->module~finer_file_ini_t module~finer finer module~finer_backend->module~finer module~finer_option_t finer_option_t module~finer_backend->module~finer_option_t module~finer_section_t finer_section_t module~finer_backend->module~finer_section_t module~finer_file_ini_t->module~finer program~test_driver Test_Driver module~finer->program~test_driver module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~finer_section_t->module~finer_file_ini_t Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: err_option_name = 1 Error flag for trapping errors in option name. integer(kind=I4P), public, parameter :: err_option_vals = 2 Error flag for trapping errors in option values. integer(kind=I4P), public, parameter :: err_option = 3 Error flag for trapping errors in option. integer(kind=I4P), public, parameter :: err_section_name = 4 Error flag for trapping errors in section name. integer(kind=I4P), public, parameter :: err_section_options = 5 Error flag for trapping errors in section options. integer(kind=I4P), public, parameter :: err_section = 6 Error flag for trapping errors in section. integer(kind=I4P), public, parameter :: err_source_missing = 7 Error flag for trapping errors in file when source is missing. character(len=1), public, parameter :: def_opt_sep = '=' Default separator of option name/value. character(len=*), public, parameter :: comments = \"!;#\" Characters used for defining a comment line. character(len=1), public, parameter :: inline_comment = ';' Inline comment delimiter.","tags":"","loc":"module/finer_backend.html","title":"finer_backend â€“ FiNeR"},{"text":"Uses: penf stringifor_string_t module~~stringifor~~UsesGraph module~stringifor stringifor module~penf penf module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor_string_t->module~stringifor module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 var panmodulestringiforUsesGraph = svgPanZoom('#modulestringiforUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor, Strings Fortran, yet another stringify Fortran module Used By module~~stringifor~~UsedByGraph module~stringifor stringifor module~finer_section_t finer_section_t module~stringifor->module~finer_section_t module~finer_option_t finer_option_t module~stringifor->module~finer_option_t module~finer_file_ini_t finer_file_ini_t module~stringifor->module~finer_file_ini_t module~finer_section_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~finer_option_t->module~finer_file_ini_t module~finer finer module~finer_file_ini_t->module~finer program~test_driver Test_Driver module~finer->program~test_driver Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface adjustl Builtin adjustl overloading. public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). public interface adjustr Builtin adjustr overloading. public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). public interface count Builtin count overloading. private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. public interface index Builtin index overloading. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public interface len Builtin len overloading. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. public interface len_trim Builtin len_trim overloading. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. public interface repeat Builtin repeat overloading. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. public interface scan Builtin scan overloading. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public interface trim Builtin trim overloading. public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Functions private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. Subroutines public subroutine read_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. public subroutine read_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read lines (records) from a connected-formatted unit. public subroutine write_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected-formatted unit. public subroutine write_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file.","tags":"","loc":"module/stringifor.html","title":"stringifor â€“ FiNeR"},{"text":"Uses: finer_backend finer_option_t penf stringifor module~~finer_section_t~~UsesGraph module~finer_section_t finer_section_t module~penf penf module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~finer_backend finer_backend module~penf->module~finer_backend module~finer_option_t finer_option_t module~penf->module~finer_option_t module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor->module~finer_section_t module~stringifor->module~finer_option_t module~finer_backend->module~finer_section_t module~finer_backend->module~finer_option_t module~finer_option_t->module~finer_section_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 var panmodulefiner_section_tUsesGraph = svgPanZoom('#modulefiner_section_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Section class definition. Used By module~~finer_section_t~~UsedByGraph module~finer_section_t finer_section_t module~finer_file_ini_t finer_file_ini_t module~finer_section_t->module~finer_file_ini_t module~finer finer module~finer_file_ini_t->module~finer program~test_driver Test_Driver module~finer->program~test_driver Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface section Overload section name with a function returning a new (itiliazed) section instance. private elemental function new_section (section_name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Description Return a new (initiliazed) section instance. Derived Types type, public :: section Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: sname Section name. type( option ), private, allocatable :: options (:) Section options. Constructor Overload section name with a function returning a new (itiliazed) section instance. private elemental function new_section (section_name) Return a new (initiliazed) section instance. Type-Bound Procedures generic, public :: add => add_option, add_a_option Add an option (scalar).\n Add an option (array). procedure, public, pass(self) :: count_values Count option value(s). procedure, public, pass(self) :: free Free dynamic memory. procedure, public, pass(self) :: free_options Free all options. procedure, public, pass(self) :: free_option Free a option. generic, public :: get => get_option, get_a_option Get option value (scalar).\n Get option value (array). procedure, public, pass(self) :: has_options Inquire if section has options. procedure, public, pass(self) :: index => index_option Return the index of an option. procedure, public, pass(self) :: loop Loop over options. procedure, public, pass(self) :: max_chars_len Return max len of option-name/values on all options. procedure, public, pass(self) :: name Return section name. procedure, public, pass(self) :: options_number Return the options number. procedure, public, pass(self) :: option_pairs Return an option pairs. procedure, public, pass(self) :: parse Parse section data. procedure, public, pass(self) :: print => print_section Pretty print data. generic, public :: set => set_option, set_a_option Set option value (scalar).\n Set option value (array). procedure, public, pass(self) :: save => save_section Save data. generic, public :: assignment(=) => assign_section Assignment overloading. generic, public :: operator(==) => section_eq_string, section_eq_character Equal operator overloading. procedure, private, pass(self) :: add_option Add an option (scalar). procedure, private, pass(self) :: add_a_option Add an option (array). procedure, private, pass(self) :: get_option Get option value (scalar). procedure, private, pass(self) :: get_a_option Get option value (array). procedure, private, pass(self) :: parse_name Get section name. procedure, private, pass(self) :: parse_options Get section options. procedure, private, pass(self) :: set_option Set option value (scalar). procedure, private, pass(self) :: set_a_option Set option value (array). procedure, private, pass(lhs) :: assign_section Assignment overloading. procedure, private, pass(lhs) :: section_eq_string Equal to string logical operator. procedure, private, pass(lhs) :: section_eq_character Equal to character logical operator. Description Section data of file INI. Functions private elemental function count_values (self, option_name, delimiter) result(Nv) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Description Get the number of values of option into section data. private elemental function has_options (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value logical Inquire result. Description Inquire is section has options (at least one). private elemental function index_option (self, option_name, back) result(ind) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. Return Value integer(kind=I4P) Index of searched section. Description Return the index of the option matching the name passed. private function loop (self, option_pairs) result(again) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Description Loop returning option name/value defined into section. private elemental function max_chars_len (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer Inquire result. Description Return the maximum number of characters between option-name/option-values on all options. private pure function name (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value character(len=len(self%sname)) Section data. Description Return section name. private elemental function options_number (self) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer Options number. Description Return the options number. private elemental function section_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function section_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function new_section (section_name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Description Return a new (initiliazed) section instance. Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Description Free dynamic memory. private elemental subroutine free_options (self) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Description Free all options. private elemental subroutine free_option (self, option_name) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. Description Free an option. private pure subroutine option_pairs (self, option_index, pairs) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Option data. integer, intent(in) :: option_index Option index. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Description Return an option pairs. private elemental subroutine parse (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Gett section data from a source string. private subroutine print_section (self, unit, retain_comments, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print data with a pretty format. private subroutine save_section (self, unit, retain_comments, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Save data. private pure subroutine add_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with scalar value). private pure subroutine add_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Add an option (with array value). private subroutine get_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Get option value (scalar). private subroutine get_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Procedure for getting option value (array). private elemental subroutine parse_name (self, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Get section name from a source string. private elemental subroutine parse_options (self, sep, source, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: sep Separator of option name/value. character(len=*), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Description Get section options from a source string. private pure subroutine set_option (self, option_name, val, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (scalar). private pure subroutine set_a_option (self, option_name, val, delimiter, error) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character(len=*), intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character(len=*), intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Description Set option value (array). private elemental subroutine assign_section (lhs, rhs) Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. Description Assignment between two sections.","tags":"","loc":"module/finer_section_t.html","title":"finer_section_t â€“ FiNeR"},{"text":"Uses: penf module~~befor64_pack_data_m~~UsesGraph module~befor64_pack_data_m befor64_pack_data_m module~penf penf module~penf->module~befor64_pack_data_m module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor64_pack_data_mUsesGraph = svgPanZoom('#modulebefor64_pack_data_mUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. KISS library for packing heterogeneous data into single (homogeneous) packed one. Used By module~~befor64_pack_data_m~~UsedByGraph module~befor64_pack_data_m befor64_pack_data_m module~befor64 befor64 module~befor64_pack_data_m->module~befor64 module~stringifor_string_t stringifor_string_t module~befor64->module~stringifor_string_t module~stringifor stringifor module~stringifor_string_t->module~stringifor module~finer_section_t finer_section_t module~stringifor->module~finer_section_t module~finer_option_t finer_option_t module~stringifor->module~finer_option_t module~finer_file_ini_t finer_file_ini_t module~stringifor->module~finer_file_ini_t module~finer_section_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~finer_option_t->module~finer_file_ini_t module~finer finer module~finer_file_ini_t->module~finer program~test_driver Test_Driver module~finer->program~test_driver var panmodulebefor64_pack_data_mUsedByGraph = svgPanZoom('#modulebefor64_pack_data_mUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface pack_data Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Subroutines private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"module/befor64_pack_data_m.html","title":"befor64_pack_data_m â€“ FiNeR"},{"text":"Uses: penf befor64_pack_data_m module~~befor64~~UsesGraph module~befor64 befor64 module~penf penf module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64_pack_data_m->module~befor64 module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor64UsesGraph = svgPanZoom('#modulebefor64UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. BeFoR64, Base64 encoding/decoding library for FoRtran poor people. BeFoR64 BeFoR64, Base64 encoding/decoding library for FoRtran poor people BeFoR64 is a pure Fortran (KISS) library for base64 encoding/decoding for modern (2003+) Fortran projects; BeFoR64 is Fortran 2003+ standard compliant; BeFoR64 is a Free, Open Source Project. Table of Contents What is BeFoR64? Main features Copyrights Documentation A Taste of BeFoR64 Issues Compiler Support -brightgreen.svg) -brightgreen.svg) What is BeFoR64? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, BeFoR64 provides an easy to use module library for encoding and decoding Fortran types (binary internal representation) in ascii- base64 -encoded string. Go to Top Main features User-friendly methods for encoding/decoding in base64: encode real/integer scalar variables; decode real/integer scalar variables; encode real/integer array variables; decode real/integer array variables; encode character scalar variables; decode character scalar variables; encode character array variables; decode character array variables; encode unlimited polymorphic scalar variables; decode unlimited polymorphic scalar variables; encode unlimited polymorphic array variables; decode unlimited polymorphic array variables; user-friendly methods for packing heterogeneous data: pack integer/integer (different kinds) scalars; pack integer/integer (different kinds) arrays; pack real/real (different kinds) scalars; pack real/real (different kinds) arrays; pack integer/real scalars; pack integer/real arrays; errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights BeFoR64 is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to BeFoR64 is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the BeFoR64 documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of BeFoR64 Let us assume our goal is encoding a binary integer. It is as simple as use befor64 ... character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) print \"(A)\" , code64 But you are not limited to a simple integer scalar, you can encode real, integer, characters scalar or arrays, and by means of the auxiliary Lib_Pack library also mixed types. See the wiki . Go to Top Used By module~~befor64~~UsedByGraph module~befor64 befor64 module~stringifor_string_t stringifor_string_t module~befor64->module~stringifor_string_t module~stringifor stringifor module~stringifor_string_t->module~stringifor module~finer_section_t finer_section_t module~stringifor->module~finer_section_t module~finer_option_t finer_option_t module~stringifor->module~finer_option_t module~finer_file_ini_t finer_file_ini_t module~stringifor->module~finer_file_ini_t module~finer_section_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~finer_option_t->module~finer_file_ini_t module~finer finer module~finer_file_ini_t->module~finer program~test_driver Test_Driver module~finer->program~test_driver var panmodulebefor64UsedByGraph = svgPanZoom('#modulebefor64UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_b64_initialized = .false. Flag for checking the initialization of the library. character(len=64), private :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" Base64 alphabet. Interfaces public interface b64_encode Encode numbers (integer and real) to base64. private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. public interface b64_encode_up Encode unlimited polymorphic variable to base64. public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public interface b64_decode Decode numbers (integer and real) from base64. private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public interface b64_decode_up Decode unlimited polymorphic variable from base64. public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Subroutines public subroutine b64_init () Arguments None Description Initialize the BeFoR64 library. private pure subroutine encode_bits (bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). private pure subroutine decode_bits (code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. public subroutine b64_encode_up (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public subroutine b64_decode_up (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. private pure subroutine b64_encode_R16 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_R16_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. private elemental subroutine b64_decode_R16 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_R16_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public subroutine autotest () Arguments None Description Procedure for autotesting the library functionalities.","tags":"","loc":"module/befor64.html","title":"befor64 â€“ FiNeR"},{"text":"Uses: finer_backend finer_file_ini_t module~~finer~~UsesGraph module~finer finer module~finer_file_ini_t finer_file_ini_t module~finer_file_ini_t->module~finer module~finer_backend finer_backend module~finer_backend->module~finer module~finer_backend->module~finer_file_ini_t module~finer_option_t finer_option_t module~finer_backend->module~finer_option_t module~finer_section_t finer_section_t module~finer_backend->module~finer_section_t iso_fortran_env iso_fortran_env iso_fortran_env->module~finer_file_ini_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~penf penf module~penf->module~finer_file_ini_t module~penf->module~finer_backend module~penf->module~finer_option_t module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_section_t->module~finer_file_ini_t module~stringifor->module~finer_file_ini_t module~stringifor->module~finer_option_t module~stringifor->module~finer_section_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 var panmodulefinerUsesGraph = svgPanZoom('#modulefinerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FiNeR, Fortran INI ParseR and generator. Used By module~~finer~~UsedByGraph module~finer finer program~test_driver Test_Driver module~finer->program~test_driver Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/finer.html","title":"finer â€“ FiNeR"},{"text":"Uses: befor64 penf module~~stringifor_string_t~~UsesGraph module~stringifor_string_t stringifor_string_t module~penf penf module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64->module~stringifor_string_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~befor64_pack_data_m->module~befor64 var panmodulestringifor_string_tUsesGraph = svgPanZoom('#modulestringifor_string_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor, definition of string type. Used By module~~stringifor_string_t~~UsedByGraph module~stringifor_string_t stringifor_string_t module~stringifor stringifor module~stringifor_string_t->module~stringifor module~finer_section_t finer_section_t module~stringifor->module~finer_section_t module~finer_option_t finer_option_t module~stringifor->module~finer_option_t module~finer_file_ini_t finer_file_ini_t module~stringifor->module~finer_file_ini_t module~finer_section_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~finer_option_t->module~finer_file_ini_t module~finer finer module~finer_file_ini_t->module~finer program~test_driver Test_Driver module~finer->program~test_driver var panmodulestringifor_string_tUsedByGraph = svgPanZoom('#modulestringifor_string_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Default character kind. character(kind=CK,len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(kind=CK,len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(kind=CK,len=1), private, parameter :: SPACE = ' ' Space character. character(kind=CK,len=1), private, parameter :: TAB = achar(9) Tab character. character(kind=CK,len=1), private, parameter :: UIX_DIR_SEP = char(47) Unix/Linux directories separator (/). character(kind=CK,len=1), private, parameter :: BACKSLASH = char(92) Backslash character. Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. procedure, public, pass(self) :: count => scount Count replacement. generic, public :: index => sindex_string_string, sindex_string_character Index replacement. procedure, public, pass(self) :: len => slen Len replacement. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. generic, public :: repeat => srepeat_string_string, srepeat_character_string Repeat replacement. generic, public :: scan => sscan_string_string, sscan_string_character Scan replacement. procedure, public, pass(self) :: trim => strim Trim replacement. procedure, public, pass(self) :: verify => sverify Verify replacement. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. procedure, public, pass(self) :: decode Decode string. procedure, public, pass(self) :: encode Encode string. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. generic, public :: insert => insert_string, insert_character Insert substring into string at a specified position. generic, public :: join => join_strings, join_characters Return a string that is a join of an array of strings or characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file Read a file a single string stream. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. procedure, public, pass(self) :: slice Return the raw characters data sliced. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P, to_integer_I2P, to_integer_I4P, to_integer_I8P, to_real_R4P, to_real_R8P Cast string to number. procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. procedure, public, pass(self) :: write_file Write a single string stream into file. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string, string_assign_character, string_assign_integer_I1P, string_assign_integer_I2P, string_assign_integer_I4P, string_assign_integer_I8P, string_assign_real_R4P, string_assign_real_R8P Assignment operator overloading. generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string Concatenation operator (string output) overloading. generic, public :: operator(==) => string_eq_string, string_eq_character, character_eq_string Equal operator overloading. generic, public :: operator(/=) => string_ne_string, string_ne_character, character_ne_string Not equal operator overloading. generic, public :: operator(<) => string_lt_string, string_lt_character, character_lt_string Lower than operator overloading. generic, public :: operator(<=) => string_le_string, string_le_character, character_le_string Lower equal than operator overloading. generic, public :: operator(>=) => string_ge_string, string_ge_character, character_ge_string Greater equal than operator overloading. generic, public :: operator(>) => string_gt_string, string_gt_character, character_gt_string Greater than operator overloading. generic, public :: read(formatted) => read_formatted Formatted input. generic, public :: write(formatted) => write_formatted Formatted output. generic, public :: read(unformatted) => read_unformatted Unformatted input. generic, public :: write(unformatted) => write_unformatted Unformatted output. procedure, private, pass(self) :: sindex_string_string Index replacement. procedure, private, pass(self) :: sindex_string_character Index replacement. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. procedure, private, pass(self) :: srepeat_character_string Repeat replacement. procedure, private, pass(self) :: sscan_string_string Scan replacement. procedure, private, pass(self) :: sscan_string_character Scan replacement. procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings Return join string of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. procedure, private, pass(self) :: to_integer_I2P Cast string to integer. procedure, private, pass(self) :: to_integer_I4P Cast string to integer. procedure, private, pass(self) :: to_integer_I8P Cast string to integer. procedure, private, pass(self) :: to_real_R4P Cast string to real. procedure, private, pass(self) :: to_real_R8P Cast string to real. procedure, private, pass(self) :: to_real_R16P Cast string to real. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted Formatted input. procedure, private, pass(dtv) :: read_delimited Read a delimited input. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. procedure, private, pass(dtv) :: write_formatted Formatted output. procedure, private, pass(dtv) :: read_unformatted Unformatted input. procedure, private, pass(dtv) :: write_unformatted Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. Description OOP designed string class. Functions private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. private elemental function decode (self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. private elemental function encode (self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. private pure function slice (self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. private elemental function strip (self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. private subroutine read_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. private subroutine read_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. private subroutine read_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. private subroutine write_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. private subroutine write_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. private subroutine write_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. private subroutine get_delimiter_mode (unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=len=1,CK), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Description Get the DELIM changeable connection mode for the given unit. private subroutine get_next_non_blank_character_this_record (unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character in the current record. private subroutine get_next_non_blank_character_any_record (unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character, advancing records if necessary. private subroutine get_decimal_mode (unit, decimal_point, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the DECIMAL changeable connection mode for the given unit.","tags":"","loc":"module/stringifor_string_t.html","title":"stringifor_string_t â€“ FiNeR"},{"text":"Uses: finer program~~test_driver~~UsesGraph program~test_driver Test_Driver module~finer finer module~finer->program~test_driver module~finer_file_ini_t finer_file_ini_t module~finer_file_ini_t->module~finer module~finer_backend finer_backend module~finer_backend->module~finer module~finer_backend->module~finer_file_ini_t module~finer_option_t finer_option_t module~finer_backend->module~finer_option_t module~finer_section_t finer_section_t module~finer_backend->module~finer_section_t iso_fortran_env iso_fortran_env iso_fortran_env->module~finer_file_ini_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~finer_option_t->module~finer_file_ini_t module~finer_option_t->module~finer_section_t module~penf penf module~penf->module~finer_file_ini_t module~penf->module~finer_backend module~penf->module~finer_option_t module~penf->module~finer_section_t module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~finer_section_t->module~finer_file_ini_t module~stringifor->module~finer_file_ini_t module~stringifor->module~finer_option_t module~stringifor->module~finer_section_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 var panprogramtest_driverUsesGraph = svgPanZoom('#programtest_driverUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Testing program for FiNeR, File INI Parser library for FoRtran poor men Usage ./Test_Driver Calls program~~test_driver~~CallsGraph program~test_driver Test_Driver proc~file_ini_autotest file_ini_autotest program~test_driver->proc~file_ini_autotest Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for FiNeR, File INI Parser library for FoRtran poor men !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- use finer , only : file_ini_autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Testing FiNeR' call file_ini_autotest stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"program/test_driver.html","title":"Test_Driver â€“ FiNeR"}]}