var tipuesearch = {"pages":[{"title":" FiNeR ","text":"FiNeR FiNeR FiNeR, Fortran INI ParseR and generator for FoRtraners FiNeR is a pure Fortran (KISS) library for IO of INI (config) files for modern (2003+) Fortran projects; FiNeR is Fortran 2003+ standard compliant; FiNeR is OOP designed; FiNeR is TDD designed; FiNeR is a Free, Open Source Project. Issues Compiler Support What is FiNeR? | Main features | Copyrights | Documentation | A Taste of FiNeR What is FiNeR? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, FiNeR provides an easy to use module library for input (parsing) and output (generating) INI (config) files. Go to Top Main features [X] User-friendly methods for IO INI files: [x] parsing files: [x] automatic parsing of all sections (whose number is auto-detected); [x] automatic parsing of all options of each section (whose number is auto-detected); [x] unlimited polymorphic option-values extraction; [x] generating files: [x] user-friendly add/remove sections/options; [x] unlimited polymorphic option-values setting; [x] introspection: [x] self-consistency checks; [x] pretty-printings; [x] loop over options; [x] inquiring the presence of sections/options by name; [ ] errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights FiNeR is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FiNeR is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FiNeR documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FiNeR Let us assume our goal is to parse a config file. It is as simple as use finer ... type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: source ! Testing string. real ( R4P ), allocatable :: array (:) ! Array option. integer ( I4P ) :: error ! Error code. ... source = '[section-1]' // new_line ( 'A' ) // & 'option-1 = one' // new_line ( 'A' ) // & 'option-2 = 2.' // new_line ( 'A' ) // & '           3.' // new_line ( 'A' ) // & 'option-3 = bar' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 = foo' call fini % load ( source = source ) allocate ( array ( 1 : fini % count_values ( section = 'section-1' , option = 'option-2' ))) call fini % get ( section = 'section-1' , option = 'option-2' , val = array , error = error ) if ( error == 0 ) then print * , array else ! errors occur... endif And what about the generation of an INI file? It is simple as parsing an old one: use finer ... type ( file_ini ) :: fini !< INI file handler. ... call fini % add ( section = 'sec-foo' ) call fini % add ( section = 'sec-foo' , option = 'bar' , val =- 3 2.1_R8P ) call fini % add ( section = 'sec-foo' , option = 'baz' , val = ' hello FiNeR! ' ) call fini % add ( section = 'sec-foo' , option = 'array' , val = [ 1 , 2 , 3 , 4 ]) call fini % add ( section = 'sec-bar' ) call fini % add ( section = 'sec-bar' , option = 'bools' , val = [. true .,. false .,. false .]) call fini % save ( filename = 'foo.ini' ) A file named foo.ini is created. It contains something like: [sec-foo] bar = -0.321000000000000E+002 baz = hello FiNeR! array = +1 +2 +3 +4 [sec-bar] bools = T F F Go to Top Developer Info Stefano Zaghi","tags":"home","loc":"index.html"},{"title":"option – FiNeR ","text":"type, public :: option Option data of sections. Inherits type~~option~~InheritsGraph type~option option string string type~option->string oname, ovals, ocomm Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~option~~InheritedByGraph type~option option type~section section type~section->type~option options type~file_ini file_ini type~file_ini->type~section sections Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ocomm oname ovals Constructor option Type-Bound Procedures assign_option assignment(=) count_values free get get_a_option get_option get_pairs name_len operator(==) option_eq_character option_eq_string parse parse_comment parse_name parse_value print save set set_a_option set_option values_len Source Code option Components Type Visibility Attributes Name Initial type(string), private :: ocomm Eventual option inline comment. type(string), private :: oname Option name. type(string), private :: ovals Option values. Constructor public interface option Overload option name with a function returning a new (initiliazed) option instance. private elemental function new_option (option_name, option_values, option_comment) Return a new (initiliazed) option instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: option_name Option name. character, intent(in), optional :: option_values Option values. character, intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Type-Bound Procedures procedure, private, pass(lhs) :: assign_option Assignment overloading. private elemental subroutine assign_option (lhs, rhs) Assignment between two options. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. generic, public :: assignment(=) => assign_option Assignment overloading. private elemental subroutine assign_option (lhs, rhs) Assignment between two options. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. procedure, public, pass(self) :: count_values Counting option value(s). private elemental function count_values (self, delimiter) result(Nv) Get the number of values of option data. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character, intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. generic, public :: get => get_option , get_a_option Get option value (scalar).\nGet option value (array). private subroutine get_option (self, val, error) for getting option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. private subroutine get_a_option (self, val, delimiter, error) Get option data values (array). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: get_a_option Get option value (array). private subroutine get_a_option (self, val, delimiter, error) Get option data values (array). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: get_option Get option value (scalar). private subroutine get_option (self, val, error) for getting option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. procedure, public, pass(self) :: get_pairs Return option name/values pairs. private pure subroutine get_pairs (self, pairs) Return option name/values pairs. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. procedure, public, pass(self) :: name_len Return option name length. private elemental function name_len (self) result(length) Return option name length. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option name length. generic, public :: operator(==) => option_eq_string , option_eq_character Equal operator overloading. private elemental function option_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function option_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: option_eq_character Equal to character logical operator. private elemental function option_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: option_eq_string Equal to string logical operator. private elemental function option_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, public, pass(self) :: parse Parse option data. private elemental subroutine parse (self, sep, source, error) Parse option data from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. procedure, private, pass(self) :: parse_comment Parse option inline comment. private elemental subroutine parse_comment (self) Parse option inline comment trimming it out from pure value string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. procedure, private, pass(self) :: parse_name Parse option name. private elemental subroutine parse_name (self, sep, source, error) Parse option name from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. procedure, private, pass(self) :: parse_value Parse option values. private elemental subroutine parse_value (self, sep, source, error) Parse option value from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. procedure, public, pass(self) :: print => print_option Pretty print data. private subroutine print_option (self, unit, retain_comments, pref, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. procedure, public, pass(self) :: save => save_option Save data. private subroutine save_option (self, unit, retain_comments, iostat, iomsg) Save data. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. generic, public :: set => set_option , set_a_option Set option value (scalar).\nSet option value (array). private pure subroutine set_option (self, val) Set option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value. private pure subroutine set_a_option (self, val, delimiter) Set option data value (array). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. procedure, private, pass(self) :: set_a_option Set option value (array). private pure subroutine set_a_option (self, val, delimiter) Set option data value (array). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. procedure, private, pass(self) :: set_option Set option value (scalar). private pure subroutine set_option (self, val) Set option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value. procedure, public, pass(self) :: values_len Return option values length. private elemental function values_len (self) result(length) Return option values length. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option values length. Source Code type :: option !< Option data of sections. private type ( string ) :: oname !< Option name. type ( string ) :: ovals !< Option values. type ( string ) :: ocomm !< Eventual option inline comment. contains ! public methods procedure , pass ( self ) :: count_values !< Counting option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_pairs !< Return option name/values pairs. procedure , pass ( self ) :: name_len !< Return option name length. procedure , pass ( self ) :: parse !< Parse option data. procedure , pass ( self ) :: print => print_option !< Pretty print data. procedure , pass ( self ) :: save => save_option !< Save data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: values_len !< Return option values length. ! operators overloading generic :: assignment ( = ) => assign_option !< Assignment overloading. generic :: operator ( == ) => option_eq_string , & option_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_comment !< Parse option inline comment. procedure , private , pass ( self ) :: parse_name !< Parse option name. procedure , private , pass ( self ) :: parse_value !< Parse option values. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_option !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: option_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: option_eq_character !< Equal to character logical operator. endtype option","tags":"","loc":"type/option.html"},{"title":"file_ini – FiNeR ","text":"type, public :: file_ini INI file class. Inherits type~~file_ini~~InheritsGraph type~file_ini file_ini type~section section type~file_ini->type~section sections type~option option type~section->type~option options string string type~option->string oname, ovals, ocomm Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Ns filename opt_sep sections Type-Bound Procedures add add_a_option add_option add_section assign_file_ini assignment(=) count_values del free free_option_of_section free_options free_options_all free_options_of_section free_section get get_a_option get_items get_option get_sections_list has_option has_section index index_option index_section initialize load loop loop_options loop_options_section parse print save section Source Code file_ini Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: Ns = 0 Number of sections. character(len=:), public, allocatable :: filename File name character(len=1), private :: opt_sep = DEF_OPT_SEP Separator character of option name/value. type( section ), private, allocatable :: sections (:) Sections. Type-Bound Procedures generic, public :: add => add_section , add_option , add_a_option Add a section.\nAdd an option to a section (scalar).\nAdd an option to a section (array). private pure subroutine add_section (self, error, section_name) Add a section. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. private pure subroutine add_option (self, error, section_name, option_name, val) Add an option (with scalar value). Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. private pure subroutine add_a_option (self, error, section_name, option_name, val) Add an option (with array value). Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. procedure, private, pass(self) :: add_a_option Add an option to a section (array). private pure subroutine add_a_option (self, error, section_name, option_name, val) Add an option (with array value). Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. procedure, private, pass(self) :: add_option Add an option to a section (scalar). private pure subroutine add_option (self, error, section_name, option_name, val) Add an option (with scalar value). Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. procedure, private, pass(self) :: add_section Add a section. private pure subroutine add_section (self, error, section_name) Add a section. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. procedure, private, pass(lhs) :: assign_file_ini Assignment overloading. private elemental subroutine assign_file_ini (lhs, rhs) Assignment between two INI files. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. generic, public :: assignment(=) => assign_file_ini Procedure for section assignment overloading. private elemental subroutine assign_file_ini (lhs, rhs) Assignment between two INI files. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. procedure, public, pass(self) :: count_values Count option value(s). private elemental function count_values (self, delimiter, section_name, option_name) result(Nv) Get the number of values of option into section data. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in), optional :: delimiter Delimiter used for separating values. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. Return Value integer(kind=I4P) Number of values. generic, public :: del => free_option_of_section , free_section Remove (freeing) an option of a section.\nRemove (freeing) a section. private elemental subroutine free_option_of_section (self, section_name, option_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. private elemental subroutine free_section (self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. procedure, public, pass(self) :: free Free dynamic memory destroyng file data. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. procedure, private, pass(self) :: free_option_of_section Free an option of a section. private elemental subroutine free_option_of_section (self, section_name, option_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. generic, public :: free_options => free_options_all , free_options_of_section , free_option_of_section Free all options.\nFree all options of a section.\nFree an option of a section. private elemental subroutine free_options_all (self) Free all options of all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. private elemental subroutine free_options_of_section (self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. private elemental subroutine free_option_of_section (self, section_name, option_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. procedure, private, pass(self) :: free_options_all Free all options of all sections. private elemental subroutine free_options_all (self) Free all options of all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. procedure, private, pass(self) :: free_options_of_section Free all options of a section. private elemental subroutine free_options_of_section (self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. procedure, private, pass(self) :: free_section Free a section. private elemental subroutine free_section (self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. generic, public :: get => get_option , get_a_option Get option value (scalar).\nGet option value (array). private subroutine get_option (self, section_name, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. private subroutine get_a_option (self, section_name, option_name, val, delimiter, error) Get option value (array) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: get_a_option Get option value (array). private subroutine get_a_option (self, section_name, option_name, val, delimiter, error) Get option value (array) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, public, pass(self) :: get_items Get list of pairs option name/value. private pure subroutine get_items (self, items) Get list of pairs option name/value. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: items (:,:) Items, list of pairs option name/value for all options [1:No,1:2]. procedure, private, pass(self) :: get_option Get option value (scalar). private subroutine get_option (self, section_name, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. procedure, public, pass(self) :: get_sections_list Get sections names list. private pure subroutine get_sections_list (self, list) Get sections names list. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: list (:) Sections names list. procedure, public, pass(self) :: has_option Inquire the presence of an option. private function has_option (self, option_name, section_name) result(pres) Inquire the presence of (at least one) option with the name passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: option_name Option name. character, intent(inout), optional :: section_name Section name. Return Value logical Inquiring flag. procedure, public, pass(self) :: has_section Inquire the presence of a section. private elemental function has_section (self, section_name) result(pres) Inquire the presence of (at least one) section with the name passed. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. Return Value logical Inquiring flag. generic, public :: index => index_section , index_option Return the index of a section.\nReturn the index of an option. private elemental function index_section (self, back, section_name) result(ind) Return the index of the section matching the name passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. private elemental function index_option (self, back, section_name, option_name) result(ind) Return the index of the option (inside a  section) matching the name(s) passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. procedure, private, pass(self) :: index_option Return the index of an option. private elemental function index_option (self, back, section_name, option_name) result(ind) Return the index of the option (inside a  section) matching the name(s) passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. procedure, private, pass(self) :: index_section Return the index of a section. private elemental function index_section (self, back, section_name) result(ind) Return the index of the section matching the name passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. procedure, public, pass(self) :: initialize Initialize file. private elemental subroutine initialize (self, filename) Initialize file. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in), optional :: filename File name. procedure, public, pass(self) :: load Load file data. private subroutine load (self, separator, filename, source, error) Get file data from a file or a source string. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=1), intent(in), optional :: separator Separator of options name/value. character, intent(in), optional :: filename File name. character, intent(in), optional :: source File source contents. integer(kind=I4P), intent(out), optional :: error Error code. generic, public :: loop => loop_options_section , loop_options Loop over options of a section.\nLoop over all options. private function loop_options_section (self, section_name, option_pairs) result(again) Loop returning option name/value defined into section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. private recursive function loop_options (self, option_pairs) result(again) Loop returning option name/value defined into all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. procedure, private, pass(self) :: loop_options Loop over all options. private recursive function loop_options (self, option_pairs) result(again) Loop returning option name/value defined into all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. procedure, private, pass(self) :: loop_options_section Loop over options of a section. private function loop_options_section (self, section_name, option_pairs) result(again) Loop returning option name/value defined into section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. procedure, private, pass(self) :: parse Parse file data. private subroutine parse (self, source, error) Parse file either from the self source data or from a source string. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. type(string), intent(in) :: source String source. integer(kind=I4P), intent(out), optional :: error Error code. procedure, public, pass(self) :: print => print_file_ini Pretty printing data. private subroutine print_file_ini (self, unit, pref, retain_comments, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: unit Logic unit. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. procedure, public, pass(self) :: save => save_file_ini Save data. private subroutine save_file_ini (self, retain_comments, iostat, iomsg, filename) Save data. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. character, intent(in), optional :: filename File name. procedure, public, pass(self) :: section => section_file_ini Get section name once provided an index. private pure function section_file_ini (self, section_index) result(sname) Get section name once an index (valid) is provided. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: section_index Section index. Return Value character(len=:),allocatable Section name. Source Code type :: file_ini !< INI file class. private character ( len = :), allocatable , public :: filename !< File name integer ( I4P ) :: Ns = 0 !< Number of sections. character ( 1 ) :: opt_sep = DEF_OPT_SEP !< Separator character of option name/value. type ( section ), allocatable :: sections (:) !< Sections. contains ! public methods generic :: add => add_section , & !< Add a section. add_option , & !< Add an option to a section (scalar). add_a_option !< Add an option to a section (array). procedure , pass ( self ) :: count_values !< Count option value(s). generic :: del => free_option_of_section , & !< Remove (freeing) an option of a section. free_section !< Remove (freeing) a section. procedure , pass ( self ) :: free !< Free dynamic memory destroyng file data. generic :: free_options => free_options_all , & !< Free all options. free_options_of_section , & !< Free all options of a section. free_option_of_section !< Free an option of a section. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_items !< Get list of pairs option name/value. procedure , pass ( self ) :: get_sections_list !< Get sections names list. procedure , pass ( self ) :: initialize !< Initialize file. procedure , pass ( self ) :: has_option !< Inquire the presence of an option. procedure , pass ( self ) :: has_section !< Inquire the presence of a section. generic :: index => index_section , & !< Return the index of a section. index_option !< Return the index of an option. procedure , pass ( self ) :: load !< Load file data. generic :: loop => loop_options_section , & !< Loop over options of a section. loop_options !< Loop over all options. procedure , pass ( self ) :: print => print_file_ini !< Pretty printing data. procedure , pass ( self ) :: save => save_file_ini !< Save data. procedure , pass ( self ) :: section => section_file_ini !< Get section name once provided an index. ! operators overloading generic :: assignment ( = ) => assign_file_ini !< Procedure for section assignment overloading. ! private methods procedure , private , pass ( self ) :: add_a_option !< Add an option to a section (array). procedure , private , pass ( self ) :: add_option !< Add an option to a section (scalar). procedure , private , pass ( self ) :: add_section !< Add a section. procedure , private , pass ( self ) :: free_options_all !< Free all options of all sections. procedure , private , pass ( self ) :: free_options_of_section !< Free all options of a section. procedure , private , pass ( self ) :: free_option_of_section !< Free an option of a section. procedure , private , pass ( self ) :: free_section !< Free a section. procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: index_option !< Return the index of an option. procedure , private , pass ( self ) :: index_section !< Return the index of a section. procedure , private , pass ( self ) :: loop_options !< Loop over all options. procedure , private , pass ( self ) :: loop_options_section !< Loop over options of a section. procedure , private , pass ( self ) :: parse !< Parse file data. ! assignments procedure , private , pass ( lhs ) :: assign_file_ini !< Assignment overloading. endtype file_ini","tags":"","loc":"type/file_ini.html"},{"title":"section – FiNeR ","text":"type, public :: section Section data of file INI. Inherits type~~section~~InheritsGraph type~section section type~option option type~section->type~option options string string type~option->string oname, ovals, ocomm Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~section~~InheritedByGraph type~section section type~file_ini file_ini type~file_ini->type~section sections Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables options sname Constructor section Type-Bound Procedures add add_a_option add_option assign_section assignment(=) count_values free free_option free_options get get_a_option get_option has_options index loop max_chars_len name operator(==) option_pairs options_number parse parse_name parse_options print sanitize_source save section_eq_character section_eq_string set set_a_option set_option Source Code section Components Type Visibility Attributes Name Initial type( option ), private, allocatable :: options (:) Section options. character(len=:), private, allocatable :: sname Section name. Constructor public interface section Overload section name with a function returning a new (itiliazed) section instance. private elemental function new_section (section_name) Return a new (initiliazed) section instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Type-Bound Procedures generic, public :: add => add_option , add_a_option Add an option (scalar).\nAdd an option (array). private pure subroutine add_option (self, option_name, val, error) Add an option (with scalar value). Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine add_a_option (self, option_name, val, delimiter, error) Add an option (with array value). Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: add_a_option Add an option (array). private pure subroutine add_a_option (self, option_name, val, delimiter, error) Add an option (with array value). Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: add_option Add an option (scalar). private pure subroutine add_option (self, option_name, val, error) Add an option (with scalar value). Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(lhs) :: assign_section Assignment overloading. private elemental subroutine assign_section (lhs, rhs) Assignment between two sections. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. generic, public :: assignment(=) => assign_section Assignment overloading. private elemental subroutine assign_section (lhs, rhs) Assignment between two sections. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. procedure, public, pass(self) :: count_values Count option value(s). private elemental function count_values (self, option_name, delimiter) result(Nv) Get the number of values of option into section data. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. character, intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. procedure, public, pass(self) :: free_option Free a option. private elemental subroutine free_option (self, option_name) Free an option. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. procedure, public, pass(self) :: free_options Free all options. private elemental subroutine free_options (self) Free all options. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. generic, public :: get => get_option , get_a_option Get option value (scalar).\nGet option value (array). private subroutine get_option (self, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. private subroutine get_a_option (self, option_name, val, delimiter, error) Procedure for getting option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: get_a_option Get option value (array). private subroutine get_a_option (self, option_name, val, delimiter, error) Procedure for getting option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: get_option Get option value (scalar). private subroutine get_option (self, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. procedure, public, pass(self) :: has_options Inquire if section has options. private elemental function has_options (self) Inquire is section has options (at least one). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value logical Inquire result. procedure, public, pass(self) :: index => index_option Return the index of an option. private elemental function index_option (self, option_name, back) result(ind) Return the index of the option matching the name passed. Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. Return Value integer(kind=I4P) Index of searched section. procedure, public, pass(self) :: loop Loop over options. private function loop (self, option_pairs) result(again) Loop returning option name/value defined into section. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. procedure, public, pass(self) :: max_chars_len Return max len of option-name/values on all options. private elemental function max_chars_len (self) Return the maximum number of characters between option-name/option-values on all options. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer(kind=I4P) Inquire result. procedure, public, pass(self) :: name Return section name. private pure function name (self) Return section name. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value character(len=len) Section data. generic, public :: operator(==) => section_eq_string , section_eq_character Equal operator overloading. private elemental function section_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function section_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, public, pass(self) :: option_pairs Return an option pairs. private pure subroutine option_pairs (self, option_index, pairs) Return an option pairs. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Option data. integer, intent(in) :: option_index Option index. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. procedure, public, pass(self) :: options_number Return the options number. private elemental function options_number (self) Return the options number. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer(kind=I4P) Options number. procedure, public, pass(self) :: parse Parse section data. private elemental subroutine parse (self, sep, source, error) Gett section data from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. procedure, private, pass(self) :: parse_name Get section name. private elemental subroutine parse_name (self, source, error) Get section name from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. type(string), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. procedure, private, pass(self) :: parse_options Get section options. private elemental subroutine parse_options (self, sep, source, error) Get section options from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. procedure, public, pass(self) :: print => print_section Pretty print data. private subroutine print_section (self, unit, retain_comments, pref, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. procedure, private, nopass :: sanitize_source Sanitize source. private elemental subroutine sanitize_source (sep, source, error) Sanitize source. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. procedure, public, pass(self) :: save => save_section Save data. private subroutine save_section (self, unit, retain_comments, iostat, iomsg) Save data. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. procedure, private, pass(lhs) :: section_eq_character Equal to character logical operator. private elemental function section_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: section_eq_string Equal to string logical operator. private elemental function section_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: set => set_option , set_a_option Set option value (scalar).\nSet option value (array). private pure subroutine set_option (self, option_name, val, error) Set option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine set_a_option (self, option_name, val, delimiter, error) Set option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: set_a_option Set option value (array). private pure subroutine set_a_option (self, option_name, val, delimiter, error) Set option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. procedure, private, pass(self) :: set_option Set option value (scalar). private pure subroutine set_option (self, option_name, val, error) Set option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Source Code type :: section !< Section data of file INI. private character ( len = :), allocatable :: sname !< Section name. type ( option ), allocatable :: options (:) !< Section options. contains ! public methods generic :: add => add_option , & !< Add an option (scalar). add_a_option !< Add an option (array). procedure , pass ( self ) :: count_values !< Count option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: free_options !< Free all options. procedure , pass ( self ) :: free_option !< Free a option. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: has_options !< Inquire if section has options. procedure , pass ( self ) :: index => index_option !< Return the index of an option. procedure , pass ( self ) :: loop !< Loop over options. procedure , pass ( self ) :: max_chars_len !< Return max len of option-name/values on all options. procedure , pass ( self ) :: name !< Return section name. procedure , pass ( self ) :: options_number !< Return the options number. procedure , pass ( self ) :: option_pairs !< Return an option pairs. procedure , pass ( self ) :: parse !< Parse section data. procedure , pass ( self ) :: print => print_section !< Pretty print data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: save => save_section !< Save data. ! operators overloading generic :: assignment ( = ) => assign_section !< Assignment overloading. generic :: operator ( == ) => section_eq_string , & section_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: add_option !< Add an option (scalar). procedure , private , pass ( self ) :: add_a_option !< Add an option (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_name !< Get section name. procedure , private , pass ( self ) :: parse_options !< Get section options. procedure , private , nopass :: sanitize_source !< Sanitize source. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_section !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: section_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: section_eq_character !< Equal to character logical operator. endtype section","tags":"","loc":"type/section.html"},{"title":"count_values – FiNeR","text":"private elemental function count_values(self, delimiter) result(Nv) Get the number of values of option data. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character, intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Contents Source Code count_values Source Code elemental function count_values ( self , delimiter ) result ( Nv ) !< Get the number of values of option data. class ( option ), intent ( in ) :: self !< Option data. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. if ( self % ovals % is_allocated ()) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter Nv = self % ovals % count ( dlm ) + 1 else Nv = 0 endif endfunction count_values","tags":"","loc":"proc/count_values.html"},{"title":"name_len – FiNeR","text":"private elemental function name_len(self) result(length) Return option name length. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option name length. Contents Source Code name_len Source Code elemental function name_len ( self ) result ( length ) !< Return option name length. class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option name length. length = 0 if ( self % oname % is_allocated ()) length = self % oname % len () endfunction name_len","tags":"","loc":"proc/name_len.html"},{"title":"new_option – FiNeR","text":"private elemental function new_option(option_name, option_values, option_comment) Return a new (initiliazed) option instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: option_name Option name. character, intent(in), optional :: option_values Option values. character, intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Called by proc~~new_option~~CalledByGraph proc~new_option new_option interface~option option interface~option->proc~new_option Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code new_option Source Code elemental function new_option ( option_name , option_values , option_comment ) !< Return a new (initiliazed) option instance. character ( * ), intent ( in ), optional :: option_name !< Option name. character ( * ), intent ( in ), optional :: option_values !< Option values. character ( * ), intent ( in ), optional :: option_comment !< Option comment. type ( option ) :: new_option !< New (initiliazed) option instance. if ( present ( option_name )) new_option % oname = option_name if ( present ( option_values )) new_option % ovals = option_values if ( present ( option_comment )) new_option % ocomm = option_comment endfunction new_option","tags":"","loc":"proc/new_option.html"},{"title":"option_eq_character – FiNeR","text":"private elemental function option_eq_character(lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code option_eq_character Source Code elemental function option_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. class ( option ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % oname == rhs endfunction option_eq_character","tags":"","loc":"proc/option_eq_character.html"},{"title":"option_eq_string – FiNeR","text":"private elemental function option_eq_string(lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code option_eq_string Source Code elemental function option_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. class ( option ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % oname == rhs endfunction option_eq_string","tags":"","loc":"proc/option_eq_string.html"},{"title":"values_len – FiNeR","text":"private elemental function values_len(self) result(length) Return option values length. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option values length. Contents Source Code values_len Source Code elemental function values_len ( self ) result ( length ) !< Return option values length. class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option values length. length = 0 if ( self % ovals % is_allocated ()) length = self % ovals % len () endfunction values_len","tags":"","loc":"proc/values_len.html"},{"title":"assign_option – FiNeR","text":"private elemental subroutine assign_option(lhs, rhs) Assignment between two options. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. Contents Source Code assign_option Source Code elemental subroutine assign_option ( lhs , rhs ) !< Assignment between two options. class ( option ), intent ( inout ) :: lhs !< Left hand side. type ( option ), intent ( in ) :: rhs !< Rigth hand side. if ( rhs % oname % is_allocated ()) lhs % oname = rhs % oname if ( rhs % ovals % is_allocated ()) lhs % ovals = rhs % ovals if ( rhs % ocomm % is_allocated ()) lhs % ocomm = rhs % ocomm endsubroutine assign_option","tags":"","loc":"proc/assign_option.html"},{"title":"free – FiNeR","text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Contents Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( option ), intent ( inout ) :: self !< Option data. call self % oname % free call self % ovals % free call self % ocomm % free endsubroutine free","tags":"","loc":"proc/free.html"},{"title":"get_a_option – FiNeR","text":"private subroutine get_a_option(self, val, delimiter, error) Get option data values (array). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code get_a_option Source Code subroutine get_a_option ( self , val , delimiter , error ) !< Get option data values (array). class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. type ( string ), allocatable :: valsV (:) !< String array of values. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. integer ( I4P ) :: v !< Counter. errd = ERR_OPTION_VALS dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( self % ovals % is_allocated ()) then call self % ovals % split ( tokens = valsV , sep = dlm ) Nv = size ( valsV , dim = 1 ) select type ( val ) #ifdef _R16P type is ( real ( R16P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R16P ) enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R8P ) enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R4P ) enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I8P ) enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I4P ) enddo #ifndef _NVF type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I2P ) enddo #endif type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I1P ) enddo type is ( logical ) do v = 1 , Nv buffer = valsV ( v )% chars () read ( buffer , * ) val ( v ) enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v )% chars () enddo endselect errd = 0 endif if ( present ( error )) error = errd endsubroutine get_a_option","tags":"","loc":"proc/get_a_option.html"},{"title":"get_option – FiNeR","text":"private subroutine get_option(self, val, error) for getting option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code get_option Source Code subroutine get_option ( self , val , error ) !< for getting option data value (scalar). class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. errd = ERR_OPTION_VALS if ( self % ovals % is_allocated ()) then select type ( val ) #ifdef _R16P type is ( real ( R16P )) val = self % ovals % to_number ( kind = 1._R16P ) #endif type is ( real ( R8P )) val = self % ovals % to_number ( kind = 1._R8P ) type is ( real ( R4P )) val = self % ovals % to_number ( kind = 1._R4P ) type is ( integer ( I8P )) val = self % ovals % to_number ( kind = 1_I8P ) type is ( integer ( I4P )) val = self % ovals % to_number ( kind = 1_I4P ) #ifndef _NVF type is ( integer ( I2P )) val = self % ovals % to_number ( kind = 1_I2P ) #endif type is ( integer ( I1P )) val = self % ovals % to_number ( kind = 1_I1P ) type is ( logical ) buffer = self % ovals % chars () read ( buffer , * ) val type is ( character ( * )) val = self % ovals % chars () endselect errd = 0 endif if ( present ( error )) error = errd endsubroutine get_option","tags":"","loc":"proc/get_option.html"},{"title":"get_pairs – FiNeR","text":"private pure subroutine get_pairs(self, pairs) Return option name/values pairs. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Contents Source Code get_pairs Source Code pure subroutine get_pairs ( self , pairs ) !< Return option name/values pairs. class ( option ), intent ( in ) :: self !< Option data. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: Nc !< Counter. if ( self % oname % is_allocated ()) then Nc = max ( self % oname % len (), self % ovals % len ()) allocate ( character ( Nc ) :: pairs ( 1 : 2 )) pairs ( 1 ) = self % oname % chars () pairs ( 2 ) = self % ovals % chars () endif endsubroutine get_pairs","tags":"","loc":"proc/get_pairs.html"},{"title":"parse – FiNeR","text":"private elemental subroutine parse(self, sep, source, error) Parse option data from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Contents Source Code parse Source Code elemental subroutine parse ( self , sep , source , error ) !< Parse option data from a source string. class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. error = ERR_OPTION if ( scan ( adjustl ( source ), comments ) == 1 ) return call self % parse_name ( sep = sep , source = source , error = error ) call self % parse_value ( sep = sep , source = source , error = error ) call self % parse_comment endsubroutine parse","tags":"","loc":"proc/parse.html"},{"title":"parse_comment – FiNeR","text":"private elemental subroutine parse_comment(self) Parse option inline comment trimming it out from pure value string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. Contents Source Code parse_comment Source Code elemental subroutine parse_comment ( self ) !< Parse option inline comment trimming it out from pure value string. class ( option ), intent ( inout ) :: self !< Option data. integer ( I4P ) :: pos !< Characters counter. if ( self % ovals % is_allocated ()) then pos = self % ovals % index ( INLINE_COMMENT ) if ( pos > 0 ) then if ( pos < self % ovals % len ()) self % ocomm = trim ( adjustl ( self % ovals % slice ( pos + 1 , self % ovals % len ()))) self % ovals = trim ( adjustl ( self % ovals % slice ( 1 , pos - 1 ))) endif endif endsubroutine parse_comment","tags":"","loc":"proc/parse_comment.html"},{"title":"parse_name – FiNeR","text":"private elemental subroutine parse_name(self, sep, source, error) Parse option name from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Contents Source Code parse_name Source Code elemental subroutine parse_name ( self , sep , source , error ) !< Parse option name from a source string. class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. error = ERR_OPTION_NAME pos = index ( source , sep ) if ( pos > 0 ) then self % oname = trim ( adjustl ( source % slice ( 1 , pos - 1 ))) error = 0 endif endsubroutine parse_name","tags":"","loc":"proc/parse_name.html"},{"title":"parse_value – FiNeR","text":"private elemental subroutine parse_value(self, sep, source, error) Parse option value from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Contents Source Code parse_value Source Code elemental subroutine parse_value ( self , sep , source , error ) !< Parse option value from a source string. class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. error = ERR_OPTION_VALS pos = index ( source , sep ) if ( pos > 0 ) then if ( pos < source % len ()) self % ovals = trim ( adjustl ( source % slice ( pos + 1 , source % len ()))) error = 0 endif endsubroutine parse_value","tags":"","loc":"proc/parse_value.html"},{"title":"print_option – FiNeR","text":"private subroutine print_option(self, unit, retain_comments, pref, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. Contents Source Code print_option Source Code subroutine print_option ( self , unit , retain_comments , pref , iostat , iomsg ) !< Print data with a pretty format. class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. if ( self % oname % is_allocated ()) then prefd = '' ; if ( present ( pref )) prefd = pref comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif endsubroutine print_option","tags":"","loc":"proc/print_option.html"},{"title":"save_option – FiNeR","text":"private subroutine save_option(self, unit, retain_comments, iostat, iomsg) Save data. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. Contents Source Code save_option Source Code subroutine save_option ( self , unit , retain_comments , iostat , iomsg ) !< Save data. class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. if ( self % oname % is_allocated ()) then comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif endsubroutine save_option","tags":"","loc":"proc/save_option.html"},{"title":"set_a_option – FiNeR","text":"private pure subroutine set_a_option(self, val, delimiter) Set option data value (array). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. Calls proc~~set_a_option~~CallsGraph proc~set_a_option set_a_option str str proc~set_a_option->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_a_option Source Code pure subroutine set_a_option ( self , val , delimiter ) !< Set option data value (array). class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: v !< Counter. dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter self % ovals = '' select type ( val ) #ifdef _R16P type is ( real ( R16P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () #endif type is ( real ( R8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( real ( R4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I2P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I1P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( logical ) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( character ( * )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( val ( v )) enddo self % ovals = self % ovals % strip () endselect endsubroutine set_a_option","tags":"","loc":"proc/set_a_option.html"},{"title":"set_option – FiNeR","text":"private pure subroutine set_option(self, val) Set option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value. Calls proc~~set_option~~CallsGraph proc~set_option set_option str str proc~set_option->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_option Source Code pure subroutine set_option ( self , val ) !< Set option data value (scalar). class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val !< Value. select type ( val ) #ifdef _R16P type is ( real ( R16P )) self % ovals = val #endif type is ( real ( R8P )) self % ovals = val type is ( real ( R4P )) self % ovals = val type is ( integer ( I8P )) self % ovals = val type is ( integer ( I4P )) self % ovals = val type is ( integer ( I2P )) self % ovals = val type is ( integer ( I1P )) self % ovals = val type is ( logical ) self % ovals = trim ( str ( n = val )) type is ( character ( * )) self % ovals = val endselect endsubroutine set_option","tags":"","loc":"proc/set_option.html"},{"title":"option – FiNeR","text":"public interface option Overload option name with a function returning a new (initiliazed) option instance. Calls interface~~option~~CallsGraph interface~option option proc~new_option new_option interface~option->proc~new_option Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures new_option Module Procedures private elemental function new_option (option_name, option_values, option_comment) Return a new (initiliazed) option instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: option_name Option name. character, intent(in), optional :: option_values Option values. character, intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance.","tags":"","loc":"interface/option.html"},{"title":"count_values – FiNeR","text":"private elemental function count_values(self, delimiter, section_name, option_name) result(Nv) Get the number of values of option into section data. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in), optional :: delimiter Delimiter used for separating values. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. Return Value integer(kind=I4P) Number of values. Contents Source Code count_values Source Code elemental function count_values ( self , delimiter , section_name , option_name ) result ( Nv ) !< Get the number of values of option into section data. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: s !< Counter. if ( allocated ( self % sections )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then Nv = self % sections ( s )% count_values ( delimiter = dlm , option_name = option_name ) exit endif enddo endif endfunction count_values","tags":"","loc":"proc/count_values~2.html"},{"title":"has_option – FiNeR","text":"private function has_option(self, option_name, section_name) result(pres) Inquire the presence of (at least one) option with the name passed. Optional, the first matching section name is returned. Note All sections are searched and the first occurence is returned. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: option_name Option name. character, intent(inout), optional :: section_name Section name. Return Value logical Inquiring flag. Contents Source Code has_option Source Code function has_option ( self , option_name , section_name ) result ( pres ) !< Inquire the presence of (at least one) option with the name passed. !< !< Optional, the first matching section name is returned. !< !< @note All sections are searched and the first occurence is returned. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), optional , intent ( inout ) :: section_name !< Section name. logical :: pres !< Inquiring flag. integer ( I4P ) :: s !< Counter. pres = . false . if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) pres = ( self % sections ( s )% index ( option_name = option_name ) > 0 ) if ( pres ) then if ( present ( section_name )) section_name = self % sections ( s )% name () exit endif enddo endif endfunction has_option","tags":"","loc":"proc/has_option.html"},{"title":"has_section – FiNeR","text":"private elemental function has_section(self, section_name) result(pres) Inquire the presence of (at least one) section with the name passed. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. Return Value logical Inquiring flag. Contents Source Code has_section Source Code elemental function has_section ( self , section_name ) result ( pres ) !< Inquire the presence of (at least one) section with the name passed. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. logical :: pres !< Inquiring flag. pres = ( self % index ( section_name = section_name ) > 0 ) endfunction has_section","tags":"","loc":"proc/has_section.html"},{"title":"index_option – FiNeR","text":"private elemental function index_option(self, back, section_name, option_name) result(ind) Return the index of the option (inside a  section) matching the name(s) passed. Note The matching index returned is the first found if back is not passed or if back=.false. . On the contrary the last\nfound is returned if back=.true. . Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. Contents Source Code index_option Source Code elemental function index_option ( self , back , section_name , option_name ) result ( ind ) !< Return the index of the option (inside a  section) matching the name(s) passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. class ( file_ini ), intent ( in ) :: self !< File data. logical , optional , intent ( in ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( in ) :: option_name !< Option  name. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back s = self % index ( section_name = section_name , back = backd ) if ( s > 0 ) then ind = self % sections ( s )% index ( option_name = option_name , back = backd ) endif endif endfunction index_option","tags":"","loc":"proc/index_option.html"},{"title":"index_section – FiNeR","text":"private elemental function index_section(self, back, section_name) result(ind) Return the index of the section matching the name passed. Note The matching index returned is the first found if back is not passed or if back=.false. . On the contrary the last\nfound is returned if back=.true. . Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. Contents Source Code index_section Source Code elemental function index_section ( self , back , section_name ) result ( ind ) !< Return the index of the section matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. class ( file_ini ), intent ( IN ) :: self !< File data. logical , optional , intent ( IN ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( IN ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do s = size ( self % sections , dim = 1 ), 1 , - 1 if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo else do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo endif endif endfunction index_section","tags":"","loc":"proc/index_section.html"},{"title":"loop_options – FiNeR","text":"private recursive function loop_options(self, option_pairs) result(again) Loop returning option name/value defined into all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. Contents Source Code loop_options Source Code recursive function loop_options ( self , option_pairs ) result ( again ) !< Loop returning option name/value defined into all sections. class ( file_ini ), intent ( IN ) :: self !< File data. character ( len = :), allocatable , intent ( OUT ) :: option_pairs (:) !< Pairs option name/value [1:2]. logical :: again !< Flag continuing the loop. logical , save :: againO = . false . !< Flag continuing the loop. integer ( I4P ), save :: s = 0 !< Counter. again = . false . if ( allocated ( self % sections )) then if ( s == 0 ) then s = lbound ( self % sections , dim = 1 ) againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) again = . true . elseif ( s < ubound ( self % sections , dim = 1 )) then if (. not . againO ) s = s + 1 againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) if (. not . againO ) then again = self % loop ( option_pairs = option_pairs ) else again = . true . endif else s = 0 againO = . false . again = . false . endif endif endfunction loop_options","tags":"","loc":"proc/loop_options.html"},{"title":"loop_options_section – FiNeR","text":"private function loop_options_section(self, section_name, option_pairs) result(again) Loop returning option name/value defined into section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. Contents Source Code loop_options_section Source Code function loop_options_section ( self , section_name , option_pairs ) result ( again ) !< Loop returning option name/value defined into section. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Pairs option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ) :: s !< Counter. again = . false . s = self % index ( section_name = section_name ) if ( s > 0 ) then again = self % sections ( s )% loop ( option_pairs = option_pairs ) endif endfunction loop_options_section","tags":"","loc":"proc/loop_options_section.html"},{"title":"section_file_ini – FiNeR","text":"private pure function section_file_ini(self, section_index) result(sname) Get section name once an index (valid) is provided. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: section_index Section index. Return Value character(len=:),allocatable Section name. Contents Source Code section_file_ini Source Code pure function section_file_ini ( self , section_index ) result ( sname ) !< Get section name once an index (valid) is provided. class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: section_index !< Section index. character ( len = :), allocatable :: sname !< Section name. if ( allocated ( self % sections )) then if (( section_index >= lbound ( self % sections , dim = 1 )). and .( section_index <= ubound ( self % sections , dim = 1 ))) then sname = self % sections ( section_index )% name () endif endif endfunction section_file_ini","tags":"","loc":"proc/section_file_ini.html"},{"title":"add_a_option – FiNeR","text":"private pure subroutine add_a_option(self, error, section_name, option_name, val) Add an option (with array value). If the option already exists, its value is updated. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. Contents Source Code add_a_option Source Code pure subroutine add_a_option ( self , error , section_name , option_name , val ) !< Add an option (with array value). !< !< If the option already exists, its value is updated. class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val ( 1 :) !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine add_a_option","tags":"","loc":"proc/add_a_option.html"},{"title":"add_option – FiNeR","text":"private pure subroutine add_option(self, error, section_name, option_name, val) Add an option (with scalar value). If the option already exists, its value is updated. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. Contents Source Code add_option Source Code pure subroutine add_option ( self , error , section_name , option_name , val ) !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine add_option","tags":"","loc":"proc/add_option.html"},{"title":"add_section – FiNeR","text":"private pure subroutine add_section(self, error, section_name) Add a section. If the section already exists, it is left unchanged. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. Contents Source Code add_section Source Code pure subroutine add_section ( self , error , section_name ) !< Add a section. !< !< If the section already exists, it is left unchanged. class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: errd !< Error code. errd = err_section if ( allocated ( self % sections )) then if ( self % index ( section_name = section_name ) == 0 ) then ! section not present allocate ( sections ( 1 : size ( self % sections , dim = 1 ) + 1 )) sections ( 1 : size ( self % sections , dim = 1 )) = self % sections sections ( size ( self % sections , dim = 1 ) + 1 ) = section ( section_name = trim ( adjustl ( section_name ))) call move_alloc ( sections , self % sections ) self % Ns = self % Ns + 1 endif else allocate ( self % sections ( 1 : 1 )) self % sections ( 1 ) = section ( section_name = section_name ) self % Ns = self % Ns + 1 endif if ( self % index ( section_name = section_name ) > 0 ) errd = 0 if ( present ( error )) error = errd endsubroutine add_section","tags":"","loc":"proc/add_section.html"},{"title":"assign_file_ini – FiNeR","text":"private elemental subroutine assign_file_ini(lhs, rhs) Assignment between two INI files. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. Contents Source Code assign_file_ini Source Code elemental subroutine assign_file_ini ( lhs , rhs ) !< Assignment between two INI files. class ( file_ini ), intent ( inout ) :: lhs !< Left hand side. type ( file_ini ), intent ( in ) :: rhs !< Rigth hand side. if ( allocated ( rhs % filename )) lhs % filename = rhs % filename if ( allocated ( rhs % sections )) then if ( allocated ( lhs % sections )) deallocate ( lhs % sections ) ; allocate ( lhs % sections ( 1 : size ( rhs % sections , dim = 1 ))) lhs % sections = rhs % sections endif lhs % Ns = rhs % Ns endsubroutine assign_file_ini","tags":"","loc":"proc/assign_file_ini.html"},{"title":"file_ini_autotest – FiNeR","text":"public subroutine file_ini_autotest() Autotest the library functionalities. Arguments None Calls proc~~file_ini_autotest~~CallsGraph proc~file_ini_autotest file_ini_autotest str str proc~file_ini_autotest->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~file_ini_autotest~~CalledByGraph proc~file_ini_autotest file_ini_autotest program~autotest autotest program~autotest->proc~file_ini_autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code file_ini_autotest Source Code subroutine file_ini_autotest () !< Autotest the library functionalities. type ( file_ini ) :: fini !< INI File. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. real ( R4P ), allocatable :: array (:) !< Array option. integer ( I4P ) :: error !< Error code. character ( len = :), allocatable :: items (:,:) !< List of all options name/value pairs. character ( len = :), allocatable :: item (:) !< Option name/value couple. character ( len = :), allocatable :: list (:) !< Sections names list. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: s !< Counter. source = '[section-1]' // new_line ( 'A' ) // & 'option-1 = one' // new_line ( 'A' ) // & 'option-2 = 2.' // new_line ( 'A' ) // & '           3. ; this is an inline comment' // new_line ( 'A' ) // & 'option-3 = bar ; this is an inline comment' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 = foo' print \"(A)\" , '' print \"(A)\" , \"Testing parsing procedures\" print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % load ( source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" string = '   ' call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-1 has values: ' , string allocate ( array ( 1 : fini % count_values ( section_name = 'section-1' , option_name = 'option-2' ))) call fini % get ( section_name = 'section-1' , option_name = 'option-2' , val = array , error = error ) if ( error == 0 ) print \"(A,3(F4.1,1X))\" , '  option-2 of section-1 has values: ' , array call fini % get ( section_name = 'section-1' , option_name = 'option-3' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-3 of section-1 has values: ' , string call fini % get ( section_name = 'section-2' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-2 has values: ' , string print \"(A)\" , '' print \"(A)\" , \"Parsed data will be saved as (having retained inline comments that are trimmed out by default):\" call fini % print ( pref = '  ' , unit = stdout , retain_comments = . true .) call fini % save ( filename = 'foo.ini' , retain_comments = . true .) call fini % free print \"(A)\" , '' print \"(A)\" , \"Testing generating procedures\" call fini % add ( section_name = 'sec-foo' ) call fini % add ( section_name = 'sec-foo' , option_name = 'bar' , val =- 3 2.1_R8P ) call fini % add ( section_name = 'sec-foo' , option_name = 'baz' , val = ' hello FiNeR! ' ) call fini % add ( section_name = 'sec-foo' , option_name = 'array' , val = [ 1 , 2 , 3 , 4 ]) call fini % add ( section_name = 'sec-bar' ) call fini % add ( section_name = 'sec-bar' , option_name = 'bools' , val = [. true .,. false .,. false .]) call fini % add ( section_name = 'sec-bartolomeo' ) call fini % add ( section_name = 'sec-bartolomeo' , option_name = 'help' , val = 'I am Bartolomeo' ) print \"(A)\" , \"The autogenerated INI file will be saved as:\" call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing option baz\" call fini % del ( section_name = 'sec-foo' , option_name = 'baz' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing section sec-bar\" call fini % del ( section_name = 'sec-bar' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing introspective methods\" print \"(A,L1)\" , \"Is there option bar? \" , fini % has_option ( option_name = 'bar' ) print \"(A,L1)\" , \"Is there option baz? \" , fini % has_option ( option_name = 'baz' ) print \"(A,L1)\" , \"Is there section sec-bar? \" , fini % has_section ( section_name = 'sec-bar' ) print \"(A,L1)\" , \"Is there section sec-foo? \" , fini % has_section ( section_name = 'sec-foo' ) print \"(A)\" , '' print \"(A)\" , \"What are all options name/values pairs? Can I have a list? Yes, you can:\" call fini % get_items ( items = items ) do i = 1 , size ( items , dim = 1 ) print \"(A)\" , trim ( items ( i , 1 )) // ' = ' // trim ( items ( i , 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over options of a section:\" do s = 1 , fini % Ns print \"(A)\" , fini % section ( s ) do while ( fini % loop ( section_name = fini % section ( s ), option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo enddo print \"(A)\" , \"Testing sections names list inquire:\" call fini % get_sections_list ( list ) do s = 1 , fini % Ns print \"(A)\" , 'Sec. ' // trim ( str ( s , . true .)) // ': ' // trim ( list ( s )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over all options:\" do while ( fini % loop ( option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing custom separator of option name/value:, use ':' instead of '='\" source = '[section-1]' // new_line ( 'A' ) // & 'option-1 : one' // new_line ( 'A' ) // & 'option-2 : 2.' // new_line ( 'A' ) // & '           3.' // new_line ( 'A' ) // & 'option-3 : bar' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 : foo' print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % free call fini % load ( separator = ':' , source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" call fini % print ( pref = '  ' , unit = stdout ) ! remove \"foo.ini\" open ( newunit = i , file = 'foo.ini' ) ; close ( unit = i , status = 'DELETE' ) endsubroutine file_ini_autotest","tags":"","loc":"proc/file_ini_autotest.html"},{"title":"free – FiNeR","text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Contents Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( file_ini ), intent ( inout ) :: self !< File data. if ( allocated ( self % filename )) deallocate ( self % filename ) if ( allocated ( self % sections )) then call self % sections % free deallocate ( self % sections ) endif self % Ns = 0 self % opt_sep = def_opt_sep endsubroutine free","tags":"","loc":"proc/free~2.html"},{"title":"free_option_of_section – FiNeR","text":"private elemental subroutine free_option_of_section(self, section_name, option_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. Contents Source Code free_option_of_section Source Code elemental subroutine free_option_of_section ( self , section_name , option_name ) !< Free all options of a section. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option  name. integer ( I4P ) :: s !< Counter. s = self % index ( section_name = section_name ) if ( s > 0 ) call self % sections ( s )% free_option ( option_name = option_name ) endsubroutine free_option_of_section","tags":"","loc":"proc/free_option_of_section.html"},{"title":"free_options_all – FiNeR","text":"private elemental subroutine free_options_all(self) Free all options of all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. Contents Source Code free_options_all Source Code elemental subroutine free_options_all ( self ) !< Free all options of all sections. class ( file_ini ), intent ( inout ) :: self !< File data. if ( allocated ( self % sections )) call self % sections % free_options endsubroutine free_options_all","tags":"","loc":"proc/free_options_all.html"},{"title":"free_options_of_section – FiNeR","text":"private elemental subroutine free_options_of_section(self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. Contents Source Code free_options_of_section Source Code elemental subroutine free_options_of_section ( self , section_name ) !< Free all options of a section. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: s !< Counter. if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% free_options exit endif enddo endif endsubroutine free_options_of_section","tags":"","loc":"proc/free_options_of_section.html"},{"title":"free_section – FiNeR","text":"private elemental subroutine free_section(self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. Contents Source Code free_section Source Code elemental subroutine free_section ( self , section_name ) !< Free all options of a section. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: s !< Counter. s = self % index ( section_name = section_name ) if ( s > 0 ) then allocate ( sections ( 1 : size ( self % sections , dim = 1 ) - 1 )) if ( s == 1 ) then sections = self % sections ( 2 :) elseif ( s == size ( self % sections , dim = 1 )) then sections = self % sections (: s - 1 ) else sections (: s - 1 ) = self % sections (: s - 1 ) sections ( s : ) = self % sections ( s + 1 :) endif call move_alloc ( sections , self % sections ) self % Ns = self % Ns - 1 endif endsubroutine free_section","tags":"","loc":"proc/free_section.html"},{"title":"get_a_option – FiNeR","text":"private subroutine get_a_option(self, section_name, option_name, val, delimiter, error) Get option value (array) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code get_a_option Source Code subroutine get_a_option ( self , section_name , option_name , val , delimiter , error ) !< Get option value (array) class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = ERR_OPTION dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( delimiter = dlm , error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_a_option","tags":"","loc":"proc/get_a_option~2.html"},{"title":"get_items – FiNeR","text":"private pure subroutine get_items(self, items) Get list of pairs option name/value. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: items (:,:) Items, list of pairs option name/value for all options [1:No,1:2]. Contents Source Code get_items Source Code pure subroutine get_items ( self , items ) !< Get list of pairs option name/value. class ( file_ini ), intent ( in ) :: self !< File data. character ( len = :), allocatable , intent ( out ) :: items (:,:) !< Items, list of pairs option name/value for all options [1:No,1:2]. character ( len = :), allocatable :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: mx_chars !< Maximum number of chars into name/value within all options. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: No !< Counter. mx_chars = MinI4P if ( allocated ( self % sections )) then No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then mx_chars = max ( mx_chars , self % sections ( s )% max_chars_len ()) No = No + self % sections ( s )% options_number () endif enddo if (( mx_chars > 0 ). and .( No > 0 )) then allocate ( character ( mx_chars ) :: items ( 1 : No , 1 : 2 )) No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then do o = 1 , self % sections ( s )% options_number () No = No + 1 call self % sections ( s )% option_pairs ( option_index = o , pairs = pairs ) items ( No , 1 ) = pairs ( 1 ) items ( No , 2 ) = pairs ( 2 ) enddo endif enddo endif endif endsubroutine get_items","tags":"","loc":"proc/get_items.html"},{"title":"get_option – FiNeR","text":"private subroutine get_option(self, section_name, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code get_option Source Code subroutine get_option ( self , section_name , option_name , val , error ) !< Get option value (scalar). class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = ERR_OPTION if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_option","tags":"","loc":"proc/get_option~2.html"},{"title":"get_sections_list – FiNeR","text":"private pure subroutine get_sections_list(self, list) Get sections names list. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: list (:) Sections names list. Contents Source Code get_sections_list Source Code pure subroutine get_sections_list ( self , list ) !< Get sections names list. class ( file_ini ), intent ( in ) :: self !< File data. character ( len = :), allocatable , intent ( out ) :: list (:) !< Sections names list. integer :: max_len !< Max length of section name. integer :: s !< Counter. if ( allocated ( self % sections )) then max_len = MinI_P do s = 1 , self % Ns max_len = max ( max_len , len ( self % sections ( s )% name ())) enddo if ( max_len > 0 ) then allocate ( character ( len = max_len ) :: list ( 1 : self % Ns )) do s = 1 , self % Ns list ( s ) = self % sections ( s )% name () enddo endif endif endsubroutine get_sections_list","tags":"","loc":"proc/get_sections_list.html"},{"title":"initialize – FiNeR","text":"private elemental subroutine initialize(self, filename) Initialize file. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in), optional :: filename File name. Contents Source Code initialize Source Code elemental subroutine initialize ( self , filename ) !< Initialize file. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ), optional :: filename !< File name. call self % free if ( present ( filename )) self % filename = trim ( adjustl ( filename )) endsubroutine initialize","tags":"","loc":"proc/initialize.html"},{"title":"load – FiNeR","text":"private subroutine load(self, separator, filename, source, error) Get file data from a file or a source string. Usage Loading from a file type ( file_ini ) :: fini\ncall fini%load ( filename = 'path_to_my_file.ini' ) Loading from a source string type ( file_ini ) :: fini\ncall fini%load ( source = '[section-1] option-1=one [section-2] option-2=due' ) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=1), intent(in), optional :: separator Separator of options name/value. character, intent(in), optional :: filename File name. character, intent(in), optional :: source File source contents. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code load Source Code subroutine load ( self , separator , filename , source , error ) !< Get file data from a file or a source string. !< !<### Usage !< !<##### Loading from a file !<```bash !<type(file_ini):: fini !<call fini%load(filename='path_to_my_file.ini') !<``` !< !<##### Loading from a source string !<```bash !<type(file_ini):: fini !<call fini%load(source='[section-1] option-1=one [section-2] option-2=due') !<``` class ( file_ini ), intent ( inout ) :: self !< File data. character ( 1 ), intent ( in ), optional :: separator !< Separator of options name/value. character ( * ), intent ( in ), optional :: filename !< File name. character ( * ), intent ( in ), optional :: source !< File source contents. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. type ( string ) :: source_ !< File source contents, local variable. errd = ERR_SOURCE_MISSING if ( present ( separator )) self % opt_sep = separator if ( present ( filename )) then self % filename = trim ( adjustl ( filename )) call source_ % read_file ( file = self % filename , iostat = errd ) elseif ( present ( source )) then source_ = source errd = 0 elseif ( allocated ( self % filename )) then call source_ % read_file ( file = self % filename , iostat = errd ) endif if ( errd <= 0 ) call self % parse ( source = source_ , error = errd ) if ( present ( error )) error = errd endsubroutine load","tags":"","loc":"proc/load.html"},{"title":"parse – FiNeR","text":"private subroutine parse(self, source, error) Parse file either from the self source data or from a source string. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. type(string), intent(in) :: source String source. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code parse Source Code subroutine parse ( self , source , error ) !< Parse file either from the self source data or from a source string. class ( file_ini ), intent ( inout ) :: self !< File data. type ( string ), intent ( in ) :: source !< String source. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. type ( string ) :: dummy !< Dummy string for parsing sections. integer ( I4P ) :: Ns !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: ss !< Counter. errd = err_source_missing call source % split ( tokens = tokens , sep = new_line ( 'a' )) Ns = 0 s = 0 do while ( s + 1 <= size ( tokens , dim = 1 )) s = s + 1 if ( scan ( adjustl ( tokens ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( tokens ( s ))), \"[\" ) == 1 ) then Ns = Ns + 1 dummy = trim ( adjustl ( tokens ( s ))) // new_line ( 'a' ) ss = s do while ( ss + 1 <= size ( tokens , dim = 1 )) ss = ss + 1 if ( index ( trim ( adjustl ( tokens ( ss ))), \"[\" ) == 1 ) then ! new section... go back exit else ! continuation of current section dummy = trim ( adjustl ( dummy )) // new_line ( 'a' ) // trim ( adjustl ( tokens ( ss ))) tokens ( ss ) = comments ! forcing skip this in the following scan endif enddo tokens ( s ) = trim ( adjustl ( dummy )) endif enddo if ( Ns > 0 ) then if ( allocated ( self % sections )) deallocate ( self % sections ) ; allocate ( self % sections ( 1 : Ns )) s = 0 ss = 0 do while ( s + 1 <= size ( tokens , dim = 1 )) s = s + 1 if ( scan ( adjustl ( tokens ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( tokens ( s ))), \"[\" ) == 1 ) then ss = ss + 1 call self % sections ( ss )% parse ( sep = self % opt_sep , source = tokens ( s ), error = errd ) endif enddo endif self % Ns = Ns if ( present ( error )) error = errd endsubroutine parse","tags":"","loc":"proc/parse~2.html"},{"title":"print_file_ini – FiNeR","text":"private subroutine print_file_ini(self, unit, pref, retain_comments, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: unit Logic unit. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. Contents Source Code print_file_ini Source Code subroutine print_file_ini ( self , unit , pref , retain_comments , iostat , iomsg ) !< Print data with a pretty format. class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. prefd = '' ; if ( present ( pref )) prefd = pref rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% print ( pref = prefd , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine print_file_ini","tags":"","loc":"proc/print_file_ini.html"},{"title":"save_file_ini – FiNeR","text":"private subroutine save_file_ini(self, retain_comments, iostat, iomsg, filename) Save data. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. character, intent(in), optional :: filename File name. Contents Source Code save_file_ini Source Code subroutine save_file_ini ( self , retain_comments , iostat , iomsg , filename ) !< Save data. class ( file_ini ), intent ( inout ) :: self !< File data. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( * ), optional , intent ( in ) :: filename !< File name. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: unit !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( present ( filename )) self % filename = filename if ( allocated ( self % filename ). and . allocated ( self % sections )) then open ( newunit = unit , file = self % filename , action = 'WRITE' , iostat = iostatd , iomsg = iomsgd ) do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo close ( unit = unit , iostat = iostatd , iomsg = iomsgd ) endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine save_file_ini","tags":"","loc":"proc/save_file_ini.html"},{"title":"count_values – FiNeR","text":"private elemental function count_values(self, option_name, delimiter) result(Nv) Get the number of values of option into section data. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. character, intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. Contents Source Code count_values Source Code elemental function count_values ( self , option_name , delimiter ) result ( Nv ) !< Get the number of values of option into section data. class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. if ( allocated ( self % options )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then Nv = self % options ( o )% count_values ( delimiter = dlm ) exit endif enddo endif endfunction count_values","tags":"","loc":"proc/count_values~3.html"},{"title":"has_options – FiNeR","text":"private elemental function has_options(self) Inquire is section has options (at least one). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value logical Inquire result. Contents Source Code has_options Source Code elemental function has_options ( self ) !< Inquire is section has options (at least one). class ( section ), intent ( in ) :: self !< Section data. logical :: has_options !< Inquire result. has_options = allocated ( self % options ) endfunction has_options","tags":"","loc":"proc/has_options.html"},{"title":"index_option – FiNeR","text":"private elemental function index_option(self, option_name, back) result(ind) Return the index of the option matching the name passed. Note The matching index returned is the first found if back is not passed or if back=.false. . On the contrary the last\nfound is returned if back=.true. . Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. Return Value integer(kind=I4P) Index of searched section. Contents Source Code index_option Source Code elemental function index_option ( self , option_name , back ) result ( ind ) !< Return the index of the option matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. logical , intent ( in ), optional :: back !< If back appears with the value true, the last matching index is returned. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: o !< Counter. ind = 0 if ( allocated ( self % options )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do o = size ( self % options , dim = 1 ), 1 , - 1 if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo else do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo endif endif endfunction index_option","tags":"","loc":"proc/index_option~2.html"},{"title":"loop – FiNeR","text":"private function loop(self, option_pairs) result(again) Loop returning option name/value defined into section. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. Contents Source Code loop Source Code function loop ( self , option_pairs ) result ( again ) !< Loop returning option name/value defined into section. class ( section ), intent ( in ) :: self !< Section data. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ), save :: o = 0 !< Counter. again = . false . if ( allocated ( self % options )) then if ( o == 0 ) then o = lbound ( self % options , dim = 1 ) call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . elseif ( o < ubound ( self % options , dim = 1 )) then o = o + 1 call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . else o = 0 again = . false . endif endif endfunction loop","tags":"","loc":"proc/loop.html"},{"title":"max_chars_len – FiNeR","text":"private elemental function max_chars_len(self) Return the maximum number of characters between option-name/option-values on all options. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer(kind=I4P) Inquire result. Contents Source Code max_chars_len Source Code elemental function max_chars_len ( self ) !< Return the maximum number of characters between option-name/option-values on all options. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ) :: max_chars_len !< Inquire result. integer ( I4P ) :: o !< Counter. max_chars_len = MinI4P if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) max_chars_len = max ( max_chars_len , self % options ( o )% name_len (), self % options ( o )% values_len ()) enddo endif endfunction max_chars_len","tags":"","loc":"proc/max_chars_len.html"},{"title":"name – FiNeR","text":"private pure function name(self) Return section name. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value character(len=len) Section data. Contents Source Code name Source Code pure function name ( self ) !< Return section name. class ( section ), intent ( in ) :: self !< Section data. character ( len = len ( self % sname )) :: name !< Section data. if ( allocated ( self % sname )) name = self % sname endfunction name","tags":"","loc":"proc/name.html"},{"title":"new_section – FiNeR","text":"private elemental function new_section(section_name) Return a new (initiliazed) section instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Called by proc~~new_section~~CalledByGraph proc~new_section new_section interface~section section interface~section->proc~new_section Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code new_section Source Code elemental function new_section ( section_name ) !< Return a new (initiliazed) section instance. character ( * ), intent ( in ), optional :: section_name !< Option name. type ( section ) :: new_section !< New (initiliazed) section instance. if ( present ( section_name )) new_section % sname = section_name endfunction new_section","tags":"","loc":"proc/new_section.html"},{"title":"options_number – FiNeR","text":"private elemental function options_number(self) Return the options number. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer(kind=I4P) Options number. Contents Source Code options_number Source Code elemental function options_number ( self ) !< Return the options number. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ) :: options_number !< Options number. options_number = 0 if ( allocated ( self % options )) options_number = size ( self % options , dim = 1 ) endfunction options_number","tags":"","loc":"proc/options_number.html"},{"title":"section_eq_character – FiNeR","text":"private elemental function section_eq_character(lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code section_eq_character Source Code elemental function section_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. class ( section ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % sname == rhs endfunction section_eq_character","tags":"","loc":"proc/section_eq_character.html"},{"title":"section_eq_string – FiNeR","text":"private elemental function section_eq_string(lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code section_eq_string Source Code elemental function section_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. class ( section ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % sname == rhs endfunction section_eq_string","tags":"","loc":"proc/section_eq_string.html"},{"title":"add_a_option – FiNeR","text":"private pure subroutine add_a_option(self, option_name, val, delimiter, error) Add an option (with array value). If the option already exists, its value is updated. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code add_a_option Source Code pure subroutine add_a_option ( self , option_name , val , delimiter , error ) !< Add an option (with array value). !< !< If the option already exists, its value is updated. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Option value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd endsubroutine add_a_option","tags":"","loc":"proc/add_a_option~2.html"},{"title":"add_option – FiNeR","text":"private pure subroutine add_option(self, option_name, val, error) Add an option (with scalar value). If the option already exists, its value is updated. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code add_option Source Code pure subroutine add_option ( self , option_name , val , error ) !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ), intent ( out ), optional :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then call self % set ( error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd endsubroutine add_option","tags":"","loc":"proc/add_option~2.html"},{"title":"assign_section – FiNeR","text":"private elemental subroutine assign_section(lhs, rhs) Assignment between two sections. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. Contents Source Code assign_section Source Code elemental subroutine assign_section ( lhs , rhs ) !< Assignment between two sections. class ( section ), intent ( INOUT ) :: lhs !< Left hand side. type ( section ), intent ( IN ) :: rhs !< Rigth hand side. if ( allocated ( rhs % sname )) lhs % sname = rhs % sname if ( allocated ( rhs % options )) then if ( allocated ( lhs % options )) deallocate ( lhs % options ) ; allocate ( lhs % options ( 1 : size ( rhs % options , dim = 1 ))) lhs % options = rhs % options endif endsubroutine assign_section","tags":"","loc":"proc/assign_section.html"},{"title":"free – FiNeR","text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Contents Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( section ), intent ( inout ) :: self !< Section data. if ( allocated ( self % sname )) deallocate ( self % sname ) call self % free_options endsubroutine free","tags":"","loc":"proc/free~3.html"},{"title":"free_option – FiNeR","text":"private elemental subroutine free_option(self, option_name) Free an option. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. Contents Source Code free_option Source Code elemental subroutine free_option ( self , option_name ) !< Free an option. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: o !< Counter. if ( allocated ( self % options )) then o = self % index ( option_name = option_name ) if ( o > 0 ) then allocate ( options ( 1 : size ( self % options , dim = 1 ) - 1 )) if ( o == 1 ) then options = self % options ( 2 :) elseif ( o == size ( self % options , dim = 1 )) then options = self % options (: o - 1 ) else options (: o - 1 ) = self % options (: o - 1 ) options ( o : ) = self % options ( o + 1 :) endif call move_alloc ( options , self % options ) endif endif endsubroutine free_option","tags":"","loc":"proc/free_option.html"},{"title":"free_options – FiNeR","text":"private elemental subroutine free_options(self) Free all options. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. Contents Source Code free_options Source Code elemental subroutine free_options ( self ) !< Free all options. class ( section ), intent ( inout ) :: self !< Section data. if ( allocated ( self % options )) then call self % options % free deallocate ( self % options ) endif endsubroutine free_options","tags":"","loc":"proc/free_options.html"},{"title":"get_a_option – FiNeR","text":"private subroutine get_a_option(self, option_name, val, delimiter, error) Procedure for getting option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code get_a_option Source Code subroutine get_a_option ( self , option_name , val , delimiter , error ) !< Procedure for getting option value (array). class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. errd = ERR_OPTION dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( delimiter = dlm , error = errd , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_a_option","tags":"","loc":"proc/get_a_option~3.html"},{"title":"get_option – FiNeR","text":"private subroutine get_option(self, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code get_option Source Code subroutine get_option ( self , option_name , val , error ) !< Get option value (scalar). class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. errd = ERR_OPTION if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( error = errd , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_option","tags":"","loc":"proc/get_option~3.html"},{"title":"option_pairs – FiNeR","text":"private pure subroutine option_pairs(self, option_index, pairs) Return an option pairs. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Option data. integer, intent(in) :: option_index Option index. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. Contents Source Code option_pairs Source Code pure subroutine option_pairs ( self , option_index , pairs ) !< Return an option pairs. class ( section ), intent ( in ) :: self !< Option data. integer , intent ( in ) :: option_index !< Option index. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. call self % options ( option_index )% get_pairs ( pairs = pairs ) endsubroutine option_pairs","tags":"","loc":"proc/option_pairs.html"},{"title":"parse – FiNeR","text":"private elemental subroutine parse(self, sep, source, error) Gett section data from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Contents Source Code parse Source Code elemental subroutine parse ( self , sep , source , error ) !< Gett section data from a source string. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. call self % sanitize_source ( sep = sep , source = source , error = error ) call self % parse_name ( source = source , error = error ) call self % parse_options ( sep = sep , source = source , error = error ) endsubroutine parse","tags":"","loc":"proc/parse~3.html"},{"title":"parse_name – FiNeR","text":"private elemental subroutine parse_name(self, source, error) Get section name from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. type(string), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Contents Source Code parse_name Source Code elemental subroutine parse_name ( self , source , error ) !< Get section name from a source string. class ( section ), intent ( inout ) :: self !< Section data. type ( string ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos ( 1 : 2 ) !< Characters counter. error = ERR_SECTION_NAME pos ( 1 ) = index ( source , \"[\" ) pos ( 2 ) = index ( source , \"]\" ) if ( all ( pos > 0 )) then self % sname = trim ( adjustl ( source % slice ( pos ( 1 ) + 1 , pos ( 2 ) - 1 ))) error = 0 endif endsubroutine parse_name","tags":"","loc":"proc/parse_name~2.html"},{"title":"parse_options – FiNeR","text":"private elemental subroutine parse_options(self, sep, source, error) Get section options from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. Contents Source Code parse_options Source Code elemental subroutine parse_options ( self , sep , source , error ) !< Get section options from a source string. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. type ( string ) :: dummy !< Dummy string for parsing options. integer ( I4P ) :: No !< Counter. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: oo !< Counter. error = 0 source = trim ( adjustl ( source % slice ( index ( source , \"]\" ) + 1 , source % len ()))) No = source % count ( substring = sep ) if ( No > 0 ) then call source % split ( tokens = tokens , sep = new_line ( 'a' )) if ( allocated ( self % options )) deallocate ( self % options ) ; allocate ( self % options ( 1 : No )) o = 0 oo = 0 do while ( o + 1 <= size ( tokens , dim = 1 )) o = o + 1 if ( index ( tokens ( o ), sep ) > 0 ) then oo = oo + 1 call self % options ( oo )% parse ( sep = sep , source = tokens ( o ), error = error ) endif enddo endif endsubroutine parse_options","tags":"","loc":"proc/parse_options.html"},{"title":"print_section – FiNeR","text":"private subroutine print_section(self, unit, retain_comments, pref, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. Contents Source Code print_section Source Code subroutine print_section ( self , unit , retain_comments , pref , iostat , iomsg ) !< Print data with a pretty format. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% print ( pref = prefd // '  ' , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine print_section","tags":"","loc":"proc/print_section.html"},{"title":"sanitize_source – FiNeR","text":"private elemental subroutine sanitize_source(sep, source, error) Sanitize source. Join splitted options; Arguments Type Intent Optional Attributes Name character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. Contents Source Code sanitize_source Source Code elemental subroutine sanitize_source ( sep , source , error ) !< Sanitize source. !< !<+ Join splitted options; character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. type ( string ), allocatable :: tokens (:) !< Source tokens. integer ( I4P ) :: o !< Counter. call source % split ( tokens = tokens , sep = new_line ( 'a' )) if ( size ( tokens , dim = 1 ) > 1 ) then do o = 2 , size ( tokens , dim = 1 ) if ( tokens ( o )% index ( substring = sep ) == 0 ) tokens ( o - 1 ) = tokens ( o - 1 ) // ' ' // tokens ( o ) enddo endif source = '' do o = 1 , size ( tokens , dim = 1 ) if (( tokens ( o )% index ( substring = sep ) > 0 ). or .& ( tokens ( o )% index ( substring = '[' ) > 0 ). or .& ( tokens ( o )% index ( substring = ']' ) > 0 )) source = source // tokens ( o ) // new_line ( 'a' ) enddo source = source % slice ( 1 , source % len () - 1 ) error = 0 endsubroutine sanitize_source","tags":"","loc":"proc/sanitize_source.html"},{"title":"save_section – FiNeR","text":"private subroutine save_section(self, unit, retain_comments, iostat, iomsg) Save data. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. Contents Source Code save_section Source Code subroutine save_section ( self , unit , retain_comments , iostat , iomsg ) !< Save data. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine save_section","tags":"","loc":"proc/save_section.html"},{"title":"set_a_option – FiNeR","text":"private pure subroutine set_a_option(self, option_name, val, delimiter, error) Set option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code set_a_option Source Code pure subroutine set_a_option ( self , option_name , val , delimiter , error ) !< Set option value (array). class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( delimiter = dlm , val = val ) errd = 0 exit endif enddo endif if ( present ( error )) error = errd endsubroutine set_a_option","tags":"","loc":"proc/set_a_option~2.html"},{"title":"set_option – FiNeR","text":"private pure subroutine set_option(self, option_name, val, error) Set option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. Contents Source Code set_option Source Code pure subroutine set_option ( self , option_name , val , error ) !< Set option value (scalar). class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( val = val ) errd = 0 exit endif enddo endif if ( present ( error )) error = errd endsubroutine set_option","tags":"","loc":"proc/set_option~2.html"},{"title":"section – FiNeR","text":"public interface section Overload section name with a function returning a new (itiliazed) section instance. Calls interface~~section~~CallsGraph interface~section section proc~new_section new_section interface~section->proc~new_section Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures new_section Module Procedures private elemental function new_section (section_name) Return a new (initiliazed) section instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance.","tags":"","loc":"interface/section.html"},{"title":"cli_parse – FiNeR","text":"subroutine cli_parse() Build and parse test cli. Arguments None Called by proc~~cli_parse~~CalledByGraph proc~cli_parse cli_parse program~finer_test_load finer_test_load program~finer_test_load->proc~cli_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cli_parse Source Code subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'finer_test_load' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"finer_test_load --ini test.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--ini' , & switch_ab = '-i' , & help = 'name of ini file' , & required = . true ., & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ini' , val = file_name ) endsubroutine cli_parse","tags":"","loc":"proc/cli_parse.html"},{"title":"finer_backend – FiNeR","text":"FiNeR backends: globals definition. Uses penf module~~finer_backend~~UsesGraph module~finer_backend finer_backend penf penf module~finer_backend->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~finer_backend~~UsedByGraph module~finer_backend finer_backend module~finer_option_t finer_option_t module~finer_option_t->module~finer_backend module~finer_section_t finer_section_t module~finer_section_t->module~finer_backend module~finer_section_t->module~finer_option_t module~finer finer module~finer->module~finer_backend module~finer_file_ini_t finer_file_ini_t module~finer->module~finer_file_ini_t module~finer_file_ini_t->module~finer_backend module~finer_file_ini_t->module~finer_option_t module~finer_file_ini_t->module~finer_section_t program~finer_test_load finer_test_load program~finer_test_load->module~finer program~finer_test_update_option finer_test_update_option program~finer_test_update_option->module~finer program~finer_test_get finer_test_get program~finer_test_get->module~finer program~autotest autotest program~autotest->module~finer program~finer_test_parse finer_test_parse program~finer_test_parse->module~finer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables COMMENTS DEF_OPT_SEP ERR_OPTION ERR_OPTION_NAME ERR_OPTION_VALS ERR_SECTION ERR_SECTION_NAME ERR_SECTION_OPTIONS ERR_SOURCE_MISSING INLINE_COMMENT Variables Type Visibility Attributes Name Initial character, public, parameter :: COMMENTS = \"!;#\" Characters used for defining a comment line. character(len=1), public, parameter :: DEF_OPT_SEP = '=' Default separator of option name/value. integer(kind=I4P), public, parameter :: ERR_OPTION = 3 Error flag for trapping errors in option. integer(kind=I4P), public, parameter :: ERR_OPTION_NAME = 1 Error flag for trapping errors in option name. integer(kind=I4P), public, parameter :: ERR_OPTION_VALS = 2 Error flag for trapping errors in option values. integer(kind=I4P), public, parameter :: ERR_SECTION = 6 Error flag for trapping errors in section. integer(kind=I4P), public, parameter :: ERR_SECTION_NAME = 4 Error flag for trapping errors in section name. integer(kind=I4P), public, parameter :: ERR_SECTION_OPTIONS = 5 Error flag for trapping errors in section options. integer(kind=I4P), public, parameter :: ERR_SOURCE_MISSING = 7 Error flag for trapping errors in file when source is missing. character(len=1), public, parameter :: INLINE_COMMENT = ';' Inline comment delimiter.","tags":"","loc":"module/finer_backend.html"},{"title":"finer_option_t – FiNeR","text":"Option class definition. Uses finer_backend stringifor penf module~~finer_option_t~~UsesGraph module~finer_option_t finer_option_t module~finer_backend finer_backend module~finer_option_t->module~finer_backend penf penf module~finer_option_t->penf stringifor stringifor module~finer_option_t->stringifor module~finer_backend->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~finer_option_t~~UsedByGraph module~finer_option_t finer_option_t module~finer_section_t finer_section_t module~finer_section_t->module~finer_option_t module~finer_file_ini_t finer_file_ini_t module~finer_file_ini_t->module~finer_option_t module~finer_file_ini_t->module~finer_section_t module~finer finer module~finer->module~finer_file_ini_t program~finer_test_load finer_test_load program~finer_test_load->module~finer program~finer_test_update_option finer_test_update_option program~finer_test_update_option->module~finer program~finer_test_get finer_test_get program~finer_test_get->module~finer program~autotest autotest program~autotest->module~finer program~finer_test_parse finer_test_parse program~finer_test_parse->module~finer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces option Derived Types option Functions count_values name_len new_option option_eq_character option_eq_string values_len Subroutines assign_option free get_a_option get_option get_pairs parse parse_comment parse_name parse_value print_option save_option set_a_option set_option Interfaces public interface option Overload option name with a function returning a new (initiliazed) option instance. private elemental function new_option (option_name, option_values, option_comment) Return a new (initiliazed) option instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: option_name Option name. character, intent(in), optional :: option_values Option values. character, intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. Derived Types type, public :: option Option data of sections. Components Type Visibility Attributes Name Initial type(string), private :: ocomm Eventual option inline comment. type(string), private :: oname Option name. type(string), private :: ovals Option values. Constructor Overload option name with a function returning a new (initiliazed) option instance. private elemental function new_option (option_name, option_values, option_comment) Return a new (initiliazed) option instance. Type-Bound Procedures procedure, private, pass(lhs) :: assign_option Assignment overloading. generic, public :: assignment(=) => assign_option Assignment overloading. procedure, public, pass(self) :: count_values Counting option value(s). procedure, public, pass(self) :: free Free dynamic memory. generic, public :: get => get_option, get_a_option Get option value (scalar).\nGet option value (array). procedure, private, pass(self) :: get_a_option Get option value (array). procedure, private, pass(self) :: get_option Get option value (scalar). procedure, public, pass(self) :: get_pairs Return option name/values pairs. procedure, public, pass(self) :: name_len Return option name length. generic, public :: operator(==) => option_eq_string, option_eq_character Equal operator overloading. procedure, private, pass(lhs) :: option_eq_character Equal to character logical operator. procedure, private, pass(lhs) :: option_eq_string Equal to string logical operator. procedure, public, pass(self) :: parse Parse option data. procedure, private, pass(self) :: parse_comment Parse option inline comment. procedure, private, pass(self) :: parse_name Parse option name. procedure, private, pass(self) :: parse_value Parse option values. procedure, public, pass(self) :: print => print_option Pretty print data. procedure, public, pass(self) :: save => save_option Save data. generic, public :: set => set_option, set_a_option Set option value (scalar).\nSet option value (array). procedure, private, pass(self) :: set_a_option Set option value (array). procedure, private, pass(self) :: set_option Set option value (scalar). procedure, public, pass(self) :: values_len Return option values length. Functions private elemental function count_values (self, delimiter) result(Nv) Get the number of values of option data. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character, intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. private elemental function name_len (self) result(length) Return option name length. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option name length. private elemental function new_option (option_name, option_values, option_comment) Return a new (initiliazed) option instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: option_name Option name. character, intent(in), optional :: option_values Option values. character, intent(in), optional :: option_comment Option comment. Return Value type( option ) New (initiliazed) option instance. private elemental function option_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function option_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function values_len (self) result(length) Return option values length. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. Return Value integer Option values length. Subroutines private elemental subroutine assign_option (lhs, rhs) Assignment between two options. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: lhs Left hand side. type( option ), intent(in) :: rhs Rigth hand side. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. private subroutine get_a_option (self, val, delimiter, error) Get option data values (array). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. private subroutine get_option (self, val, error) for getting option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine get_pairs (self, pairs) Return option name/values pairs. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. private elemental subroutine parse (self, sep, source, error) Parse option data from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. private elemental subroutine parse_comment (self) Parse option inline comment trimming it out from pure value string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. private elemental subroutine parse_name (self, sep, source, error) Parse option name from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. private elemental subroutine parse_value (self, sep, source, error) Parse option value from a source string. Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. character, intent(in) :: sep Separator of option name/value. type(string), intent(in) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. private subroutine print_option (self, unit, retain_comments, pref, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. private subroutine save_option (self, unit, retain_comments, iostat, iomsg) Save data. Arguments Type Intent Optional Attributes Name class( option ), intent(in) :: self Option data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. private pure subroutine set_a_option (self, val, delimiter) Set option data value (array). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. private pure subroutine set_option (self, val) Set option data value (scalar). Arguments Type Intent Optional Attributes Name class( option ), intent(inout) :: self Option data. class(*), intent(in) :: val Value.","tags":"","loc":"module/finer_option_t.html"},{"title":"finer – FiNeR","text":"FiNeR, Fortran INI ParseR and generator. Uses finer_backend finer_file_ini_t module~~finer~~UsesGraph module~finer finer module~finer_backend finer_backend module~finer->module~finer_backend module~finer_file_ini_t finer_file_ini_t module~finer->module~finer_file_ini_t penf penf module~finer_backend->penf module~finer_file_ini_t->module~finer_backend module~finer_file_ini_t->penf iso_fortran_env iso_fortran_env module~finer_file_ini_t->iso_fortran_env module~finer_section_t finer_section_t module~finer_file_ini_t->module~finer_section_t stringifor stringifor module~finer_file_ini_t->stringifor module~finer_option_t finer_option_t module~finer_file_ini_t->module~finer_option_t module~finer_section_t->module~finer_backend module~finer_section_t->penf module~finer_section_t->stringifor module~finer_section_t->module~finer_option_t module~finer_option_t->module~finer_backend module~finer_option_t->penf module~finer_option_t->stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~finer~~UsedByGraph module~finer finer program~finer_test_load finer_test_load program~finer_test_load->module~finer program~finer_test_update_option finer_test_update_option program~finer_test_update_option->module~finer program~finer_test_get finer_test_get program~finer_test_get->module~finer program~autotest autotest program~autotest->module~finer program~finer_test_parse finer_test_parse program~finer_test_parse->module~finer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/finer.html"},{"title":"finer_file_ini_t – FiNeR","text":"INI file class definition. Uses finer_section_t finer_option_t iso_fortran_env penf finer_backend stringifor module~~finer_file_ini_t~~UsesGraph module~finer_file_ini_t finer_file_ini_t iso_fortran_env iso_fortran_env module~finer_file_ini_t->iso_fortran_env penf penf module~finer_file_ini_t->penf module~finer_section_t finer_section_t module~finer_file_ini_t->module~finer_section_t module~finer_backend finer_backend module~finer_file_ini_t->module~finer_backend module~finer_option_t finer_option_t module~finer_file_ini_t->module~finer_option_t stringifor stringifor module~finer_file_ini_t->stringifor module~finer_section_t->penf module~finer_section_t->module~finer_backend module~finer_section_t->module~finer_option_t module~finer_section_t->stringifor module~finer_backend->penf module~finer_option_t->penf module~finer_option_t->module~finer_backend module~finer_option_t->stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~finer_file_ini_t~~UsedByGraph module~finer_file_ini_t finer_file_ini_t module~finer finer module~finer->module~finer_file_ini_t program~finer_test_load finer_test_load program~finer_test_load->module~finer program~finer_test_update_option finer_test_update_option program~finer_test_update_option->module~finer program~finer_test_get finer_test_get program~finer_test_get->module~finer program~autotest autotest program~autotest->module~finer program~finer_test_parse finer_test_parse program~finer_test_parse->module~finer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types file_ini Functions count_values has_option has_section index_option index_section loop_options loop_options_section section_file_ini Subroutines add_a_option add_option add_section assign_file_ini file_ini_autotest free free_option_of_section free_options_all free_options_of_section free_section get_a_option get_items get_option get_sections_list initialize load parse print_file_ini save_file_ini Derived Types type, public :: file_ini INI file class. Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: Ns = 0 Number of sections. character(len=:), public, allocatable :: filename File name character(len=1), private :: opt_sep = DEF_OPT_SEP Separator character of option name/value. type( section ), private, allocatable :: sections (:) Sections. Type-Bound Procedures generic, public :: add => add_section, add_option, add_a_option Add a section.\nAdd an option to a section (scalar).\nAdd an option to a section (array). procedure, private, pass(self) :: add_a_option Add an option to a section (array). procedure, private, pass(self) :: add_option Add an option to a section (scalar). procedure, private, pass(self) :: add_section Add a section. procedure, private, pass(lhs) :: assign_file_ini Assignment overloading. generic, public :: assignment(=) => assign_file_ini Procedure for section assignment overloading. procedure, public, pass(self) :: count_values Count option value(s). generic, public :: del => free_option_of_section, free_section Remove (freeing) an option of a section.\nRemove (freeing) a section. procedure, public, pass(self) :: free Free dynamic memory destroyng file data. procedure, private, pass(self) :: free_option_of_section Free an option of a section. generic, public :: free_options => free_options_all, free_options_of_section, free_option_of_section Free all options.\nFree all options of a section.\nFree an option of a section. procedure, private, pass(self) :: free_options_all Free all options of all sections. procedure, private, pass(self) :: free_options_of_section Free all options of a section. procedure, private, pass(self) :: free_section Free a section. generic, public :: get => get_option, get_a_option Get option value (scalar).\nGet option value (array). procedure, private, pass(self) :: get_a_option Get option value (array). procedure, public, pass(self) :: get_items Get list of pairs option name/value. procedure, private, pass(self) :: get_option Get option value (scalar). procedure, public, pass(self) :: get_sections_list Get sections names list. procedure, public, pass(self) :: has_option Inquire the presence of an option. procedure, public, pass(self) :: has_section Inquire the presence of a section. generic, public :: index => index_section, index_option Return the index of a section.\nReturn the index of an option. procedure, private, pass(self) :: index_option Return the index of an option. procedure, private, pass(self) :: index_section Return the index of a section. procedure, public, pass(self) :: initialize Initialize file. procedure, public, pass(self) :: load Load file data. generic, public :: loop => loop_options_section, loop_options Loop over options of a section.\nLoop over all options. procedure, private, pass(self) :: loop_options Loop over all options. procedure, private, pass(self) :: loop_options_section Loop over options of a section. procedure, private, pass(self) :: parse Parse file data. procedure, public, pass(self) :: print => print_file_ini Pretty printing data. procedure, public, pass(self) :: save => save_file_ini Save data. procedure, public, pass(self) :: section => section_file_ini Get section name once provided an index. Functions private elemental function count_values (self, delimiter, section_name, option_name) result(Nv) Get the number of values of option into section data. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in), optional :: delimiter Delimiter used for separating values. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. Return Value integer(kind=I4P) Number of values. private function has_option (self, option_name, section_name) result(pres) Inquire the presence of (at least one) option with the name passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: option_name Option name. character, intent(inout), optional :: section_name Section name. Return Value logical Inquiring flag. private elemental function has_section (self, section_name) result(pres) Inquire the presence of (at least one) section with the name passed. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. Return Value logical Inquiring flag. private elemental function index_option (self, back, section_name, option_name) result(ind) Return the index of the option (inside a  section) matching the name(s) passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. Return Value integer(kind=I4P) Index of searched section. private elemental function index_section (self, back, section_name) result(ind) Return the index of the section matching the name passed. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. character, intent(in) :: section_name Section name. Return Value integer(kind=I4P) Index of searched section. private recursive function loop_options (self, option_pairs) result(again) Loop returning option name/value defined into all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. private function loop_options_section (self, section_name, option_pairs) result(again) Loop returning option name/value defined into section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character(len=:), intent(out), allocatable :: option_pairs (:) Pairs option name/value [1:2]. Return Value logical Flag continuing the loop. private pure function section_file_ini (self, section_index) result(sname) Get section name once an index (valid) is provided. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: section_index Section index. Return Value character(len=:),allocatable Section name. Subroutines private pure subroutine add_a_option (self, error, section_name, option_name, val) Add an option (with array value). Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (1:) Option value. private pure subroutine add_option (self, error, section_name, option_name, val) Add an option (with scalar value). Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. private pure subroutine add_section (self, error, section_name) Add a section. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. integer(kind=I4P), intent(out), optional :: error Error code. character, intent(in) :: section_name Section name. private elemental subroutine assign_file_ini (lhs, rhs) Assignment between two INI files. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: lhs Left hand side. type( file_ini ), intent(in) :: rhs Rigth hand side. public subroutine file_ini_autotest () Autotest the library functionalities. Arguments None private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. private elemental subroutine free_option_of_section (self, section_name, option_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option  name. private elemental subroutine free_options_all (self) Free all options of all sections. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. private elemental subroutine free_options_of_section (self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. private elemental subroutine free_section (self, section_name) Free all options of a section. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in) :: section_name Section name. private subroutine get_a_option (self, section_name, option_name, val, delimiter, error) Get option value (array) Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine get_items (self, items) Get list of pairs option name/value. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: items (:,:) Items, list of pairs option name/value for all options [1:No,1:2]. private subroutine get_option (self, section_name, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character, intent(in) :: section_name Section name. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine get_sections_list (self, list) Get sections names list. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. character(len=:), intent(out), allocatable :: list (:) Sections names list. private elemental subroutine initialize (self, filename) Initialize file. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character, intent(in), optional :: filename File name. private subroutine load (self, separator, filename, source, error) Get file data from a file or a source string. Read more… Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. character(len=1), intent(in), optional :: separator Separator of options name/value. character, intent(in), optional :: filename File name. character, intent(in), optional :: source File source contents. integer(kind=I4P), intent(out), optional :: error Error code. private subroutine parse (self, source, error) Parse file either from the self source data or from a source string. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. type(string), intent(in) :: source String source. integer(kind=I4P), intent(out), optional :: error Error code. private subroutine print_file_ini (self, unit, pref, retain_comments, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(in) :: self File data. integer(kind=I4P), intent(in) :: unit Logic unit. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. private subroutine save_file_ini (self, retain_comments, iostat, iomsg, filename) Save data. Arguments Type Intent Optional Attributes Name class( file_ini ), intent(inout) :: self File data. logical, intent(in), optional :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. character, intent(in), optional :: filename File name.","tags":"","loc":"module/finer_file_ini_t.html"},{"title":"finer_section_t – FiNeR","text":"Section class definition. Uses finer_backend stringifor finer_option_t penf module~~finer_section_t~~UsesGraph module~finer_section_t finer_section_t module~finer_backend finer_backend module~finer_section_t->module~finer_backend stringifor stringifor module~finer_section_t->stringifor penf penf module~finer_section_t->penf module~finer_option_t finer_option_t module~finer_section_t->module~finer_option_t module~finer_backend->penf module~finer_option_t->module~finer_backend module~finer_option_t->stringifor module~finer_option_t->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~finer_section_t~~UsedByGraph module~finer_section_t finer_section_t module~finer_file_ini_t finer_file_ini_t module~finer_file_ini_t->module~finer_section_t module~finer finer module~finer->module~finer_file_ini_t program~finer_test_load finer_test_load program~finer_test_load->module~finer program~finer_test_update_option finer_test_update_option program~finer_test_update_option->module~finer program~finer_test_get finer_test_get program~finer_test_get->module~finer program~autotest autotest program~autotest->module~finer program~finer_test_parse finer_test_parse program~finer_test_parse->module~finer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces section Derived Types section Functions count_values has_options index_option loop max_chars_len name new_section options_number section_eq_character section_eq_string Subroutines add_a_option add_option assign_section free free_option free_options get_a_option get_option option_pairs parse parse_name parse_options print_section sanitize_source save_section set_a_option set_option Interfaces public interface section Overload section name with a function returning a new (itiliazed) section instance. private elemental function new_section (section_name) Return a new (initiliazed) section instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. Derived Types type, public :: section Section data of file INI. Components Type Visibility Attributes Name Initial type( option ), private, allocatable :: options (:) Section options. character(len=:), private, allocatable :: sname Section name. Constructor Overload section name with a function returning a new (itiliazed) section instance. private elemental function new_section (section_name) Return a new (initiliazed) section instance. Type-Bound Procedures generic, public :: add => add_option, add_a_option Add an option (scalar).\nAdd an option (array). procedure, private, pass(self) :: add_a_option Add an option (array). procedure, private, pass(self) :: add_option Add an option (scalar). procedure, private, pass(lhs) :: assign_section Assignment overloading. generic, public :: assignment(=) => assign_section Assignment overloading. procedure, public, pass(self) :: count_values Count option value(s). procedure, public, pass(self) :: free Free dynamic memory. procedure, public, pass(self) :: free_option Free a option. procedure, public, pass(self) :: free_options Free all options. generic, public :: get => get_option, get_a_option Get option value (scalar).\nGet option value (array). procedure, private, pass(self) :: get_a_option Get option value (array). procedure, private, pass(self) :: get_option Get option value (scalar). procedure, public, pass(self) :: has_options Inquire if section has options. procedure, public, pass(self) :: index => index_option Return the index of an option. procedure, public, pass(self) :: loop Loop over options. procedure, public, pass(self) :: max_chars_len Return max len of option-name/values on all options. procedure, public, pass(self) :: name Return section name. generic, public :: operator(==) => section_eq_string, section_eq_character Equal operator overloading. procedure, public, pass(self) :: option_pairs Return an option pairs. procedure, public, pass(self) :: options_number Return the options number. procedure, public, pass(self) :: parse Parse section data. procedure, private, pass(self) :: parse_name Get section name. procedure, private, pass(self) :: parse_options Get section options. procedure, public, pass(self) :: print => print_section Pretty print data. procedure, private, nopass :: sanitize_source Sanitize source. procedure, public, pass(self) :: save => save_section Save data. procedure, private, pass(lhs) :: section_eq_character Equal to character logical operator. procedure, private, pass(lhs) :: section_eq_string Equal to string logical operator. generic, public :: set => set_option, set_a_option Set option value (scalar).\nSet option value (array). procedure, private, pass(self) :: set_a_option Set option value (array). procedure, private, pass(self) :: set_option Set option value (scalar). Functions private elemental function count_values (self, option_name, delimiter) result(Nv) Get the number of values of option into section data. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. character, intent(in), optional :: delimiter Delimiter used for separating values. Return Value integer(kind=I4P) Number of values. private elemental function has_options (self) Inquire is section has options (at least one). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value logical Inquire result. private elemental function index_option (self, option_name, back) result(ind) Return the index of the option matching the name passed. Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. logical, intent(in), optional :: back If back appears with the value true, the last matching index is returned. Return Value integer(kind=I4P) Index of searched section. private function loop (self, option_pairs) result(again) Loop returning option name/value defined into section. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character(len=:), intent(out), allocatable :: option_pairs (:) Couples option name/value [1:2]. Return Value logical Flag continuing the loop. private elemental function max_chars_len (self) Return the maximum number of characters between option-name/option-values on all options. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer(kind=I4P) Inquire result. private pure function name (self) Return section name. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value character(len=len) Section data. private elemental function new_section (section_name) Return a new (initiliazed) section instance. Arguments Type Intent Optional Attributes Name character, intent(in), optional :: section_name Option name. Return Value type( section ) New (initiliazed) section instance. private elemental function options_number (self) Return the options number. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. Return Value integer(kind=I4P) Options number. private elemental function section_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function section_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: lhs Left hand side. type(string), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Subroutines private pure subroutine add_a_option (self, option_name, val, delimiter, error) Add an option (with array value). Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Option value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine add_option (self, option_name, val, error) Add an option (with scalar value). Read more… Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Option value. integer(kind=I4P), intent(out), optional :: error Error code. private elemental subroutine assign_section (lhs, rhs) Assignment between two sections. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: lhs Left hand side. type( section ), intent(in) :: rhs Rigth hand side. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. private elemental subroutine free_option (self, option_name) Free an option. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. private elemental subroutine free_options (self) Free all options. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. private subroutine get_a_option (self, option_name, val, delimiter, error) Procedure for getting option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val (1:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. private subroutine get_option (self, option_name, val, error) Get option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(inout) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine option_pairs (self, option_index, pairs) Return an option pairs. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Option data. integer, intent(in) :: option_index Option index. character(len=:), intent(out), allocatable :: pairs (:) Option name/values pairs. private elemental subroutine parse (self, sep, source, error) Gett section data from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. private elemental subroutine parse_name (self, source, error) Get section name from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. type(string), intent(in) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. private elemental subroutine parse_options (self, sep, source, error) Get section options from a source string. Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing section data. integer(kind=I4P), intent(out) :: error Error code. private subroutine print_section (self, unit, retain_comments, pref, iostat, iomsg) Print data with a pretty format. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. private elemental subroutine sanitize_source (sep, source, error) Sanitize source. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: sep Separator of option name/value. type(string), intent(inout) :: source String containing option data. integer(kind=I4P), intent(out) :: error Error code. private subroutine save_section (self, unit, retain_comments, iostat, iomsg) Save data. Arguments Type Intent Optional Attributes Name class( section ), intent(in) :: self Section data. integer(kind=I4P), intent(in) :: unit Logic unit. logical, intent(in) :: retain_comments Flag for retaining eventual comments. integer(kind=I4P), intent(out), optional :: iostat IO error. character, intent(out), optional :: iomsg IO error message. private pure subroutine set_a_option (self, option_name, val, delimiter, error) Set option value (array). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val (:) Value. character, intent(in), optional :: delimiter Delimiter used for separating values. integer(kind=I4P), intent(out), optional :: error Error code. private pure subroutine set_option (self, option_name, val, error) Set option value (scalar). Arguments Type Intent Optional Attributes Name class( section ), intent(inout) :: self Section data. character, intent(in) :: option_name Option name. class(*), intent(in) :: val Value. integer(kind=I4P), intent(out), optional :: error Error code.","tags":"","loc":"module/finer_section_t.html"},{"title":"finer_test_load – FiNeR","text":"Uses finer flap penf program~~finer_test_load~~UsesGraph program~finer_test_load finer_test_load module~finer finer program~finer_test_load->module~finer flap flap program~finer_test_load->flap penf penf program~finer_test_load->penf module~finer_backend finer_backend module~finer->module~finer_backend module~finer_file_ini_t finer_file_ini_t module~finer->module~finer_file_ini_t module~finer_backend->penf module~finer_file_ini_t->penf module~finer_file_ini_t->module~finer_backend iso_fortran_env iso_fortran_env module~finer_file_ini_t->iso_fortran_env module~finer_section_t finer_section_t module~finer_file_ini_t->module~finer_section_t module~finer_option_t finer_option_t module~finer_file_ini_t->module~finer_option_t stringifor stringifor module~finer_file_ini_t->stringifor module~finer_section_t->penf module~finer_section_t->module~finer_backend module~finer_section_t->module~finer_option_t module~finer_section_t->stringifor module~finer_option_t->penf module~finer_option_t->module~finer_backend module~finer_option_t->stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FiNeR test: basic load. Usage ./finer_test_load Calls program~~finer_test_load~~CallsGraph program~finer_test_load finer_test_load proc~cli_parse cli_parse program~finer_test_load->proc~cli_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables file_name fini i items Subroutines cli_parse Source Code finer_test_load Variables Type Attributes Name Initial character(len=999) :: file_name Name of INI file. type( file_ini ) :: fini INI file handler. integer :: i Counter. character(len=:), allocatable :: items (:,:) Items pairs. Subroutines subroutine cli_parse () Build and parse test cli. Arguments None Source Code program finer_test_load !< FiNeR test: basic load. !< !<### Usage !<```bash !< ./finer_test_load !<``` use finer , only : file_ini use flap , only : command_line_interface use penf , only : I4P implicit none character ( 999 ) :: file_name !< Name of INI file. type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: items (:,:) !< Items pairs. integer :: i !< Counter. call cli_parse call fini % load ( filename = file_name ) call fini % get_items ( items ) do i = 1 , size ( items , dim = 1 ) print \"(A)\" , trim ( items ( i , 1 )) // ' = ' // trim ( items ( i , 2 )) enddo contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'finer_test_load' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"finer_test_load --ini test.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--ini' , & switch_ab = '-i' , & help = 'name of ini file' , & required = . true ., & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ini' , val = file_name ) endsubroutine cli_parse endprogram finer_test_load","tags":"","loc":"program/finer_test_load.html"},{"title":"finer_test_update_option – FiNeR","text":"Uses finer iso_fortran_env penf program~~finer_test_update_option~~UsesGraph program~finer_test_update_option finer_test_update_option module~finer finer program~finer_test_update_option->module~finer iso_fortran_env iso_fortran_env program~finer_test_update_option->iso_fortran_env penf penf program~finer_test_update_option->penf module~finer_backend finer_backend module~finer->module~finer_backend module~finer_file_ini_t finer_file_ini_t module~finer->module~finer_file_ini_t module~finer_backend->penf module~finer_file_ini_t->iso_fortran_env module~finer_file_ini_t->penf module~finer_file_ini_t->module~finer_backend module~finer_section_t finer_section_t module~finer_file_ini_t->module~finer_section_t module~finer_option_t finer_option_t module~finer_file_ini_t->module~finer_option_t stringifor stringifor module~finer_file_ini_t->stringifor module~finer_section_t->penf module~finer_section_t->module~finer_backend module~finer_section_t->module~finer_option_t module~finer_section_t->stringifor module~finer_option_t->penf module~finer_option_t->module~finer_backend module~finer_option_t->stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FiNeR test: update existing option. Usage ./finer_test_update_option Contents Variables error fini source string test_passed Source Code finer_test_update_option Variables Type Attributes Name Initial integer(kind=I4P) :: error Error code. type( file_ini ) :: fini INI file handler. character(len=:), allocatable :: source Testing string. character(len=:), allocatable :: string String option. logical :: test_passed (3) List of passed tests. Source Code program finer_test_update_option !< FiNeR test: update existing option. !< !<### Usage !<```bash !< ./finer_test_update_option !<``` use , intrinsic :: iso_fortran_env , only : stdout => output_unit use finer , only : file_ini use penf , only : I4P , R4P , str implicit none type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. integer ( I4P ) :: error !< Error code. logical :: test_passed ( 3 ) !< List of passed tests. call fini % load ( filename = './src/tests/update_option.ini' ) call fini % print ( unit = stdout ) string = repeat ( ' ' , 999 ) call fini % get ( section_name = 'sec-foo' , option_name = 'bar2' , val = string , error = error ) test_passed ( 1 ) = (( error == 0 ). and .( trim ( string ) == '1.102325' )) call fini % add ( section_name = 'sec-foo' , option_name = 'bar2' , val = '0.99' ) call fini % print ( unit = stdout ) call fini % get ( section_name = 'sec-foo' , option_name = 'bar2' , val = string , error = error ) test_passed ( 2 ) = (( error == 0 ). and .( trim ( string ) == '0.99' )) call fini % get ( section_name = 'sec-foo' , option_name = 'bar' , val = string , error = error ) test_passed ( 3 ) = (( error == 0 ). and .( trim ( string ) == '-0.583000E+02' )) print \"(A,3L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram finer_test_update_option","tags":"","loc":"program/finer_test_update_option.html"},{"title":"finer_test_get – FiNeR","text":"Uses finer iso_fortran_env penf program~~finer_test_get~~UsesGraph program~finer_test_get finer_test_get module~finer finer program~finer_test_get->module~finer iso_fortran_env iso_fortran_env program~finer_test_get->iso_fortran_env penf penf program~finer_test_get->penf module~finer_backend finer_backend module~finer->module~finer_backend module~finer_file_ini_t finer_file_ini_t module~finer->module~finer_file_ini_t module~finer_backend->penf module~finer_file_ini_t->iso_fortran_env module~finer_file_ini_t->penf module~finer_file_ini_t->module~finer_backend module~finer_section_t finer_section_t module~finer_file_ini_t->module~finer_section_t module~finer_option_t finer_option_t module~finer_file_ini_t->module~finer_option_t stringifor stringifor module~finer_file_ini_t->stringifor module~finer_section_t->penf module~finer_section_t->module~finer_backend module~finer_section_t->module~finer_option_t module~finer_section_t->stringifor module~finer_option_t->penf module~finer_option_t->module~finer_backend module~finer_option_t->stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FiNeR test: basic get. Usage ./finer_test_get Contents Variables error fini source string test_passed Source Code finer_test_get Variables Type Attributes Name Initial integer(kind=I4P) :: error Error code. type( file_ini ) :: fini INI file handler. character(len=:), allocatable :: source Testing string. character(len=:), allocatable :: string String option. logical :: test_passed (2) List of passed tests. Source Code program finer_test_get !< FiNeR test: basic get. !< !<### Usage !<```bash !< ./finer_test_get !<``` use , intrinsic :: iso_fortran_env , only : output_unit use finer , only : file_ini use penf , only : I4P , R4P , str implicit none type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. integer ( I4P ) :: error !< Error code. logical :: test_passed ( 2 ) !< List of passed tests. source = '[section-1]' // new_line ( 'a' ) // & 'option-1 = one ; this is an inline comment' // new_line ( 'a' ) // & 'option-2 = bar' // new_line ( 'a' ) print \"(A)\" , 'Source input' // new_line ( 'a' ) // new_line ( 'a' ) // source // new_line ( 'a' ) // new_line ( 'a' ) // 'Parse results' // new_line ( 'a' ) call fini % load ( source = source , error = error ) string = repeat ( ' ' , 999 ) call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) test_passed ( 1 ) = (( error == 0 ). and .( trim ( string ) == 'one' )) print \"(A,L1)\" , '[section-1].(option-1) = \"' // trim ( string ) // '\", is correct? ' , test_passed ( 1 ) call fini % get ( section_name = 'section-1' , option_name = 'option-3' , val = string , error = error ) test_passed ( 2 ) = ( error /= 0 ) print \"(A,L1)\" , '[section-1].(option-3) dos not exist, is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram finer_test_get","tags":"","loc":"program/finer_test_get.html"},{"title":"finer_test_parse – FiNeR","text":"Uses finer penf program~~finer_test_parse~~UsesGraph program~finer_test_parse finer_test_parse module~finer finer program~finer_test_parse->module~finer penf penf program~finer_test_parse->penf module~finer_backend finer_backend module~finer->module~finer_backend module~finer_file_ini_t finer_file_ini_t module~finer->module~finer_file_ini_t module~finer_backend->penf module~finer_file_ini_t->penf module~finer_file_ini_t->module~finer_backend iso_fortran_env iso_fortran_env module~finer_file_ini_t->iso_fortran_env module~finer_section_t finer_section_t module~finer_file_ini_t->module~finer_section_t module~finer_option_t finer_option_t module~finer_file_ini_t->module~finer_option_t stringifor stringifor module~finer_file_ini_t->stringifor module~finer_section_t->penf module~finer_section_t->module~finer_backend module~finer_section_t->module~finer_option_t module~finer_section_t->stringifor module~finer_option_t->penf module~finer_option_t->module~finer_backend module~finer_option_t->stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FiNeR test: basic parse. Usage ./finer_test_parse Calls program~~finer_test_parse~~CallsGraph program~finer_test_parse finer_test_parse str str program~finer_test_parse->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables array error fini source string test_passed Source Code finer_test_parse Variables Type Attributes Name Initial real(kind=R4P), allocatable :: array (:) Array option. integer(kind=I4P) :: error Error code. type( file_ini ) :: fini INI file handler. character(len=:), allocatable :: source Testing string. character(len=:), allocatable :: string String option. logical :: test_passed (2) List of passed tests. Source Code program finer_test_parse !< FiNeR test: basic parse. !< !<### Usage !<```bash !< ./finer_test_parse !<``` use finer , only : file_ini use penf , only : I4P , R4P , str implicit none type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. real ( R4P ), allocatable :: array (:) !< Array option. integer ( I4P ) :: error !< Error code. logical :: test_passed ( 2 ) !< List of passed tests. source = '[section-1]' // new_line ( 'a' ) // & '; option-1 = two ; commented line' // new_line ( 'a' ) // & '# option-1 = three ; commented line' // new_line ( 'a' ) // & 'option-1 = one ; this is an inline comment' // new_line ( 'a' ) // & '! option-1 = four ; commented line' // new_line ( 'a' ) // & 'option-2 = 2.' // new_line ( 'a' ) // & '           3. ; continued line' // new_line ( 'a' ) // & 'option-3 = bar' // new_line ( 'a' ) // & '[section-2]' // new_line ( 'a' ) // & 'option-1 = foo' // new_line ( 'a' ) // & '[section-3]' // new_line ( 'a' ) // & 'option-1 = foo' // new_line ( 'a' ) // & 'option-2 = bar' // new_line ( 'a' ) print \"(A)\" , 'Source input' // new_line ( 'a' ) // new_line ( 'a' ) // source // new_line ( 'a' ) // new_line ( 'a' ) // 'Parse results' // new_line ( 'a' ) call fini % load ( source = source ) string = repeat ( ' ' , 999 ) call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) test_passed ( 1 ) = (( error == 0 ). and .( trim ( string ) == 'one' )) print \"(A,L1)\" , '[section-1].(option-1) = \"' // trim ( string ) // '\", is correct? ' , test_passed ( 1 ) allocate ( array ( 1 : fini % count_values ( section_name = 'section-1' , option_name = 'option-2' ))) call fini % get ( section_name = 'section-1' , option_name = 'option-2' , val = array , error = error ) test_passed ( 2 ) = (( error == 0 ). and .( array ( 1 ) == 2._R4P ). and .( array ( 2 ) == 3._R4P )) print \"(A,L1)\" , '[section-1].(option-2) = \"' // trim ( str ( array )) // '\", is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram finer_test_parse","tags":"","loc":"program/finer_test_parse.html"},{"title":"autotest – FiNeR","text":"Uses finer program~~autotest~~UsesGraph program~autotest autotest module~finer finer program~autotest->module~finer module~finer_backend finer_backend module~finer->module~finer_backend module~finer_file_ini_t finer_file_ini_t module~finer->module~finer_file_ini_t penf penf module~finer_backend->penf module~finer_file_ini_t->module~finer_backend module~finer_file_ini_t->penf iso_fortran_env iso_fortran_env module~finer_file_ini_t->iso_fortran_env module~finer_section_t finer_section_t module~finer_file_ini_t->module~finer_section_t stringifor stringifor module~finer_file_ini_t->stringifor module~finer_option_t finer_option_t module~finer_file_ini_t->module~finer_option_t module~finer_section_t->module~finer_backend module~finer_section_t->penf module~finer_section_t->stringifor module~finer_section_t->module~finer_option_t module~finer_option_t->module~finer_backend module~finer_option_t->penf module~finer_option_t->stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FiNeR autotest. Usage ./autotest Calls program~~autotest~~CallsGraph program~autotest autotest proc~file_ini_autotest file_ini_autotest program~autotest->proc~file_ini_autotest str str proc~file_ini_autotest->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code autotest Source Code program autotest !< FiNeR autotest. !< !<### Usage !<```bash !< ./autotest !<``` use finer , only : file_ini_autotest implicit none print \"(A)\" , 'FiNeR autotest' call file_ini_autotest endprogram autotest","tags":"","loc":"program/autotest.html"},{"title":"finer_backend.f90 – FiNeR","text":"FiNeR backends: globals definition. Files dependent on this one sourcefile~~finer_backend.f90~~AfferentGraph sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_test_parse.f90 finer_test_parse.f90 sourcefile~finer_test_parse.f90->sourcefile~finer.f90 sourcefile~finer_test_update_option.f90 finer_test_update_option.f90 sourcefile~finer_test_update_option.f90->sourcefile~finer.f90 sourcefile~finer_test_autotest.f90 finer_test_autotest.f90 sourcefile~finer_test_autotest.f90->sourcefile~finer.f90 sourcefile~finer_test_load.f90 finer_test_load.f90 sourcefile~finer_test_load.f90->sourcefile~finer.f90 sourcefile~finer_test_get.f90 finer_test_get.f90 sourcefile~finer_test_get.f90->sourcefile~finer.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules finer_backend Source Code finer_backend.f90 Source Code !< FiNeR backends: globals definition. module finer_backend !< FiNeR backends: globals definition. use penf implicit none save private integer ( I4P ), parameter , public :: ERR_OPTION_NAME = 1 !< Error flag for trapping errors in option name. integer ( I4P ), parameter , public :: ERR_OPTION_VALS = 2 !< Error flag for trapping errors in option values. integer ( I4P ), parameter , public :: ERR_OPTION = 3 !< Error flag for trapping errors in option. integer ( I4P ), parameter , public :: ERR_SECTION_NAME = 4 !< Error flag for trapping errors in section name. integer ( I4P ), parameter , public :: ERR_SECTION_OPTIONS = 5 !< Error flag for trapping errors in section options. integer ( I4P ), parameter , public :: ERR_SECTION = 6 !< Error flag for trapping errors in section. integer ( I4P ), parameter , public :: ERR_SOURCE_MISSING = 7 !< Error flag for trapping errors in file when source is missing. character ( 1 ), parameter , public :: DEF_OPT_SEP = '=' !< Default separator of option name/value. character ( * ), parameter , public :: COMMENTS = \"!;#\" !< Characters used for defining a comment line. character ( 1 ), parameter , public :: INLINE_COMMENT = ';' !< Inline comment delimiter. endmodule finer_backend","tags":"","loc":"sourcefile/finer_backend.f90.html"},{"title":"finer_option_t.F90 – FiNeR","text":"Option class definition. This file depends on sourcefile~~finer_option_t.f90~~EfferentGraph sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~finer_option_t.f90~~AfferentGraph sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_test_parse.f90 finer_test_parse.f90 sourcefile~finer_test_parse.f90->sourcefile~finer.f90 sourcefile~finer_test_update_option.f90 finer_test_update_option.f90 sourcefile~finer_test_update_option.f90->sourcefile~finer.f90 sourcefile~finer_test_autotest.f90 finer_test_autotest.f90 sourcefile~finer_test_autotest.f90->sourcefile~finer.f90 sourcefile~finer_test_load.f90 finer_test_load.f90 sourcefile~finer_test_load.f90->sourcefile~finer.f90 sourcefile~finer_test_get.f90 finer_test_get.f90 sourcefile~finer_test_get.f90->sourcefile~finer.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules finer_option_t Source Code finer_option_t.F90 Source Code !< Option class definition. module finer_option_t !< Option class definition. use finer_backend use penf #ifndef __GFORTRAN__ use stringifor_string_t , only : adjustl , index , scan , string #else use stringifor , only : adjustl , index , scan , string #endif implicit none private public :: option type :: option !< Option data of sections. private type ( string ) :: oname !< Option name. type ( string ) :: ovals !< Option values. type ( string ) :: ocomm !< Eventual option inline comment. contains ! public methods procedure , pass ( self ) :: count_values !< Counting option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_pairs !< Return option name/values pairs. procedure , pass ( self ) :: name_len !< Return option name length. procedure , pass ( self ) :: parse !< Parse option data. procedure , pass ( self ) :: print => print_option !< Pretty print data. procedure , pass ( self ) :: save => save_option !< Save data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: values_len !< Return option values length. ! operators overloading generic :: assignment ( = ) => assign_option !< Assignment overloading. generic :: operator ( == ) => option_eq_string , & option_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_comment !< Parse option inline comment. procedure , private , pass ( self ) :: parse_name !< Parse option name. procedure , private , pass ( self ) :: parse_value !< Parse option values. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_option !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: option_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: option_eq_character !< Equal to character logical operator. endtype option interface option !< Overload `option` name with a function returning a new (initiliazed) option instance. module procedure new_option endinterface option contains ! public methods elemental function count_values ( self , delimiter ) result ( Nv ) !< Get the number of values of option data. class ( option ), intent ( in ) :: self !< Option data. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. if ( self % ovals % is_allocated ()) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter Nv = self % ovals % count ( dlm ) + 1 else Nv = 0 endif endfunction count_values elemental subroutine free ( self ) !< Free dynamic memory. class ( option ), intent ( inout ) :: self !< Option data. call self % oname % free call self % ovals % free call self % ocomm % free endsubroutine free pure subroutine get_pairs ( self , pairs ) !< Return option name/values pairs. class ( option ), intent ( in ) :: self !< Option data. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: Nc !< Counter. if ( self % oname % is_allocated ()) then Nc = max ( self % oname % len (), self % ovals % len ()) allocate ( character ( Nc ) :: pairs ( 1 : 2 )) pairs ( 1 ) = self % oname % chars () pairs ( 2 ) = self % ovals % chars () endif endsubroutine get_pairs elemental function name_len ( self ) result ( length ) !< Return option name length. class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option name length. length = 0 if ( self % oname % is_allocated ()) length = self % oname % len () endfunction name_len elemental function values_len ( self ) result ( length ) !< Return option values length. class ( option ), intent ( in ) :: self !< Option data. integer :: length !< Option values length. length = 0 if ( self % ovals % is_allocated ()) length = self % ovals % len () endfunction values_len elemental subroutine parse ( self , sep , source , error ) !< Parse option data from a source string. class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. error = ERR_OPTION if ( scan ( adjustl ( source ), comments ) == 1 ) return call self % parse_name ( sep = sep , source = source , error = error ) call self % parse_value ( sep = sep , source = source , error = error ) call self % parse_comment endsubroutine parse ! private methods subroutine get_option ( self , val , error ) !< for getting option data value (scalar). class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. errd = ERR_OPTION_VALS if ( self % ovals % is_allocated ()) then select type ( val ) #ifdef _R16P type is ( real ( R16P )) val = self % ovals % to_number ( kind = 1._R16P ) #endif type is ( real ( R8P )) val = self % ovals % to_number ( kind = 1._R8P ) type is ( real ( R4P )) val = self % ovals % to_number ( kind = 1._R4P ) type is ( integer ( I8P )) val = self % ovals % to_number ( kind = 1_I8P ) type is ( integer ( I4P )) val = self % ovals % to_number ( kind = 1_I4P ) #ifndef _NVF type is ( integer ( I2P )) val = self % ovals % to_number ( kind = 1_I2P ) #endif type is ( integer ( I1P )) val = self % ovals % to_number ( kind = 1_I1P ) type is ( logical ) buffer = self % ovals % chars () read ( buffer , * ) val type is ( character ( * )) val = self % ovals % chars () endselect errd = 0 endif if ( present ( error )) error = errd endsubroutine get_option subroutine get_a_option ( self , val , delimiter , error ) !< Get option data values (array). class ( option ), intent ( in ) :: self !< Option data. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: Nv !< Number of values. type ( string ), allocatable :: valsV (:) !< String array of values. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: buffer !< Dummy buffer. integer ( I4P ) :: v !< Counter. errd = ERR_OPTION_VALS dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( self % ovals % is_allocated ()) then call self % ovals % split ( tokens = valsV , sep = dlm ) Nv = size ( valsV , dim = 1 ) select type ( val ) #ifdef _R16P type is ( real ( R16P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R16P ) enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R8P ) enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1._R4P ) enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I8P ) enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I4P ) enddo #ifndef _NVF type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I2P ) enddo #endif type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = valsV ( v )% to_number ( kind = 1_I1P ) enddo type is ( logical ) do v = 1 , Nv buffer = valsV ( v )% chars () read ( buffer , * ) val ( v ) enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v )% chars () enddo endselect errd = 0 endif if ( present ( error )) error = errd endsubroutine get_a_option elemental subroutine parse_comment ( self ) !< Parse option inline comment trimming it out from pure value string. class ( option ), intent ( inout ) :: self !< Option data. integer ( I4P ) :: pos !< Characters counter. if ( self % ovals % is_allocated ()) then pos = self % ovals % index ( INLINE_COMMENT ) if ( pos > 0 ) then if ( pos < self % ovals % len ()) self % ocomm = trim ( adjustl ( self % ovals % slice ( pos + 1 , self % ovals % len ()))) self % ovals = trim ( adjustl ( self % ovals % slice ( 1 , pos - 1 ))) endif endif endsubroutine parse_comment elemental subroutine parse_name ( self , sep , source , error ) !< Parse option name from a source string. class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. error = ERR_OPTION_NAME pos = index ( source , sep ) if ( pos > 0 ) then self % oname = trim ( adjustl ( source % slice ( 1 , pos - 1 ))) error = 0 endif endsubroutine parse_name elemental subroutine parse_value ( self , sep , source , error ) !< Parse option value from a source string. class ( option ), intent ( inout ) :: self !< Option data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( in ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos !< Characters counter. error = ERR_OPTION_VALS pos = index ( source , sep ) if ( pos > 0 ) then if ( pos < source % len ()) self % ovals = trim ( adjustl ( source % slice ( pos + 1 , source % len ()))) error = 0 endif endsubroutine parse_value subroutine print_option ( self , unit , retain_comments , pref , iostat , iomsg ) !< Print data with a pretty format. class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. if ( self % oname % is_allocated ()) then prefd = '' ; if ( present ( pref )) prefd = pref comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif endsubroutine print_option pure subroutine set_option ( self , val ) !< Set option data value (scalar). class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val !< Value. select type ( val ) #ifdef _R16P type is ( real ( R16P )) self % ovals = val #endif type is ( real ( R8P )) self % ovals = val type is ( real ( R4P )) self % ovals = val type is ( integer ( I8P )) self % ovals = val type is ( integer ( I4P )) self % ovals = val type is ( integer ( I2P )) self % ovals = val type is ( integer ( I1P )) self % ovals = val type is ( logical ) self % ovals = trim ( str ( n = val )) type is ( character ( * )) self % ovals = val endselect endsubroutine set_option pure subroutine set_a_option ( self , val , delimiter ) !< Set option data value (array). class ( option ), intent ( inout ) :: self !< Option data. class ( * ), intent ( in ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: v !< Counter. dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter self % ovals = '' select type ( val ) #ifdef _R16P type is ( real ( R16P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () #endif type is ( real ( R8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( real ( R4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I8P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I4P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I2P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( integer ( I1P )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( logical ) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( str ( n = val ( v ))) enddo self % ovals = self % ovals % strip () type is ( character ( * )) do v = 1 , size ( val , dim = 1 ) self % ovals = self % ovals // dlm // trim ( val ( v )) enddo self % ovals = self % ovals % strip () endselect endsubroutine set_a_option subroutine save_option ( self , unit , retain_comments , iostat , iomsg ) !< Save data. class ( option ), intent ( in ) :: self !< Option data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. character ( len = :), allocatable :: comment !< Eventual option comments. if ( self % oname % is_allocated ()) then comment = '' ; if ( self % ocomm % is_allocated (). and . retain_comments ) comment = ' ; ' // self % ocomm if ( self % ovals % is_allocated ()) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // self % ovals // comment else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) self % oname // ' = ' // comment endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endif endsubroutine save_option ! assignments elemental subroutine assign_option ( lhs , rhs ) !< Assignment between two options. class ( option ), intent ( inout ) :: lhs !< Left hand side. type ( option ), intent ( in ) :: rhs !< Rigth hand side. if ( rhs % oname % is_allocated ()) lhs % oname = rhs % oname if ( rhs % ovals % is_allocated ()) lhs % ovals = rhs % ovals if ( rhs % ocomm % is_allocated ()) lhs % ocomm = rhs % ocomm endsubroutine assign_option ! logical operators elemental function option_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. class ( option ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % oname == rhs endfunction option_eq_string elemental function option_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. class ( option ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % oname == rhs endfunction option_eq_character ! non TBP methods elemental function new_option ( option_name , option_values , option_comment ) !< Return a new (initiliazed) option instance. character ( * ), intent ( in ), optional :: option_name !< Option name. character ( * ), intent ( in ), optional :: option_values !< Option values. character ( * ), intent ( in ), optional :: option_comment !< Option comment. type ( option ) :: new_option !< New (initiliazed) option instance. if ( present ( option_name )) new_option % oname = option_name if ( present ( option_values )) new_option % ovals = option_values if ( present ( option_comment )) new_option % ocomm = option_comment endfunction new_option endmodule finer_option_t","tags":"","loc":"sourcefile/finer_option_t.f90.html"},{"title":"finer.f90 – FiNeR","text":"FiNeR, Fortran INI ParseR and generator. This file depends on sourcefile~~finer.f90~~EfferentGraph sourcefile~finer.f90 finer.f90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~finer.f90~~AfferentGraph sourcefile~finer.f90 finer.f90 sourcefile~finer_test_parse.f90 finer_test_parse.f90 sourcefile~finer_test_parse.f90->sourcefile~finer.f90 sourcefile~finer_test_update_option.f90 finer_test_update_option.f90 sourcefile~finer_test_update_option.f90->sourcefile~finer.f90 sourcefile~finer_test_autotest.f90 finer_test_autotest.f90 sourcefile~finer_test_autotest.f90->sourcefile~finer.f90 sourcefile~finer_test_load.f90 finer_test_load.f90 sourcefile~finer_test_load.f90->sourcefile~finer.f90 sourcefile~finer_test_get.f90 finer_test_get.f90 sourcefile~finer_test_get.f90->sourcefile~finer.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules finer Source Code finer.f90 Source Code !< FiNeR, Fortran INI ParseR and generator. module finer !< FiNeR, Fortran INI ParseR and generator. use finer_backend use finer_file_ini_t implicit none private public :: err_option_name public :: err_option_vals public :: err_option public :: err_section_name public :: err_section_options public :: err_section public :: err_source_missing public :: file_ini public :: file_ini_autotest endmodule finer","tags":"","loc":"sourcefile/finer.f90.html"},{"title":"finer_file_ini_t.F90 – FiNeR","text":"INI file class definition. This file depends on sourcefile~~finer_file_ini_t.f90~~EfferentGraph sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~finer_file_ini_t.f90~~AfferentGraph sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90 finer.f90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_test_parse.f90 finer_test_parse.f90 sourcefile~finer_test_parse.f90->sourcefile~finer.f90 sourcefile~finer_test_update_option.f90 finer_test_update_option.f90 sourcefile~finer_test_update_option.f90->sourcefile~finer.f90 sourcefile~finer_test_autotest.f90 finer_test_autotest.f90 sourcefile~finer_test_autotest.f90->sourcefile~finer.f90 sourcefile~finer_test_load.f90 finer_test_load.f90 sourcefile~finer_test_load.f90->sourcefile~finer.f90 sourcefile~finer_test_get.f90 finer_test_get.f90 sourcefile~finer_test_get.f90->sourcefile~finer.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules finer_file_ini_t Source Code finer_file_ini_t.F90 Source Code !< INI file class definition. module finer_file_ini_t !< INI file class definition. use finer_backend use finer_option_t , only : option use finer_section_t , only : section use penf ! use stringifor #ifndef __GFORTRAN__ use stringifor_string_t , only : adjustl , string #else use stringifor , only : adjustl , string #endif use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none private public :: file_ini public :: file_ini_autotest type :: file_ini !< INI file class. private character ( len = :), allocatable , public :: filename !< File name integer ( I4P ) :: Ns = 0 !< Number of sections. character ( 1 ) :: opt_sep = DEF_OPT_SEP !< Separator character of option name/value. type ( section ), allocatable :: sections (:) !< Sections. contains ! public methods generic :: add => add_section , & !< Add a section. add_option , & !< Add an option to a section (scalar). add_a_option !< Add an option to a section (array). procedure , pass ( self ) :: count_values !< Count option value(s). generic :: del => free_option_of_section , & !< Remove (freeing) an option of a section. free_section !< Remove (freeing) a section. procedure , pass ( self ) :: free !< Free dynamic memory destroyng file data. generic :: free_options => free_options_all , & !< Free all options. free_options_of_section , & !< Free all options of a section. free_option_of_section !< Free an option of a section. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: get_items !< Get list of pairs option name/value. procedure , pass ( self ) :: get_sections_list !< Get sections names list. procedure , pass ( self ) :: initialize !< Initialize file. procedure , pass ( self ) :: has_option !< Inquire the presence of an option. procedure , pass ( self ) :: has_section !< Inquire the presence of a section. generic :: index => index_section , & !< Return the index of a section. index_option !< Return the index of an option. procedure , pass ( self ) :: load !< Load file data. generic :: loop => loop_options_section , & !< Loop over options of a section. loop_options !< Loop over all options. procedure , pass ( self ) :: print => print_file_ini !< Pretty printing data. procedure , pass ( self ) :: save => save_file_ini !< Save data. procedure , pass ( self ) :: section => section_file_ini !< Get section name once provided an index. ! operators overloading generic :: assignment ( = ) => assign_file_ini !< Procedure for section assignment overloading. ! private methods procedure , private , pass ( self ) :: add_a_option !< Add an option to a section (array). procedure , private , pass ( self ) :: add_option !< Add an option to a section (scalar). procedure , private , pass ( self ) :: add_section !< Add a section. procedure , private , pass ( self ) :: free_options_all !< Free all options of all sections. procedure , private , pass ( self ) :: free_options_of_section !< Free all options of a section. procedure , private , pass ( self ) :: free_option_of_section !< Free an option of a section. procedure , private , pass ( self ) :: free_section !< Free a section. procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: index_option !< Return the index of an option. procedure , private , pass ( self ) :: index_section !< Return the index of a section. procedure , private , pass ( self ) :: loop_options !< Loop over all options. procedure , private , pass ( self ) :: loop_options_section !< Loop over options of a section. procedure , private , pass ( self ) :: parse !< Parse file data. ! assignments procedure , private , pass ( lhs ) :: assign_file_ini !< Assignment overloading. endtype file_ini contains ! public methods elemental function count_values ( self , delimiter , section_name , option_name ) result ( Nv ) !< Get the number of values of option into section data. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), optional , intent ( in ) :: delimiter !< Delimiter used for separating values. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: s !< Counter. if ( allocated ( self % sections )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then Nv = self % sections ( s )% count_values ( delimiter = dlm , option_name = option_name ) exit endif enddo endif endfunction count_values elemental subroutine free ( self ) !< Free dynamic memory. class ( file_ini ), intent ( inout ) :: self !< File data. if ( allocated ( self % filename )) deallocate ( self % filename ) if ( allocated ( self % sections )) then call self % sections % free deallocate ( self % sections ) endif self % Ns = 0 self % opt_sep = def_opt_sep endsubroutine free pure subroutine get_items ( self , items ) !< Get list of pairs option name/value. class ( file_ini ), intent ( in ) :: self !< File data. character ( len = :), allocatable , intent ( out ) :: items (:,:) !< Items, list of pairs option name/value for all options [1:No,1:2]. character ( len = :), allocatable :: pairs (:) !< Option name/values pairs. integer ( I4P ) :: mx_chars !< Maximum number of chars into name/value within all options. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: No !< Counter. mx_chars = MinI4P if ( allocated ( self % sections )) then No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then mx_chars = max ( mx_chars , self % sections ( s )% max_chars_len ()) No = No + self % sections ( s )% options_number () endif enddo if (( mx_chars > 0 ). and .( No > 0 )) then allocate ( character ( mx_chars ) :: items ( 1 : No , 1 : 2 )) No = 0 do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s )% has_options ()) then do o = 1 , self % sections ( s )% options_number () No = No + 1 call self % sections ( s )% option_pairs ( option_index = o , pairs = pairs ) items ( No , 1 ) = pairs ( 1 ) items ( No , 2 ) = pairs ( 2 ) enddo endif enddo endif endif endsubroutine get_items pure subroutine get_sections_list ( self , list ) !< Get sections names list. class ( file_ini ), intent ( in ) :: self !< File data. character ( len = :), allocatable , intent ( out ) :: list (:) !< Sections names list. integer :: max_len !< Max length of section name. integer :: s !< Counter. if ( allocated ( self % sections )) then max_len = MinI_P do s = 1 , self % Ns max_len = max ( max_len , len ( self % sections ( s )% name ())) enddo if ( max_len > 0 ) then allocate ( character ( len = max_len ) :: list ( 1 : self % Ns )) do s = 1 , self % Ns list ( s ) = self % sections ( s )% name () enddo endif endif endsubroutine get_sections_list function has_option ( self , option_name , section_name ) result ( pres ) !< Inquire the presence of (at least one) option with the name passed. !< !< Optional, the first matching section name is returned. !< !< @note All sections are searched and the first occurence is returned. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), optional , intent ( inout ) :: section_name !< Section name. logical :: pres !< Inquiring flag. integer ( I4P ) :: s !< Counter. pres = . false . if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) pres = ( self % sections ( s )% index ( option_name = option_name ) > 0 ) if ( pres ) then if ( present ( section_name )) section_name = self % sections ( s )% name () exit endif enddo endif endfunction has_option elemental function has_section ( self , section_name ) result ( pres ) !< Inquire the presence of (at least one) section with the name passed. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. logical :: pres !< Inquiring flag. pres = ( self % index ( section_name = section_name ) > 0 ) endfunction has_section elemental subroutine initialize ( self , filename ) !< Initialize file. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ), optional :: filename !< File name. call self % free if ( present ( filename )) self % filename = trim ( adjustl ( filename )) endsubroutine initialize subroutine load ( self , separator , filename , source , error ) !< Get file data from a file or a source string. !< !<### Usage !< !<##### Loading from a file !<```bash !<type(file_ini):: fini !<call fini%load(filename='path_to_my_file.ini') !<``` !< !<##### Loading from a source string !<```bash !<type(file_ini):: fini !<call fini%load(source='[section-1] option-1=one [section-2] option-2=due') !<``` class ( file_ini ), intent ( inout ) :: self !< File data. character ( 1 ), intent ( in ), optional :: separator !< Separator of options name/value. character ( * ), intent ( in ), optional :: filename !< File name. character ( * ), intent ( in ), optional :: source !< File source contents. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. type ( string ) :: source_ !< File source contents, local variable. errd = ERR_SOURCE_MISSING if ( present ( separator )) self % opt_sep = separator if ( present ( filename )) then self % filename = trim ( adjustl ( filename )) call source_ % read_file ( file = self % filename , iostat = errd ) elseif ( present ( source )) then source_ = source errd = 0 elseif ( allocated ( self % filename )) then call source_ % read_file ( file = self % filename , iostat = errd ) endif if ( errd <= 0 ) call self % parse ( source = source_ , error = errd ) if ( present ( error )) error = errd endsubroutine load subroutine print_file_ini ( self , unit , pref , retain_comments , iostat , iomsg ) !< Print data with a pretty format. class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. prefd = '' ; if ( present ( pref )) prefd = pref rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% print ( pref = prefd , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine print_file_ini subroutine save_file_ini ( self , retain_comments , iostat , iomsg , filename ) !< Save data. class ( file_ini ), intent ( inout ) :: self !< File data. logical , optional , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( * ), optional , intent ( in ) :: filename !< File name. logical :: rt_comm !< Flag for retaining eventual comments. integer ( I4P ) :: unit !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: s !< Counter. rt_comm = . false . ; if ( present ( retain_comments )) rt_comm = retain_comments if ( present ( filename )) self % filename = filename if ( allocated ( self % filename ). and . allocated ( self % sections )) then open ( newunit = unit , file = self % filename , action = 'WRITE' , iostat = iostatd , iomsg = iomsgd ) do s = 1 , size ( self % sections , dim = 1 ) call self % sections ( s )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = rt_comm ) enddo close ( unit = unit , iostat = iostatd , iomsg = iomsgd ) endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine save_file_ini pure function section_file_ini ( self , section_index ) result ( sname ) !< Get section name once an index (valid) is provided. class ( file_ini ), intent ( in ) :: self !< File data. integer ( I4P ), intent ( in ) :: section_index !< Section index. character ( len = :), allocatable :: sname !< Section name. if ( allocated ( self % sections )) then if (( section_index >= lbound ( self % sections , dim = 1 )). and .( section_index <= ubound ( self % sections , dim = 1 ))) then sname = self % sections ( section_index )% name () endif endif endfunction section_file_ini ! private methods pure subroutine add_a_option ( self , error , section_name , option_name , val ) !< Add an option (with array value). !< !< If the option already exists, its value is updated. class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val ( 1 :) !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine add_a_option pure subroutine add_option ( self , error , section_name , option_name , val ) !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = err_section_options call self % add ( section_name = section_name , error = errd ) if ( errd == 0 ) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% add ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine add_option pure subroutine add_section ( self , error , section_name ) !< Add a section. !< !< If the section already exists, it is left unchanged. class ( file_ini ), intent ( inout ) :: self !< File data. integer ( I4P ), optional , intent ( out ) :: error !< Error code. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: errd !< Error code. errd = err_section if ( allocated ( self % sections )) then if ( self % index ( section_name = section_name ) == 0 ) then ! section not present allocate ( sections ( 1 : size ( self % sections , dim = 1 ) + 1 )) sections ( 1 : size ( self % sections , dim = 1 )) = self % sections sections ( size ( self % sections , dim = 1 ) + 1 ) = section ( section_name = trim ( adjustl ( section_name ))) call move_alloc ( sections , self % sections ) self % Ns = self % Ns + 1 endif else allocate ( self % sections ( 1 : 1 )) self % sections ( 1 ) = section ( section_name = section_name ) self % Ns = self % Ns + 1 endif if ( self % index ( section_name = section_name ) > 0 ) errd = 0 if ( present ( error )) error = errd endsubroutine add_section elemental subroutine free_options_all ( self ) !< Free all options of all sections. class ( file_ini ), intent ( inout ) :: self !< File data. if ( allocated ( self % sections )) call self % sections % free_options endsubroutine free_options_all elemental subroutine free_option_of_section ( self , section_name , option_name ) !< Free all options of a section. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option  name. integer ( I4P ) :: s !< Counter. s = self % index ( section_name = section_name ) if ( s > 0 ) call self % sections ( s )% free_option ( option_name = option_name ) endsubroutine free_option_of_section elemental subroutine free_options_of_section ( self , section_name ) !< Free all options of a section. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: s !< Counter. if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == section_name ) then call self % sections ( s )% free_options exit endif enddo endif endsubroutine free_options_of_section elemental subroutine free_section ( self , section_name ) !< Free all options of a section. class ( file_ini ), intent ( inout ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. type ( section ), allocatable :: sections (:) !< Temporary sections array. integer ( I4P ) :: s !< Counter. s = self % index ( section_name = section_name ) if ( s > 0 ) then allocate ( sections ( 1 : size ( self % sections , dim = 1 ) - 1 )) if ( s == 1 ) then sections = self % sections ( 2 :) elseif ( s == size ( self % sections , dim = 1 )) then sections = self % sections (: s - 1 ) else sections (: s - 1 ) = self % sections (: s - 1 ) sections ( s : ) = self % sections ( s + 1 :) endif call move_alloc ( sections , self % sections ) self % Ns = self % Ns - 1 endif endsubroutine free_section subroutine get_a_option ( self , section_name , option_name , val , delimiter , error ) !< Get option value (array) class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = ERR_OPTION dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( delimiter = dlm , error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_a_option subroutine get_option ( self , section_name , option_name , val , error ) !< Get option value (scalar). class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: s !< Counter. errd = ERR_OPTION if ( allocated ( self % sections )) then do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then call self % sections ( s )% get ( error = errd , option_name = option_name , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_option elemental function index_option ( self , back , section_name , option_name ) result ( ind ) !< Return the index of the option (inside a  section) matching the name(s) passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. class ( file_ini ), intent ( in ) :: self !< File data. logical , optional , intent ( in ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( in ) :: option_name !< Option  name. character ( * ), intent ( in ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back s = self % index ( section_name = section_name , back = backd ) if ( s > 0 ) then ind = self % sections ( s )% index ( option_name = option_name , back = backd ) endif endif endfunction index_option elemental function index_section ( self , back , section_name ) result ( ind ) !< Return the index of the section matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. class ( file_ini ), intent ( IN ) :: self !< File data. logical , optional , intent ( IN ) :: back !< If back appears with the value true, the last matching index is returned. character ( * ), intent ( IN ) :: section_name !< Section name. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: s !< Counter. ind = 0 if ( allocated ( self % sections )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do s = size ( self % sections , dim = 1 ), 1 , - 1 if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo else do s = 1 , size ( self % sections , dim = 1 ) if ( self % sections ( s ) == trim ( adjustl ( section_name ))) then ind = s exit endif enddo endif endif endfunction index_section function loop_options_section ( self , section_name , option_pairs ) result ( again ) !< Loop returning option name/value defined into section. class ( file_ini ), intent ( in ) :: self !< File data. character ( * ), intent ( in ) :: section_name !< Section name. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Pairs option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ) :: s !< Counter. again = . false . s = self % index ( section_name = section_name ) if ( s > 0 ) then again = self % sections ( s )% loop ( option_pairs = option_pairs ) endif endfunction loop_options_section recursive function loop_options ( self , option_pairs ) result ( again ) !< Loop returning option name/value defined into all sections. class ( file_ini ), intent ( IN ) :: self !< File data. character ( len = :), allocatable , intent ( OUT ) :: option_pairs (:) !< Pairs option name/value [1:2]. logical :: again !< Flag continuing the loop. logical , save :: againO = . false . !< Flag continuing the loop. integer ( I4P ), save :: s = 0 !< Counter. again = . false . if ( allocated ( self % sections )) then if ( s == 0 ) then s = lbound ( self % sections , dim = 1 ) againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) again = . true . elseif ( s < ubound ( self % sections , dim = 1 )) then if (. not . againO ) s = s + 1 againO = self % loop ( section_name = self % sections ( s )% name (), option_pairs = option_pairs ) if (. not . againO ) then again = self % loop ( option_pairs = option_pairs ) else again = . true . endif else s = 0 againO = . false . again = . false . endif endif endfunction loop_options subroutine parse ( self , source , error ) !< Parse file either from the self source data or from a source string. class ( file_ini ), intent ( inout ) :: self !< File data. type ( string ), intent ( in ) :: source !< String source. integer ( I4P ), optional , intent ( out ) :: error !< Error code. integer ( I4P ) :: errd !< Error code. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. type ( string ) :: dummy !< Dummy string for parsing sections. integer ( I4P ) :: Ns !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: ss !< Counter. errd = err_source_missing call source % split ( tokens = tokens , sep = new_line ( 'a' )) Ns = 0 s = 0 do while ( s + 1 <= size ( tokens , dim = 1 )) s = s + 1 if ( scan ( adjustl ( tokens ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( tokens ( s ))), \"[\" ) == 1 ) then Ns = Ns + 1 dummy = trim ( adjustl ( tokens ( s ))) // new_line ( 'a' ) ss = s do while ( ss + 1 <= size ( tokens , dim = 1 )) ss = ss + 1 if ( index ( trim ( adjustl ( tokens ( ss ))), \"[\" ) == 1 ) then ! new section... go back exit else ! continuation of current section dummy = trim ( adjustl ( dummy )) // new_line ( 'a' ) // trim ( adjustl ( tokens ( ss ))) tokens ( ss ) = comments ! forcing skip this in the following scan endif enddo tokens ( s ) = trim ( adjustl ( dummy )) endif enddo if ( Ns > 0 ) then if ( allocated ( self % sections )) deallocate ( self % sections ) ; allocate ( self % sections ( 1 : Ns )) s = 0 ss = 0 do while ( s + 1 <= size ( tokens , dim = 1 )) s = s + 1 if ( scan ( adjustl ( tokens ( s )), comments ) == 1 ) cycle if ( index ( trim ( adjustl ( tokens ( s ))), \"[\" ) == 1 ) then ss = ss + 1 call self % sections ( ss )% parse ( sep = self % opt_sep , source = tokens ( s ), error = errd ) endif enddo endif self % Ns = Ns if ( present ( error )) error = errd endsubroutine parse ! assignments elemental subroutine assign_file_ini ( lhs , rhs ) !< Assignment between two INI files. class ( file_ini ), intent ( inout ) :: lhs !< Left hand side. type ( file_ini ), intent ( in ) :: rhs !< Rigth hand side. if ( allocated ( rhs % filename )) lhs % filename = rhs % filename if ( allocated ( rhs % sections )) then if ( allocated ( lhs % sections )) deallocate ( lhs % sections ) ; allocate ( lhs % sections ( 1 : size ( rhs % sections , dim = 1 ))) lhs % sections = rhs % sections endif lhs % Ns = rhs % Ns endsubroutine assign_file_ini ! non TBP methods subroutine file_ini_autotest () !< Autotest the library functionalities. type ( file_ini ) :: fini !< INI File. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. real ( R4P ), allocatable :: array (:) !< Array option. integer ( I4P ) :: error !< Error code. character ( len = :), allocatable :: items (:,:) !< List of all options name/value pairs. character ( len = :), allocatable :: item (:) !< Option name/value couple. character ( len = :), allocatable :: list (:) !< Sections names list. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: s !< Counter. source = '[section-1]' // new_line ( 'A' ) // & 'option-1 = one' // new_line ( 'A' ) // & 'option-2 = 2.' // new_line ( 'A' ) // & '           3. ; this is an inline comment' // new_line ( 'A' ) // & 'option-3 = bar ; this is an inline comment' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 = foo' print \"(A)\" , '' print \"(A)\" , \"Testing parsing procedures\" print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % load ( source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" string = '   ' call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-1 has values: ' , string allocate ( array ( 1 : fini % count_values ( section_name = 'section-1' , option_name = 'option-2' ))) call fini % get ( section_name = 'section-1' , option_name = 'option-2' , val = array , error = error ) if ( error == 0 ) print \"(A,3(F4.1,1X))\" , '  option-2 of section-1 has values: ' , array call fini % get ( section_name = 'section-1' , option_name = 'option-3' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-3 of section-1 has values: ' , string call fini % get ( section_name = 'section-2' , option_name = 'option-1' , val = string , error = error ) if ( error == 0 ) print \"(A,A)\" , '  option-1 of section-2 has values: ' , string print \"(A)\" , '' print \"(A)\" , \"Parsed data will be saved as (having retained inline comments that are trimmed out by default):\" call fini % print ( pref = '  ' , unit = stdout , retain_comments = . true .) call fini % save ( filename = 'foo.ini' , retain_comments = . true .) call fini % free print \"(A)\" , '' print \"(A)\" , \"Testing generating procedures\" call fini % add ( section_name = 'sec-foo' ) call fini % add ( section_name = 'sec-foo' , option_name = 'bar' , val =- 3 2.1_R8P ) call fini % add ( section_name = 'sec-foo' , option_name = 'baz' , val = ' hello FiNeR! ' ) call fini % add ( section_name = 'sec-foo' , option_name = 'array' , val = [ 1 , 2 , 3 , 4 ]) call fini % add ( section_name = 'sec-bar' ) call fini % add ( section_name = 'sec-bar' , option_name = 'bools' , val = [. true .,. false .,. false .]) call fini % add ( section_name = 'sec-bartolomeo' ) call fini % add ( section_name = 'sec-bartolomeo' , option_name = 'help' , val = 'I am Bartolomeo' ) print \"(A)\" , \"The autogenerated INI file will be saved as:\" call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing option baz\" call fini % del ( section_name = 'sec-foo' , option_name = 'baz' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing removing section sec-bar\" call fini % del ( section_name = 'sec-bar' ) call fini % print ( pref = '  ' , unit = stdout ) print \"(A)\" , '' print \"(A)\" , \"Testing introspective methods\" print \"(A,L1)\" , \"Is there option bar? \" , fini % has_option ( option_name = 'bar' ) print \"(A,L1)\" , \"Is there option baz? \" , fini % has_option ( option_name = 'baz' ) print \"(A,L1)\" , \"Is there section sec-bar? \" , fini % has_section ( section_name = 'sec-bar' ) print \"(A,L1)\" , \"Is there section sec-foo? \" , fini % has_section ( section_name = 'sec-foo' ) print \"(A)\" , '' print \"(A)\" , \"What are all options name/values pairs? Can I have a list? Yes, you can:\" call fini % get_items ( items = items ) do i = 1 , size ( items , dim = 1 ) print \"(A)\" , trim ( items ( i , 1 )) // ' = ' // trim ( items ( i , 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over options of a section:\" do s = 1 , fini % Ns print \"(A)\" , fini % section ( s ) do while ( fini % loop ( section_name = fini % section ( s ), option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo enddo print \"(A)\" , \"Testing sections names list inquire:\" call fini % get_sections_list ( list ) do s = 1 , fini % Ns print \"(A)\" , 'Sec. ' // trim ( str ( s , . true .)) // ': ' // trim ( list ( s )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing loop method over all options:\" do while ( fini % loop ( option_pairs = item )) print \"(A)\" , '  ' // trim ( item ( 1 )) // ' = ' // trim ( item ( 2 )) enddo print \"(A)\" , '' print \"(A)\" , \"Testing custom separator of option name/value:, use ':' instead of '='\" source = '[section-1]' // new_line ( 'A' ) // & 'option-1 : one' // new_line ( 'A' ) // & 'option-2 : 2.' // new_line ( 'A' ) // & '           3.' // new_line ( 'A' ) // & 'option-3 : bar' // new_line ( 'A' ) // & '[section-2]' // new_line ( 'A' ) // & 'option-1 : foo' print \"(A)\" , '' print \"(A)\" , \"Source to be parsed:\" print \"(A)\" , source call fini % free call fini % load ( separator = ':' , source = source ) print \"(A)\" , '' print \"(A)\" , \"Result of parsing:\" call fini % print ( pref = '  ' , unit = stdout ) ! remove \"foo.ini\" open ( newunit = i , file = 'foo.ini' ) ; close ( unit = i , status = 'DELETE' ) endsubroutine file_ini_autotest endmodule finer_file_ini_t","tags":"","loc":"sourcefile/finer_file_ini_t.f90.html"},{"title":"finer_section_t.f90 – FiNeR","text":"Section class definition. This file depends on sourcefile~~finer_section_t.f90~~EfferentGraph sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~finer_section_t.f90~~AfferentGraph sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_test_parse.f90 finer_test_parse.f90 sourcefile~finer_test_parse.f90->sourcefile~finer.f90 sourcefile~finer_test_update_option.f90 finer_test_update_option.f90 sourcefile~finer_test_update_option.f90->sourcefile~finer.f90 sourcefile~finer_test_autotest.f90 finer_test_autotest.f90 sourcefile~finer_test_autotest.f90->sourcefile~finer.f90 sourcefile~finer_test_load.f90 finer_test_load.f90 sourcefile~finer_test_load.f90->sourcefile~finer.f90 sourcefile~finer_test_get.f90 finer_test_get.f90 sourcefile~finer_test_get.f90->sourcefile~finer.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules finer_section_t Source Code finer_section_t.f90 Source Code !< Section class definition. module finer_section_t !< Section class definition. use finer_backend use finer_option_t , only : option use penf use stringifor , only : string , index implicit none private public :: section type :: section !< Section data of file INI. private character ( len = :), allocatable :: sname !< Section name. type ( option ), allocatable :: options (:) !< Section options. contains ! public methods generic :: add => add_option , & !< Add an option (scalar). add_a_option !< Add an option (array). procedure , pass ( self ) :: count_values !< Count option value(s). procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: free_options !< Free all options. procedure , pass ( self ) :: free_option !< Free a option. generic :: get => get_option , & !< Get option value (scalar). get_a_option !< Get option value (array). procedure , pass ( self ) :: has_options !< Inquire if section has options. procedure , pass ( self ) :: index => index_option !< Return the index of an option. procedure , pass ( self ) :: loop !< Loop over options. procedure , pass ( self ) :: max_chars_len !< Return max len of option-name/values on all options. procedure , pass ( self ) :: name !< Return section name. procedure , pass ( self ) :: options_number !< Return the options number. procedure , pass ( self ) :: option_pairs !< Return an option pairs. procedure , pass ( self ) :: parse !< Parse section data. procedure , pass ( self ) :: print => print_section !< Pretty print data. generic :: set => set_option , & !< Set option value (scalar). set_a_option !< Set option value (array). procedure , pass ( self ) :: save => save_section !< Save data. ! operators overloading generic :: assignment ( = ) => assign_section !< Assignment overloading. generic :: operator ( == ) => section_eq_string , & section_eq_character !< Equal operator overloading. ! private methods procedure , private , pass ( self ) :: add_option !< Add an option (scalar). procedure , private , pass ( self ) :: add_a_option !< Add an option (array). procedure , private , pass ( self ) :: get_option !< Get option value (scalar). procedure , private , pass ( self ) :: get_a_option !< Get option value (array). procedure , private , pass ( self ) :: parse_name !< Get section name. procedure , private , pass ( self ) :: parse_options !< Get section options. procedure , private , nopass :: sanitize_source !< Sanitize source. procedure , private , pass ( self ) :: set_option !< Set option value (scalar). procedure , private , pass ( self ) :: set_a_option !< Set option value (array). ! assignments procedure , private , pass ( lhs ) :: assign_section !< Assignment overloading. ! logical operators procedure , private , pass ( lhs ) :: section_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: section_eq_character !< Equal to character logical operator. endtype section interface section !< Overload `section` name with a function returning a new (itiliazed) section instance. module procedure new_section endinterface section contains ! public methods elemental function count_values ( self , option_name , delimiter ) result ( Nv ) !< Get the number of values of option into section data. class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ) :: Nv !< Number of values. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. if ( allocated ( self % options )) then dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then Nv = self % options ( o )% count_values ( delimiter = dlm ) exit endif enddo endif endfunction count_values elemental subroutine free ( self ) !< Free dynamic memory. class ( section ), intent ( inout ) :: self !< Section data. if ( allocated ( self % sname )) deallocate ( self % sname ) call self % free_options endsubroutine free elemental subroutine free_options ( self ) !< Free all options. class ( section ), intent ( inout ) :: self !< Section data. if ( allocated ( self % options )) then call self % options % free deallocate ( self % options ) endif endsubroutine free_options elemental subroutine free_option ( self , option_name ) !< Free an option. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: o !< Counter. if ( allocated ( self % options )) then o = self % index ( option_name = option_name ) if ( o > 0 ) then allocate ( options ( 1 : size ( self % options , dim = 1 ) - 1 )) if ( o == 1 ) then options = self % options ( 2 :) elseif ( o == size ( self % options , dim = 1 )) then options = self % options (: o - 1 ) else options (: o - 1 ) = self % options (: o - 1 ) options ( o : ) = self % options ( o + 1 :) endif call move_alloc ( options , self % options ) endif endif endsubroutine free_option elemental function has_options ( self ) !< Inquire is section has options (at least one). class ( section ), intent ( in ) :: self !< Section data. logical :: has_options !< Inquire result. has_options = allocated ( self % options ) endfunction has_options elemental function index_option ( self , option_name , back ) result ( ind ) !< Return the index of the option matching the name passed. !< !< @note The matching index returned is the first found if *back* is not passed or if *back=.false.*. On the contrary the last !< found is returned if *back=.true.*. class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. logical , intent ( in ), optional :: back !< If back appears with the value true, the last matching index is returned. integer ( I4P ) :: ind !< Index of searched section. logical :: backd !< Dummy back flag. integer ( I4P ) :: o !< Counter. ind = 0 if ( allocated ( self % options )) then backd = . false . ; if ( present ( back )) backd = back if ( backd ) then do o = size ( self % options , dim = 1 ), 1 , - 1 if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo else do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then ind = o exit endif enddo endif endif endfunction index_option function loop ( self , option_pairs ) result ( again ) !< Loop returning option name/value defined into section. class ( section ), intent ( in ) :: self !< Section data. character ( len = :), allocatable , intent ( out ) :: option_pairs (:) !< Couples option name/value [1:2]. logical :: again !< Flag continuing the loop. integer ( I4P ), save :: o = 0 !< Counter. again = . false . if ( allocated ( self % options )) then if ( o == 0 ) then o = lbound ( self % options , dim = 1 ) call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . elseif ( o < ubound ( self % options , dim = 1 )) then o = o + 1 call self % options ( o )% get_pairs ( pairs = option_pairs ) again = . true . else o = 0 again = . false . endif endif endfunction loop elemental function max_chars_len ( self ) !< Return the maximum number of characters between option-name/option-values on all options. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ) :: max_chars_len !< Inquire result. integer ( I4P ) :: o !< Counter. max_chars_len = MinI4P if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) max_chars_len = max ( max_chars_len , self % options ( o )% name_len (), self % options ( o )% values_len ()) enddo endif endfunction max_chars_len pure function name ( self ) !< Return section name. class ( section ), intent ( in ) :: self !< Section data. character ( len = len ( self % sname )) :: name !< Section data. if ( allocated ( self % sname )) name = self % sname endfunction name pure subroutine option_pairs ( self , option_index , pairs ) !< Return an option pairs. class ( section ), intent ( in ) :: self !< Option data. integer , intent ( in ) :: option_index !< Option index. character ( len = :), allocatable , intent ( out ) :: pairs (:) !< Option name/values pairs. call self % options ( option_index )% get_pairs ( pairs = pairs ) endsubroutine option_pairs elemental function options_number ( self ) !< Return the options number. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ) :: options_number !< Options number. options_number = 0 if ( allocated ( self % options )) options_number = size ( self % options , dim = 1 ) endfunction options_number elemental subroutine parse ( self , sep , source , error ) !< Gett section data from a source string. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. call self % sanitize_source ( sep = sep , source = source , error = error ) call self % parse_name ( source = source , error = error ) call self % parse_options ( sep = sep , source = source , error = error ) endsubroutine parse subroutine print_section ( self , unit , retain_comments , pref , iostat , iomsg ) !< Print data with a pretty format. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% print ( pref = prefd // '  ' , iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine print_section subroutine save_section ( self , unit , retain_comments , iostat , iomsg ) !< Save data. class ( section ), intent ( in ) :: self !< Section data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. logical , intent ( in ) :: retain_comments !< Flag for retaining eventual comments. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. integer ( I4P ) :: o !< Counter. if ( allocated ( self % sname )) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) '[' // self % sname // ']' if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) call self % options ( o )% save ( iostat = iostatd , iomsg = iomsgd , unit = unit , retain_comments = retain_comments ) enddo endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine save_section ! private methods pure subroutine add_option ( self , option_name , val , error ) !< Add an option (with scalar value). !< !< If the option already exists, its value is updated. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Option value. integer ( I4P ), intent ( out ), optional :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then call self % set ( error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd endsubroutine add_option pure subroutine add_a_option ( self , option_name , val , delimiter , error ) !< Add an option (with array value). !< !< If the option already exists, its value is updated. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Option value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. type ( option ), allocatable :: options (:) !< Temporary options array. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) if ( errd /= 0 ) then ! the option does not exist allocate ( options ( 1 : size ( self % options , dim = 1 ) + 1 )) options ( 1 : size ( self % options , dim = 1 ) ) = self % options options ( size ( self % options , dim = 1 ) + 1 ) = option ( option_name = option_name ) call move_alloc ( options , self % options ) call self % set ( error = errd , option_name = option_name , val = val ) endif else allocate ( self % options ( 1 : 1 )) self % options ( 1 ) = option ( option_name = option_name ) call self % set ( delimiter = dlm , error = errd , option_name = option_name , val = val ) endif if ( present ( error )) error = errd endsubroutine add_a_option subroutine get_option ( self , option_name , val , error ) !< Get option value (scalar). class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. errd = ERR_OPTION if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( error = errd , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_option subroutine get_a_option ( self , option_name , val , delimiter , error ) !< Procedure for getting option value (array). class ( section ), intent ( in ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( inout ) :: val ( 1 :) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. errd = ERR_OPTION dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% get ( delimiter = dlm , error = errd , val = val ) exit endif enddo endif if ( present ( error )) error = errd endsubroutine get_a_option elemental subroutine parse_name ( self , source , error ) !< Get section name from a source string. class ( section ), intent ( inout ) :: self !< Section data. type ( string ), intent ( in ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. integer ( I4P ) :: pos ( 1 : 2 ) !< Characters counter. error = ERR_SECTION_NAME pos ( 1 ) = index ( source , \"[\" ) pos ( 2 ) = index ( source , \"]\" ) if ( all ( pos > 0 )) then self % sname = trim ( adjustl ( source % slice ( pos ( 1 ) + 1 , pos ( 2 ) - 1 ))) error = 0 endif endsubroutine parse_name elemental subroutine parse_options ( self , sep , source , error ) !< Get section options from a source string. class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing section data. integer ( I4P ), intent ( out ) :: error !< Error code. type ( string ), allocatable :: tokens (:) !< Options strings tokenized. type ( string ) :: dummy !< Dummy string for parsing options. integer ( I4P ) :: No !< Counter. integer ( I4P ) :: o !< Counter. integer ( I4P ) :: oo !< Counter. error = 0 source = trim ( adjustl ( source % slice ( index ( source , \"]\" ) + 1 , source % len ()))) No = source % count ( substring = sep ) if ( No > 0 ) then call source % split ( tokens = tokens , sep = new_line ( 'a' )) if ( allocated ( self % options )) deallocate ( self % options ) ; allocate ( self % options ( 1 : No )) o = 0 oo = 0 do while ( o + 1 <= size ( tokens , dim = 1 )) o = o + 1 if ( index ( tokens ( o ), sep ) > 0 ) then oo = oo + 1 call self % options ( oo )% parse ( sep = sep , source = tokens ( o ), error = error ) endif enddo endif endsubroutine parse_options elemental subroutine sanitize_source ( sep , source , error ) !< Sanitize source. !< !<+ Join splitted options; character ( * ), intent ( in ) :: sep !< Separator of option name/value. type ( string ), intent ( inout ) :: source !< String containing option data. integer ( I4P ), intent ( out ) :: error !< Error code. type ( string ), allocatable :: tokens (:) !< Source tokens. integer ( I4P ) :: o !< Counter. call source % split ( tokens = tokens , sep = new_line ( 'a' )) if ( size ( tokens , dim = 1 ) > 1 ) then do o = 2 , size ( tokens , dim = 1 ) if ( tokens ( o )% index ( substring = sep ) == 0 ) tokens ( o - 1 ) = tokens ( o - 1 ) // ' ' // tokens ( o ) enddo endif source = '' do o = 1 , size ( tokens , dim = 1 ) if (( tokens ( o )% index ( substring = sep ) > 0 ). or .& ( tokens ( o )% index ( substring = '[' ) > 0 ). or .& ( tokens ( o )% index ( substring = ']' ) > 0 )) source = source // tokens ( o ) // new_line ( 'a' ) enddo source = source % slice ( 1 , source % len () - 1 ) error = 0 endsubroutine sanitize_source pure subroutine set_option ( self , option_name , val , error ) !< Set option value (scalar). class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val !< Value. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. integer ( I4P ) :: o !< Counter. errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( val = val ) errd = 0 exit endif enddo endif if ( present ( error )) error = errd endsubroutine set_option pure subroutine set_a_option ( self , option_name , val , delimiter , error ) !< Set option value (array). class ( section ), intent ( inout ) :: self !< Section data. character ( * ), intent ( in ) :: option_name !< Option name. class ( * ), intent ( in ) :: val (:) !< Value. character ( * ), intent ( in ), optional :: delimiter !< Delimiter used for separating values. integer ( I4P ), intent ( out ), optional :: error !< Error code. integer ( I4P ) :: errd !< Error code. character ( len = :), allocatable :: dlm !< Dummy string for delimiter handling. integer ( I4P ) :: o !< Counter. dlm = ' ' ; if ( present ( delimiter )) dlm = delimiter errd = ERR_SECTION_OPTIONS if ( allocated ( self % options )) then do o = 1 , size ( self % options , dim = 1 ) if ( self % options ( o ) == trim ( adjustl ( option_name ))) then call self % options ( o )% set ( delimiter = dlm , val = val ) errd = 0 exit endif enddo endif if ( present ( error )) error = errd endsubroutine set_a_option ! assignments elemental subroutine assign_section ( lhs , rhs ) !< Assignment between two sections. class ( section ), intent ( INOUT ) :: lhs !< Left hand side. type ( section ), intent ( IN ) :: rhs !< Rigth hand side. if ( allocated ( rhs % sname )) lhs % sname = rhs % sname if ( allocated ( rhs % options )) then if ( allocated ( lhs % options )) deallocate ( lhs % options ) ; allocate ( lhs % options ( 1 : size ( rhs % options , dim = 1 ))) lhs % options = rhs % options endif endsubroutine assign_section ! logical operators elemental function section_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. class ( section ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % sname == rhs endfunction section_eq_string elemental function section_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. class ( section ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % sname == rhs endfunction section_eq_character ! non TBP methods elemental function new_section ( section_name ) !< Return a new (initiliazed) section instance. character ( * ), intent ( in ), optional :: section_name !< Option name. type ( section ) :: new_section !< New (initiliazed) section instance. if ( present ( section_name )) new_section % sname = section_name endfunction new_section endmodule finer_section_t","tags":"","loc":"sourcefile/finer_section_t.f90.html"},{"title":"finer_test_load.f90 – FiNeR","text":"FiNeR test: basic load. This file depends on sourcefile~~finer_test_load.f90~~EfferentGraph sourcefile~finer_test_load.f90 finer_test_load.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer_test_load.f90->sourcefile~finer.f90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs finer_test_load Source Code finer_test_load.f90 Source Code !< FiNeR test: basic load. program finer_test_load !< FiNeR test: basic load. !< !<### Usage !<```bash !< ./finer_test_load !<``` use finer , only : file_ini use flap , only : command_line_interface use penf , only : I4P implicit none character ( 999 ) :: file_name !< Name of INI file. type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: items (:,:) !< Items pairs. integer :: i !< Counter. call cli_parse call fini % load ( filename = file_name ) call fini % get_items ( items ) do i = 1 , size ( items , dim = 1 ) print \"(A)\" , trim ( items ( i , 1 )) // ' = ' // trim ( items ( i , 2 )) enddo contains subroutine cli_parse () !< Build and parse test cli. type ( command_line_interface ) :: cli !< Test command line interface. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'finer_test_load' , & authors = 'S. Zaghi' , & help = 'Usage: ' , & examples = [ \"finer_test_load --ini test.ini\" ], & epilog = new_line ( 'a' ) // \"all done\" ) call cli % add ( switch = '--ini' , & switch_ab = '-i' , & help = 'name of ini file' , & required = . true ., & act = 'store' ) call cli % parse ( error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ini' , val = file_name ) endsubroutine cli_parse endprogram finer_test_load","tags":"","loc":"sourcefile/finer_test_load.f90.html"},{"title":"finer_test_update_option.f90 – FiNeR","text":"FiNeR test: update existing option. This file depends on sourcefile~~finer_test_update_option.f90~~EfferentGraph sourcefile~finer_test_update_option.f90 finer_test_update_option.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer_test_update_option.f90->sourcefile~finer.f90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs finer_test_update_option Source Code finer_test_update_option.f90 Source Code !< FiNeR test: update existing option. program finer_test_update_option !< FiNeR test: update existing option. !< !<### Usage !<```bash !< ./finer_test_update_option !<``` use , intrinsic :: iso_fortran_env , only : stdout => output_unit use finer , only : file_ini use penf , only : I4P , R4P , str implicit none type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. integer ( I4P ) :: error !< Error code. logical :: test_passed ( 3 ) !< List of passed tests. call fini % load ( filename = './src/tests/update_option.ini' ) call fini % print ( unit = stdout ) string = repeat ( ' ' , 999 ) call fini % get ( section_name = 'sec-foo' , option_name = 'bar2' , val = string , error = error ) test_passed ( 1 ) = (( error == 0 ). and .( trim ( string ) == '1.102325' )) call fini % add ( section_name = 'sec-foo' , option_name = 'bar2' , val = '0.99' ) call fini % print ( unit = stdout ) call fini % get ( section_name = 'sec-foo' , option_name = 'bar2' , val = string , error = error ) test_passed ( 2 ) = (( error == 0 ). and .( trim ( string ) == '0.99' )) call fini % get ( section_name = 'sec-foo' , option_name = 'bar' , val = string , error = error ) test_passed ( 3 ) = (( error == 0 ). and .( trim ( string ) == '-0.583000E+02' )) print \"(A,3L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram finer_test_update_option","tags":"","loc":"sourcefile/finer_test_update_option.f90.html"},{"title":"finer_test_get.f90 – FiNeR","text":"FiNeR test: basic get. This file depends on sourcefile~~finer_test_get.f90~~EfferentGraph sourcefile~finer_test_get.f90 finer_test_get.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer_test_get.f90->sourcefile~finer.f90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs finer_test_get Source Code finer_test_get.f90 Source Code !< FiNeR test: basic get. program finer_test_get !< FiNeR test: basic get. !< !<### Usage !<```bash !< ./finer_test_get !<``` use , intrinsic :: iso_fortran_env , only : output_unit use finer , only : file_ini use penf , only : I4P , R4P , str implicit none type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. integer ( I4P ) :: error !< Error code. logical :: test_passed ( 2 ) !< List of passed tests. source = '[section-1]' // new_line ( 'a' ) // & 'option-1 = one ; this is an inline comment' // new_line ( 'a' ) // & 'option-2 = bar' // new_line ( 'a' ) print \"(A)\" , 'Source input' // new_line ( 'a' ) // new_line ( 'a' ) // source // new_line ( 'a' ) // new_line ( 'a' ) // 'Parse results' // new_line ( 'a' ) call fini % load ( source = source , error = error ) string = repeat ( ' ' , 999 ) call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) test_passed ( 1 ) = (( error == 0 ). and .( trim ( string ) == 'one' )) print \"(A,L1)\" , '[section-1].(option-1) = \"' // trim ( string ) // '\", is correct? ' , test_passed ( 1 ) call fini % get ( section_name = 'section-1' , option_name = 'option-3' , val = string , error = error ) test_passed ( 2 ) = ( error /= 0 ) print \"(A,L1)\" , '[section-1].(option-3) dos not exist, is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram finer_test_get","tags":"","loc":"sourcefile/finer_test_get.f90.html"},{"title":"finer_test_parse.f90 – FiNeR","text":"FiNeR test: basic parse. This file depends on sourcefile~~finer_test_parse.f90~~EfferentGraph sourcefile~finer_test_parse.f90 finer_test_parse.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer_test_parse.f90->sourcefile~finer.f90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs finer_test_parse Source Code finer_test_parse.f90 Source Code !< FiNeR test: basic parse. program finer_test_parse !< FiNeR test: basic parse. !< !<### Usage !<```bash !< ./finer_test_parse !<``` use finer , only : file_ini use penf , only : I4P , R4P , str implicit none type ( file_ini ) :: fini !< INI file handler. character ( len = :), allocatable :: source !< Testing string. character ( len = :), allocatable :: string !< String option. real ( R4P ), allocatable :: array (:) !< Array option. integer ( I4P ) :: error !< Error code. logical :: test_passed ( 2 ) !< List of passed tests. source = '[section-1]' // new_line ( 'a' ) // & '; option-1 = two ; commented line' // new_line ( 'a' ) // & '# option-1 = three ; commented line' // new_line ( 'a' ) // & 'option-1 = one ; this is an inline comment' // new_line ( 'a' ) // & '! option-1 = four ; commented line' // new_line ( 'a' ) // & 'option-2 = 2.' // new_line ( 'a' ) // & '           3. ; continued line' // new_line ( 'a' ) // & 'option-3 = bar' // new_line ( 'a' ) // & '[section-2]' // new_line ( 'a' ) // & 'option-1 = foo' // new_line ( 'a' ) // & '[section-3]' // new_line ( 'a' ) // & 'option-1 = foo' // new_line ( 'a' ) // & 'option-2 = bar' // new_line ( 'a' ) print \"(A)\" , 'Source input' // new_line ( 'a' ) // new_line ( 'a' ) // source // new_line ( 'a' ) // new_line ( 'a' ) // 'Parse results' // new_line ( 'a' ) call fini % load ( source = source ) string = repeat ( ' ' , 999 ) call fini % get ( section_name = 'section-1' , option_name = 'option-1' , val = string , error = error ) test_passed ( 1 ) = (( error == 0 ). and .( trim ( string ) == 'one' )) print \"(A,L1)\" , '[section-1].(option-1) = \"' // trim ( string ) // '\", is correct? ' , test_passed ( 1 ) allocate ( array ( 1 : fini % count_values ( section_name = 'section-1' , option_name = 'option-2' ))) call fini % get ( section_name = 'section-1' , option_name = 'option-2' , val = array , error = error ) test_passed ( 2 ) = (( error == 0 ). and .( array ( 1 ) == 2._R4P ). and .( array ( 2 ) == 3._R4P )) print \"(A,L1)\" , '[section-1].(option-2) = \"' // trim ( str ( array )) // '\", is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram finer_test_parse","tags":"","loc":"sourcefile/finer_test_parse.f90.html"},{"title":"finer_test_autotest.f90 – FiNeR","text":"FiNeR autotest. This file depends on sourcefile~~finer_test_autotest.f90~~EfferentGraph sourcefile~finer_test_autotest.f90 finer_test_autotest.f90 sourcefile~finer.f90 finer.f90 sourcefile~finer_test_autotest.f90->sourcefile~finer.f90 sourcefile~finer_backend.f90 finer_backend.f90 sourcefile~finer.f90->sourcefile~finer_backend.f90 sourcefile~finer_file_ini_t.f90 finer_file_ini_t.F90 sourcefile~finer.f90->sourcefile~finer_file_ini_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_option_t.f90 finer_option_t.F90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_option_t.f90 sourcefile~finer_section_t.f90 finer_section_t.f90 sourcefile~finer_file_ini_t.f90->sourcefile~finer_section_t.f90 sourcefile~finer_option_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_backend.f90 sourcefile~finer_section_t.f90->sourcefile~finer_option_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs autotest Source Code finer_test_autotest.f90 Source Code !< FiNeR autotest. program autotest !< FiNeR autotest. !< !<### Usage !<```bash !< ./autotest !<``` use finer , only : file_ini_autotest implicit none print \"(A)\" , 'FiNeR autotest' call file_ini_autotest endprogram autotest","tags":"","loc":"sourcefile/finer_test_autotest.f90.html"}]}